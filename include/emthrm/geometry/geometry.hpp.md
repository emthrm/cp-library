---
data:
  _extendedDependsOn: []
  _extendedRequiredBy:
  - icon: ':heavy_check_mark:'
    path: include/emthrm/geometry/smallest_enclosing_circle.hpp
    title: "\u6700\u5C0F\u5305\u542B\u5186 (smallest enclosing circle)"
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.01.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (ccw(a,\
      \ b, c))"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.02.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u6700\u8FD1\
      \u70B9\u5BFE)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.03.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u5C04\u5F71\
      )"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.04.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u93E1\u6620\
      )"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.05.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u5E73\u884C\
      \ / \u5782\u76F4)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.06.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u7DDA\
      \u5206\u306E\u4EA4\u5DEE\u5224\u5B9A)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.07.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u7DDA\u5206\
      \u3068\u5186\u306E\u4EA4\u5DEE\u5224\u5B9A)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.08.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u7DDA\
      \u5206\u306E\u4EA4\u70B9)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.09.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u76F4\u7DDA\
      \u3068\u5186\u306E\u4EA4\u70B9)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.10.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u7DDA\u5206\
      \u3068\u5186\u306E\u4EA4\u70B9)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.11.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u5186\
      \u306E\u4EA4\u70B9)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.12.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u7DDA\
      \u5206\u306E\u8DDD\u96E2)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.13.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u63A5\u70B9\
      )"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.14.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u5186\
      \u306E\u5171\u901A\u63A5\u7DDA\u306E\u672C\u6570)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.15.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u5186\
      \u306E\u5171\u901A\u63A5\u7DDA)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.16.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u5186\
      \u306E\u5171\u901A\u90E8\u5206\u306E\u9762\u7A4D)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.17.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u591A\u89D2\
      \u5F62\u306E\u9762\u7A4D)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.18.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u591A\u89D2\
      \u5F62\u306B\u5BFE\u3059\u308B\u70B9\u306E\u5185\u5916\u5224\u5B9A)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.19.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u51F8\u6027\
      \u5224\u5B9A)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.20.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u51F8\u5305\
      )"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.21.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u51F8\u591A\
      \u89D2\u5F62\u306E\u5207\u65AD)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.22.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u51F8\u591A\
      \u89D2\u5F62\u306E\u76F4\u5F84)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.23.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u5358\u4F4D\
      \u30D9\u30AF\u30C8\u30EB)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.24.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u70B9\u306E\
      \u56DE\u8EE2)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/smallest_enclosing_circle.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u6700\u5C0F\u5305\u542B\u5186"
  - icon: ':heavy_check_mark:'
    path: test/math/quadratic_equation.test.cpp
    title: "\u6570\u5B66/\u4E00\u5143\u4E8C\u6B21\u65B9\u7A0B\u5F0F"
  _isVerificationFailed: false
  _pathExtension: hpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    links: []
  bundledCode: "#line 1 \"include/emthrm/geometry/geometry.hpp\"\n\n\n\n#include <algorithm>\n\
    #include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n\
    #include <iterator>\n#include <limits>\n#include <tuple>\n#include <utility>\n\
    #include <vector>\n\nnamespace emthrm {\n\nnamespace geometry {\n\nusing Real\
    \ = double;\nconstexpr long double PI = 3.14159265358979323846;\n\nint sgn(const\
    \ Real x) {\n  static constexpr Real EPS = 1e-8;\n  return x > EPS ? 1 : (x <\
    \ -EPS ? -1 : 0);\n}\n\nReal degree_to_radian(const Real d) { return d * PI /\
    \ 180; }\nReal radian_to_degree(const Real r) { return r * 180 / PI; }\n\nstruct\
    \ Point {\n  Real x, y;\n  explicit Point(const Real x = 0, const Real y = 0)\
    \ : x(x), y(y) {}\n  Real abs() const { return std::sqrt(norm()); }\n  Real arg()\
    \ const {\n    const Real res = std::atan2(y, x);\n    return res < 0 ? res +\
    \ PI * 2 : res;\n  }\n  Real norm() const { return x * x + y * y; }\n  Point rotate(const\
    \ Real angle) const {\n    const Real cs = std::cos(angle), sn = std::sin(angle);\n\
    \    return Point(x * cs - y * sn, x * sn + y * cs);\n  }\n  Point& operator+=(const\
    \ Point& p) {\n    x += p.x; y += p.y;\n    return *this;\n  }\n  Point& operator-=(const\
    \ Point& p) {\n    x -= p.x; y -= p.y;\n    return *this;\n  }\n  Point& operator*=(const\
    \ Real k) {\n    x *= k; y *= k;\n    return *this;\n  }\n  Point& operator/=(const\
    \ Real k) {\n    x /= k; y /= k;\n    return *this;\n  }\n  bool operator<(const\
    \ Point& p) const {\n    const int x_sgn = sgn(p.x - x);\n    return x_sgn !=\
    \ 0 ? x_sgn == 1 : sgn(p.y - y) == 1;\n  }\n  bool operator<=(const Point& p)\
    \ const { return !(p < *this); }\n  bool operator>(const Point& p) const { return\
    \ p < *this; }\n  bool operator>=(const Point& p) const { return !(*this < p);\
    \ }\n  Point operator+() const { return *this; }\n  Point operator-() const {\
    \ return Point(-x, -y); }\n  Point operator+(const Point& p) const { return Point(*this)\
    \ += p; }\n  Point operator-(const Point& p) const { return Point(*this) -= p;\
    \ }\n  Point operator*(const Real k) const { return Point(*this) *= k; }\n  Point\
    \ operator/(const Real k) const { return Point(*this) /= k; }\n  friend std::ostream&\
    \ operator<<(std::ostream& os, const Point& p) {\n    return os << '(' << p.x\
    \ << \", \" << p.y << ')';\n  }\n  friend std::istream& operator>>(std::istream&\
    \ is, Point& p) {\n    Real x, y; is >> x >> y;\n    p = Point(x, y);\n    return\
    \ is;\n  }\n};\n\nstruct Segment {\n  Point s, t;\n  explicit Segment(const Point&\
    \ s = Point(0, 0), const Point& t = Point(0, 0))\n      : s(s), t(t) {}\n};\n\
    struct Line : Segment {\n  using Segment::Segment;\n  explicit Line(const Real\
    \ a, const Real b, const Real c) {\n    if (sgn(a) == 0) {\n      s = Point(0,\
    \ -c / b); t = Point(1, s.y);\n    } else if (sgn(b) == 0) {\n      s = Point(-c\
    \ / a, 0); t = Point(s.x, 1);\n    } else if (sgn(c) == 0) {\n      s = Point(0,\
    \ 0); t = Point(1, -a / b);\n    } else {\n      s = Point(0, -c / b); t = Point(-c\
    \ / a, 0);\n    }\n  }\n};\n\nstruct Circle {\n  Point p; Real r;\n  explicit\
    \ Circle(const Point& p = Point(0, 0), const Real r = 0)\n      : p(p), r(r) {}\n\
    };\n\nPoint unit_vector(const Point& p) {\n  const Real a = p.abs();\n  return\
    \ Point(p.x / a, p.y / a);\n}\nstd::tuple<Point, Point> normal_unit_vector(const\
    \ Point& p) {\n  const Point u = unit_vector(p);\n  return {Point(-u.y, u.x),\
    \ Point(u.y, -u.x)};\n}\n\nReal cross(const Point& a, const Point& b) { return\
    \ a.x * b.y - a.y * b.x; }\nReal dot(const Point& a, const Point& b) { return\
    \ a.x * b.x + a.y * b.y; }\n\nint ccw(const Point& a, const Point& b, const Point&\
    \ c) {\n  const Point ab = b - a, ac = c - a;\n  const int sign = sgn(cross(ab,\
    \ ac));\n  if (sign == 0) {\n    if (sgn(dot(ab, ac)) == -1) return 2;\n    if\
    \ (sgn(ac.norm() - ab.norm()) == 1) return -2;\n  }\n  return sign;\n}\n\nReal\
    \ get_angle(const Point& a, const Point& b, const Point& c) {\n  Real ab = (a\
    \ - b).arg(), bc = (c - b).arg();\n  if (ab > bc) std::swap(ab, bc);\n  return\
    \ std::min(bc - ab, static_cast<Real>(PI * 2 - (bc - ab)));\n}\n\nReal closest_pair(std::vector<Point>\
    \ ps) {\n  const int n = ps.size();\n  assert(n >= 2);\n  std::sort(ps.begin(),\
    \ ps.end());\n  const std::function<Real(int, int)> f =\n      [&ps, &f](const\
    \ int left, const int right) -> Real {\n        const int mid = (left + right)\
    \ >> 1;\n        Real x_mid = ps[mid].x, d = std::numeric_limits<Real>::max();\n\
    \        if (left + 1 < mid) d = std::min(d, f(left, mid));\n        if (mid +\
    \ 1 < right) d = std::min(d, f(mid, right));\n        std::inplace_merge(std::next(ps.begin(),\
    \ left),\n                           std::next(ps.begin(), mid),\n           \
    \                std::next(ps.begin(), right),\n                           [](const\
    \ Point& a, const Point& b) -> bool {\n                             return sgn(b.y\
    \ - a.y) == 1;\n                           });\n        std::vector<Point> tmp;\n\
    \        for (int i = left; i < right; ++i) {\n          if (sgn(std::abs(ps[i].x\
    \ - x_mid) - d) == 1) continue;\n          for (int j = static_cast<int>(tmp.size())\
    \ - 1; j >= 0; --j) {\n            const Point v = ps[i] - tmp[j];\n         \
    \   if (sgn(v.y - d) == 1) break;\n            d = std::min(d, v.abs());\n   \
    \       }\n          tmp.emplace_back(ps[i]);\n        }\n        return d;\n\
    \      };\n  return f(0, n);\n}\n\nPoint projection(const Segment& a, const Point&\
    \ b) {\n  return a.s + (a.t - a.s) * dot(a.t - a.s, b - a.s) / (a.t - a.s).norm();\n\
    }\nPoint reflection(const Segment& a, const Point& b) {\n  return projection(a,\
    \ b) * 2 - b;\n}\n\nbool is_parallel(const Segment& a, const Segment& b) {\n \
    \ return sgn(cross(a.t - a.s, b.t - b.s)) == 0;\n}\nbool is_orthogonal(const Segment&\
    \ a, const Segment& b) {\n  return sgn(dot(a.t - a.s, b.t - b.s)) == 0;\n}\n\n\
    Real distance(const Point&, const Point&);\nReal distance(const Segment&, const\
    \ Point&);\nReal distance(const Line&, const Point&);\nint common_tangent_num(const\
    \ Circle&, const Circle&);\nbool has_intersected(const Segment& a, const Point&\
    \ b) {\n  return ccw(a.s, a.t, b) == 0;\n}\nbool has_intersected(const Segment&\
    \ a, const Segment& b) {\n  return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) <=\
    \ 0 &&\n         ccw(b.s, b.t, a.s) * ccw(b.s, b.t, a.t) <= 0;\n}\nbool has_intersected(const\
    \ Line& a, const Point& b) {\n  const int c = ccw(a.s, a.t, b);\n  return c !=\
    \ 1 && c != -1;\n}\nbool has_intersected(const Line& a, const Segment& b) {\n\
    \  return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) != 1;\n}\nbool has_intersected(const\
    \ Line& a, const Line& b) {\n  return sgn(cross(a.t - a.s, b.t - b.s)) != 0 ||\n\
    \         sgn(cross(a.t - a.s, b.s - a.s)) == 0;\n}\nbool has_intersected(const\
    \ Circle& a, const Point& b) {\n  return sgn(distance(a.p, b) - a.r) == 0;\n}\n\
    bool has_intersected(const Circle& a, const Segment& b) {\n  return sgn(a.r -\
    \ distance(b, a.p)) != -1 &&\n         sgn(std::max(distance(a.p, b.s), distance(a.p,\
    \ b.t)) - a.r) != -1;\n}\nbool has_intersected(const Circle& a, const Line& b)\
    \ {\n  return sgn(a.r - distance(b, a.p)) != -1;\n}\nbool has_intersected(const\
    \ Circle& a, const Circle& b) {\n  const int num = common_tangent_num(a, b);\n\
    \  return 1 <= num && num <= 3;\n}\n\nPoint intersection(const Line& a, const\
    \ Line& b) {\n  assert(has_intersected(a, b) && !is_parallel(a, b));\n  const\
    \ Point va = a.t - a.s, vb = b.t - b.s;\n  return a.s + va * cross(vb, b.s - a.s)\
    \ / cross(vb, va);\n}\nPoint intersection(const Segment& a, const Segment& b)\
    \ {\n  assert(has_intersected(a, b));\n  if (is_parallel(a, b)) {\n    if (sgn(distance(a.s,\
    \ b.s)) == 0) {\n      assert(sgn(dot(a.t - a.s, b.t - a.s)) == -1);\n      return\
    \ a.s;\n    } else if (sgn(distance(a.s, b.t)) == 0) {\n      assert(sgn(dot(a.t\
    \ - a.s, b.s - a.s)) == -1);\n      return a.s;\n    } else if (sgn(distance(a.t,\
    \ b.s)) == 0) {\n      assert(sgn(dot(a.s - a.t, b.t - a.t)) == -1);\n      return\
    \ a.t;\n    } else if (sgn(distance(a.t, b.t)) == 0) {\n      assert(sgn(dot(a.s\
    \ - a.t, b.s - a.t)) == -1);\n      return a.t;\n    } else {\n      assert(false);\n\
    \    }\n  } else {\n    return intersection(Line(a.s, a.t), Line(b.s, b.t));\n\
    \  }\n}\nPoint intersection(const Line& a, const Segment& b) {\n  assert(has_intersected(a,\
    \ b));\n  return intersection(a, Line(b.s, b.t));\n}\nstd::vector<Point> intersection(const\
    \ Circle& a, const Line& b) {\n  const Point pro = projection(b, a.p);\n  const\
    \ Real nor = (a.p - pro).norm();\n  const int sign = sgn(a.r - std::sqrt(nor));\n\
    \  if (sign == -1) return {};\n  if (sign == 0) return {pro};\n  const Point tmp\
    \ = unit_vector(b.t - b.s) * std::sqrt(a.r * a.r - nor);\n  return {pro + tmp,\
    \ pro - tmp};\n}\nstd::vector<Point> intersection(const Circle& a, const Segment&\
    \ b) {\n  if (!has_intersected(a, b)) return {};\n  const std::vector<Point> res\
    \ = intersection(a, Line(b.s, b.t));\n  if (sgn(distance(a.p, b.s) - a.r) != -1\
    \ &&\n      sgn(distance(a.p, b.t) - a.r) != -1) {\n    return res;\n  }\n  return\
    \ {res[sgn(dot(res[0] - b.s, res[0] - b.t)) == 1 ? 1 : 0]};\n}\nstd::vector<Point>\
    \ intersection(const Circle& a, const Circle& b) {\n  const int num = common_tangent_num(a,\
    \ b);\n  if (num == 0 || num == 4) return {};\n  const Real alpha = (b.p - a.p).arg();\n\
    \  if (num == 1 || num == 3) {\n    return {Point(a.p.x + a.r * std::cos(alpha),\n\
    \                  a.p.y + a.r * std::sin(alpha))};\n  }\n  const Real dist =\
    \ (b.p - a.p).norm();\n  const Real beta =\n      std::acos((dist + a.r * a.r\
    \ - b.r * b.r) / (2 * std::sqrt(dist) * a.r));\n  return {\n      a.p + Point(a.r\
    \ * std::cos(alpha + beta), a.r * std::sin(alpha + beta)),\n      a.p + Point(a.r\
    \ * std::cos(alpha - beta), a.r * std::sin(alpha - beta))};\n}\n\nReal distance(const\
    \ Point& a, const Point& b) { return (b - a).abs(); }\nReal distance(const Segment&\
    \ a, const Point& b) {\n  const Point foot = projection(a, b);\n  return has_intersected(a,\
    \ foot) ?\n         distance(foot, b) : std::min(distance(a.s, b), distance(a.t,\
    \ b));\n}\nReal distance(const Segment& a, const Segment& b) {\n  return has_intersected(a,\
    \ b) ? 0 :\n         std::min({distance(a, b.s), distance(a, b.t),\n         \
    \          distance(b, a.s), distance(b, a.t)});\n}\nReal distance(const Line&\
    \ a, const Point& b) {\n  return distance(projection(a, b), b);\n}\nReal distance(const\
    \ Line& a, const Segment& b) {\n  return has_intersected(a, b) ?\n         0 :\
    \ std::min(distance(a, b.s), distance(a, b.t));\n}\nReal distance(const Line&\
    \ a, const Line& b) {\n  return has_intersected(a, b) ? 0 : distance(a, b.s);\n\
    }\n\nstd::vector<Point> tangency(const Circle& a, const Point& b) {\n  const Real\
    \ dist = distance(a.p, b);\n  const int sign = sgn(dist - a.r);\n  if (sign ==\
    \ -1) return {};\n  if (sign == 0) return {b};\n  const Real alpha = (b - a.p).arg(),\
    \ beta = std::acos(a.r / dist);\n  return {\n      a.p + Point(a.r * std::cos(alpha\
    \ + beta), a.r * std::sin(alpha + beta)),\n      a.p + Point(a.r * std::cos(alpha\
    \ - beta), a.r * std::sin(alpha - beta))};\n}\nint common_tangent_num(const Circle&\
    \ a, const Circle& b) {\n  const Real dist = distance(a.p, b.p);\n  int sign =\
    \ sgn(a.r + b.r - dist);\n  if (sign == -1) return 4;\n  if (sign == 0) return\
    \ 3;\n  sign = sgn((sgn(a.r - b.r) == -1 ? b.r - a.r : a.r - b.r) - dist);\n \
    \ if (sign == -1) return 2;\n  if (sign == 0) return 1;\n  return 0;\n}\nstd::vector<Line>\
    \ common_tangent(const Circle& a, const Circle& b) {\n  std::vector<Line> tangents;\n\
    \  const Real dist = distance(a.p, b.p), argument = (b.p - a.p).arg();\n  int\
    \ sign = sgn(a.r + b.r - dist);\n  if (sign == -1) {\n    const Real ac = std::acos((a.r\
    \ + b.r) / dist);\n    Real alpha = argument + ac, cs = std::cos(alpha), sn =\
    \ std::sin(alpha);\n    tangents.emplace_back(a.p + Point(a.r * cs, a.r * sn),\n\
    \                          b.p + Point(-b.r * cs, -b.r * sn));\n    alpha = argument\
    \ - ac; cs = std::cos(alpha); sn = std::sin(alpha);\n    tangents.emplace_back(a.p\
    \ + Point(a.r * cs, a.r * sn),\n                          b.p + Point(-b.r * cs,\
    \ -b.r * sn));\n  } else if (sign == 0) {\n    const Point s =\n        a.p +\
    \ Point(a.r * std::cos(argument), a.r * std::sin(argument));\n    tangents.emplace_back(s,\
    \ s + std::get<0>(normal_unit_vector(b.p - a.p)));\n  }\n  if (sgn(b.r - a.r)\
    \ == -1) {\n    sign = sgn(a.r - b.r - dist);\n    if (sign == -1) {\n      const\
    \ Real at = std::acos((a.r - b.r) / dist);\n      Real alpha = argument + at,\
    \ cs = std::cos(alpha), sn = std::sin(alpha);\n      tangents.emplace_back(a.p\
    \ + Point(a.r * cs, a.r * sn),\n                            b.p + Point(b.r *\
    \ cs, b.r * sn));\n      alpha = argument - at; cs = std::cos(alpha); sn = std::sin(alpha);\n\
    \      tangents.emplace_back(a.p + Point(a.r * cs, a.r * sn),\n              \
    \              b.p + Point(b.r * cs, b.r * sn));\n    } else if (sign == 0) {\n\
    \      const Point s =\n          a.p + Point(a.r * std::cos(argument), a.r *\
    \ std::sin(argument));\n      tangents.emplace_back(s, s + std::get<0>(normal_unit_vector(b.p\
    \ - a.p)));\n    }\n  } else {\n    sign = sgn(b.r - a.r - dist);\n    if (sign\
    \ == -1) {\n      const Real at = std::acos((b.r - a.r) / dist);\n      Real alpha\
    \ = argument - at, cs = std::cos(alpha), sn = std::sin(alpha);\n      tangents.emplace_back(a.p\
    \ + Point(-a.r * cs, -a.r * sn),\n                            b.p + Point(-b.r\
    \ * cs, -b.r * sn));\n      alpha = argument + at; cs = std::cos(alpha); sn =\
    \ std::sin(alpha);\n      tangents.emplace_back(a.p + Point(-a.r * cs, -a.r *\
    \ sn),\n                            b.p + Point(-b.r * cs, -b.r * sn));\n    }\
    \ else if (sign == 0) {\n      const Point s =\n          b.p + Point(-b.r * std::cos(argument),\
    \ -b.r * std::sin(argument));\n      tangents.emplace_back(s, s + std::get<0>(normal_unit_vector(a.p\
    \ - b.p)));\n    }\n  }\n  return tangents;\n}\n\nReal intersection_area(const\
    \ Circle& a, const Circle& b) {\n  const Real nor = (b.p - a.p).norm(), dist =\
    \ std::sqrt(nor);\n  if (sgn(a.r + b.r - dist) != 1) return 0;\n  if (sgn(std::abs(a.r\
    \ - b.r) - dist) != -1) {\n    return std::min(a.r, b.r) * std::min(a.r, b.r)\
    \ * PI;\n  }\n  const Real alpha =\n      std::acos((nor + a.r * a.r - b.r * b.r)\
    \ / (2 * dist * a.r));\n  const Real beta = std::acos((nor + b.r * b.r - a.r *\
    \ a.r) / (2 * dist * b.r));\n  return (alpha - std::sin(alpha + alpha) * 0.5)\
    \ * a.r * a.r +\n         (beta - std::sin(beta + beta) * 0.5) * b.r * b.r;\n\
    }\n\nusing Polygon = std::vector<Point>;\n\nReal area(Polygon a) {\n  const int\
    \ n = a.size();\n  a.resize(n + 1);\n  a.back() = a.front();\n  Real res = 0;\n\
    \  for (int i = 0; i < n; ++i) {\n    res += cross(a[i], a[i + 1]);\n  }\n  return\
    \ res * 0.5;\n}\n\nPoint centroid(Polygon a) {\n  const int n = a.size();\n  a.resize(n\
    \ + 1);\n  a.back() = a.front();\n  Point res(0, 0);\n  Real den = 0;\n  for (int\
    \ i = 0; i < n; ++i) {\n    const Real cro = cross(a[i], a[i + 1]);\n    res +=\
    \ (a[i] + a[i + 1]) / 3 * cro;\n    den += cro;\n  }\n  return res / den;\n}\n\
    \nint contains(Polygon a, const Point &b) {\n  const int n = a.size();\n  a.resize(n\
    \ + 1);\n  a.back() = a.front();\n  bool is_in = false;\n  for (int i = 0; i <\
    \ n; ++i) {\n    Point p = a[i] - b, q = a[i + 1] - b;\n    if (sgn(q.y - p.y)\
    \ == -1) std::swap(p, q);\n    const int sign = sgn(cross(p, q));\n    if (sign\
    \ == 1 && sgn(p.y) != 1 && sgn(q.y) == 1) is_in = !is_in;\n    if (sign == 0 &&\
    \ sgn(dot(p, q)) != 1) return 1;\n  }\n  return is_in ? 2 : 0;\n}\n\nbool is_convex(Polygon\
    \ a) {\n  const int n = a.size();\n  a.resize(n + 2);\n  a[n] = a[0];\n  a[n +\
    \ 1] = a[1];\n  for (int i = 1; i <= n; ++i) {\n    if (ccw(a[i - 1], a[i], a[i\
    \ + 1]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon monotone_chain(std::vector<Point>\
    \ ps, const bool is_tight = true) {\n  const int n = ps.size();\n  std::sort(ps.begin(),\
    \ ps.end());\n  Polygon convex_hull(n << 1);\n  int idx = 0;\n  for (int i = 0;\
    \ i < n; convex_hull[idx++] = ps[i++]) {\n    while (idx >= 2 &&\n           sgn(cross(convex_hull[idx\
    \ - 1] - convex_hull[idx - 2],\n                     ps[i] - convex_hull[idx -\
    \ 1])) < is_tight) {\n      --idx;\n    }\n  }\n  for (int i = n - 2, border =\
    \ idx + 1; i >= 0; convex_hull[idx++] = ps[i--]) {\n    while (idx >= border &&\n\
    \           sgn(cross(convex_hull[idx - 1] - convex_hull[idx - 2],\n         \
    \            ps[i] - convex_hull[idx - 1])) < is_tight) {\n      --idx;\n    }\n\
    \  }\n  convex_hull.resize(idx - 1);\n  return convex_hull;\n}\n\nPolygon cut_convex(Polygon\
    \ a, const Line& b) {\n  const int n = a.size();\n  a.resize(n + 1);\n  a.back()\
    \ = a.front();\n  Polygon res;\n  for (int i = 0; i < n; ++i) {\n    const int\
    \ c = ccw(b.s, b.t, a[i]);\n    if (c != -1) res.emplace_back(a[i]);\n    if (c\
    \ * ccw(b.s, b.t, a[i + 1]) == -1) {\n      res.emplace_back(intersection(Line(a[i],\
    \ a[i + 1]), b));\n    }\n  }\n  return res.size() < 3 ? Polygon() : res;\n}\n\
    \nstd::tuple<Point, Point> rotating_calipers(Polygon a) {\n  const int n = a.size();\n\
    \  if (n <= 2) {\n    assert(n == 2);\n    return {a[0], a[1]};\n  }\n  a.resize(n\
    \ + 1);\n  a.back() = a.front();\n  int high = 0, low = 0;\n  for (int i = 1;\
    \ i < n; ++i) {\n    if (a[i].y > a[high].y) high = i;\n    if (a[i].y < a[low].y)\
    \ low = i;\n  }\n  Real max_norm = (a[high] - a[low]).norm();\n  int i = high,\
    \ j = low, argmax_i = i, argmax_j = j;\n  do {\n    int* i_or_j = &(sgn(cross(a[i\
    \ + 1] - a[i], a[j + 1] - a[j])) != -1 ? j : i);\n    if (++(*i_or_j) == n) *i_or_j\
    \ = 0;\n    const Real tmp = (a[j] - a[i]).norm();\n    if (sgn(tmp - max_norm)\
    \ == 1) {\n      max_norm = tmp;\n      argmax_i = i; argmax_j = j;\n    }\n \
    \ } while (i != high || j != low);\n  return {a[argmax_i], a[argmax_j]};\n}\n\n\
    }  // namespace geometry\n\n// namespace geometry {\n\n// using Integer = long\
    \ long;\n\n// int sgn(const Integer x) {\n//   return x > 0 ? 1 : (x < 0 ? -1\
    \ : 0);\n// }\n\n// struct Point {\n//   Integer x, y;\n//   explicit Point(const\
    \ Integer x = 0, const Integer y = 0) : x(x), y(y) {}\n//   Integer norm() const\
    \ { return x * x + y * y; }\n//   Point& operator+=(const Point& p) {\n//    \
    \ x += p.x; y += p.y;\n//     return *this;\n//   }\n//   Point& operator-=(const\
    \ Point& p) {\n//     x -= p.x; y -= p.y;\n//     return *this;\n//   }\n//  \
    \ Point& operator*=(const Integer k) {\n//     x *= k; y *= k;\n//     return\
    \ *this;\n//   }\n//   Point& operator/=(const Integer k) {\n//     x /= k; y\
    \ /= k;\n//     return *this;\n//   }\n//   bool operator<(const Point& p) const\
    \ {\n//     const int x_sgn = sgn(p.x - x);\n//     return x_sgn != 0 ? x_sgn\
    \ == 1 : sgn(p.y - y) == 1;\n//   }\n//   bool operator<=(const Point& p) const\
    \ { return !(p < *this); }\n//   bool operator>(const Point& p) const { return\
    \ p < *this; }\n//   bool operator>=(const Point& p) const { return !(*this <\
    \ p); }\n//   Point operator+() const { return *this; }\n//   Point operator-()\
    \ const { return Point(-x, -y); }\n//   Point operator+(const Point& p) const\
    \ { return Point(*this) += p; }\n//   Point operator-(const Point& p) const {\
    \ return Point(*this) -= p; }\n//   Point operator*(const Integer k) const { return\
    \ Point(*this) *= k; }\n//   Point operator/(const Integer k) const { return Point(*this)\
    \ /= k; }\n//   friend std::ostream& operator<<(std::ostream& os, const Point&\
    \ p) {\n//     return os << '(' << p.x << \", \" << p.y << ')';\n//   }\n//  \
    \ friend std::istream& operator>>(std::istream& is, Point& p) {\n//     Integer\
    \ x, y; is >> x >> y;\n//     p = Point(x, y);\n//     return is;\n//   }\n//\
    \ };\n\n// struct Segment {\n//   Point s, t;\n//   explicit Segment(const Point&\
    \ s = Point(0, 0), const Point& t = Point(0, 0))\n//       : s(s), t(t) {}\n//\
    \ };\n// struct Line : Segment {\n//   using Segment::Segment;\n// };\n\n// struct\
    \ Circle {\n//   Point p; Integer r;\n//   explicit Circle(const Point& p = Point(0,\
    \ 0), const Integer r = 0)\n//       : p(p), r(r) {}\n// };\n\n// Integer cross(const\
    \ Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n// Integer dot(const\
    \ Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n\n// int ccw(const\
    \ Point& a, const Point& b, const Point& c) {\n//   const Point ab = b - a, ac\
    \ = c - a;\n//   const int sign = sgn(cross(ab, ac));\n//   if (sign == 0) {\n\
    //     if (sgn(dot(ab, ac)) == -1) return 2;\n//     if (sgn(ac.norm() - ab.norm())\
    \ == 1) return -2;\n//   }\n//   return sign;\n// }\n\n// Integer closest_pair(std::vector<Point>\
    \ ps) {\n//   const int n = ps.size();\n//   assert(n >= 2);\n//   std::sort(ps.begin(),\
    \ ps.end());\n//   const std::function<Integer(int, int)> f =\n//       [&ps,\
    \ &f](const int left, const int right) -> Integer {\n//         const int mid\
    \ = (left + right) >> 1;\n//         Integer x_mid = ps[mid].x, d = std::numeric_limits<Integer>::max();\n\
    //         if (left + 1 < mid) d = std::min(d, f(left, mid));\n//         if (mid\
    \ + 1 < right) d = std::min(d, f(mid, right));\n//         std::inplace_merge(std::next(ps.begin(),\
    \ left),\n//                            std::next(ps.begin(), mid),\n//      \
    \                      std::next(ps.begin(), right),\n//                     \
    \       [](const Point& a, const Point& b) -> bool {\n//                     \
    \         return sgn(b.y - a.y) == 1;\n//                            });\n// \
    \        std::vector<Point> tmp;\n//         for (int i = left; i < right; ++i)\
    \ {\n//           if (sgn((ps[i].x - x_mid) * (ps[i].x - x_mid) - d) == 1) continue;\n\
    //           for (int j = static_cast<int>(tmp.size()) - 1; j >= 0; --j) {\n//\
    \             const Point v = ps[i] - tmp[j];\n//             if (sgn(v.y * v.y\
    \ - d) == 1) break;\n//             d = std::min(d, v.norm());\n//           }\n\
    //           tmp.emplace_back(ps[i]);\n//         }\n//         return d;\n//\
    \       };\n//   return f(0, n);\n// }\n\n// bool is_parallel(const Segment& a,\
    \ const Segment& b) {\n//   return sgn(cross(a.t - a.s, b.t - b.s)) == 0;\n//\
    \ }\n// bool is_orthogonal(const Segment& a, const Segment& b) {\n//   return\
    \ sgn(dot(a.t - a.s, b.t - b.s)) == 0;\n// }\n\n// int common_tangent_num(const\
    \ Circle&, const Circle&);\n// bool has_intersected(const Segment& a, const Point&\
    \ b) {\n//   return ccw(a.s, a.t, b) == 0;\n// }\n// bool has_intersected(const\
    \ Segment& a, const Segment& b) {\n//   return ccw(a.s, a.t, b.s) * ccw(a.s, a.t,\
    \ b.t) <= 0 &&\n//          ccw(b.s, b.t, a.s) * ccw(b.s, b.t, a.t) <= 0;\n//\
    \ }\n// bool has_intersected(const Line& a, const Point& b) {\n//   const int\
    \ c = ccw(a.s, a.t, b);\n//   return c != 1 && c != -1;\n// }\n// bool has_intersected(const\
    \ Line& a, const Segment& b) {\n//   return ccw(a.s, a.t, b.s) * ccw(a.s, a.t,\
    \ b.t) != 1;\n// }\n// bool has_intersected(const Line& a, const Line& b) {\n\
    //   return sgn(cross(a.t - a.s, b.t - b.s)) != 0 ||\n//          sgn(cross(a.t\
    \ - a.s, b.s - a.s)) == 0;\n// }\n// bool has_intersected(const Circle& a, const\
    \ Point& b) {\n//   return (a.p - b).norm() == a.r * a.r;\n// }\n// bool has_intersected(const\
    \ Circle& a, const Circle& b) {\n//   const int num = common_tangent_num(a, b);\n\
    //   return 1 <= num && num <= 3;\n// }\n\n// int common_tangent_num(const Circle&\
    \ a, const Circle& b) {\n//   const Integer dist = (a.p - b.p).norm();\n//   int\
    \ sign = sgn((a.r + b.r) * (a.r + b.r) - dist);\n//   if (sign == -1) return 4;\n\
    //   if (sign == 0) return 3;\n//   sign = sgn((b.r - a.r) * (b.r - a.r) - dist);\n\
    //   if (sign == -1) return 2;\n//   if (sign == 0) return 1;\n//   return 0;\n\
    // }\n\n// using Polygon = std::vector<Point>;\n\n// Integer area(Polygon a) {\n\
    //   const int n = a.size();\n//   a.resize(n + 1);\n//   a.back() = a.front();\n\
    //   Integer res = 0;\n//   for (int i = 0; i < n; ++i) {\n//     res += cross(a[i],\
    \ a[i + 1]);\n//   }\n//   // return res / 2;\n//   return res;\n// }\n\n// int\
    \ contains(Polygon a, const Point &b) {\n//   const int n = a.size();\n//   a.resize(n\
    \ + 1);\n//   a.back() = a.front();\n//   bool is_in = false;\n//   for (int i\
    \ = 0; i < n; ++i) {\n//     Point p = a[i] - b, q = a[i + 1] - b;\n//     if\
    \ (sgn(q.y - p.y) == -1) std::swap(p, q);\n//     const int sign = sgn(cross(p,\
    \ q));\n//     if (sign == 1 && sgn(p.y) != 1 && sgn(q.y) == 1) is_in = !is_in;\n\
    //     if (sign == 0 && sgn(dot(p, q)) != 1) return 1;\n//   }\n//   return is_in\
    \ ? 2 : 0;\n// }\n\n// bool is_convex(Polygon a) {\n//   const int n = a.size();\n\
    //   a.resize(n + 2);\n//   a[n] = a[0];\n//   a[n + 1] = a[1];\n//   for (int\
    \ i = 1; i <= n; ++i) {\n//     if (ccw(a[i - 1], a[i], a[i + 1]) == -1) return\
    \ false;\n//   }\n//   return true;\n// }\n\n// Polygon monotone_chain(std::vector<Point>\
    \ ps, const bool is_tight = true) {\n//   const int n = ps.size();\n//   std::sort(ps.begin(),\
    \ ps.end());\n//   Polygon convex_hull(n << 1);\n//   int idx = 0;\n//   for (int\
    \ i = 0; i < n; convex_hull[idx++] = ps[i++]) {\n//     while (idx >= 2 &&\n//\
    \            sgn(cross(convex_hull[idx - 1] - convex_hull[idx - 2],\n//      \
    \                ps[i] - convex_hull[idx - 1])) < is_tight) {\n//       --idx;\n\
    //     }\n//   }\n//   for (int i = n - 2, border = idx + 1; i >= 0; convex_hull[idx++]\
    \ = ps[i--]) {\n//     while (idx >= border &&\n//            sgn(cross(convex_hull[idx\
    \ - 1] - convex_hull[idx - 2],\n//                      ps[i] - convex_hull[idx\
    \ - 1])) < is_tight) {\n//       --idx;\n//     }\n//   }\n//   convex_hull.resize(idx\
    \ - 1);\n//   return convex_hull;\n// }\n\n// std::pair<Point, Point> rotating_calipers(Polygon\
    \ a) {\n//   const int n = a.size();\n//   if (n <= 2) {\n//     assert(n == 2);\n\
    //     return {a[0], a[1]};\n//   }\n//   a.resize(n + 1);\n//   a.back() = a.front();\n\
    //   int high = 0, low = 0;\n//   for (int i = 1; i < n; ++i) {\n//     if (a[i].y\
    \ > a[high].y) high = i;\n//     if (a[i].y < a[low].y) low = i;\n//   }\n// \
    \  Integer max_norm = (a[high] - a[low]).norm();\n//   int i = high, j = low,\
    \ argmax_i = i, argmax_j = j;\n//   do {\n//     int* i_or_j = &(sgn(cross(a[i\
    \ + 1] - a[i], a[j + 1] - a[j])) != -1 ? j : i);\n//     if (++(*i_or_j) == n)\
    \ *i_or_j = 0;\n//     const Integer tmp = (a[j] - a[i]).norm();\n//     if (sgn(tmp\
    \ - max_norm) == 1) {\n//       max_norm = tmp;\n//       argmax_i = i; argmax_j\
    \ = j;\n//     }\n//   } while (i != high || j != low);\n//   return {a[argmax_i],\
    \ a[argmax_j]};\n// }\n\n// }  // namespace geometry\n\n}  // namespace emthrm\n\
    \n\n"
  code: "#ifndef EMTHRM_GEOMETRY_GEOMETRY_HPP_\n#define EMTHRM_GEOMETRY_GEOMETRY_HPP_\n\
    \n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <functional>\n\
    #include <iostream>\n#include <iterator>\n#include <limits>\n#include <tuple>\n\
    #include <utility>\n#include <vector>\n\nnamespace emthrm {\n\nnamespace geometry\
    \ {\n\nusing Real = double;\nconstexpr long double PI = 3.14159265358979323846;\n\
    \nint sgn(const Real x) {\n  static constexpr Real EPS = 1e-8;\n  return x > EPS\
    \ ? 1 : (x < -EPS ? -1 : 0);\n}\n\nReal degree_to_radian(const Real d) { return\
    \ d * PI / 180; }\nReal radian_to_degree(const Real r) { return r * 180 / PI;\
    \ }\n\nstruct Point {\n  Real x, y;\n  explicit Point(const Real x = 0, const\
    \ Real y = 0) : x(x), y(y) {}\n  Real abs() const { return std::sqrt(norm());\
    \ }\n  Real arg() const {\n    const Real res = std::atan2(y, x);\n    return\
    \ res < 0 ? res + PI * 2 : res;\n  }\n  Real norm() const { return x * x + y *\
    \ y; }\n  Point rotate(const Real angle) const {\n    const Real cs = std::cos(angle),\
    \ sn = std::sin(angle);\n    return Point(x * cs - y * sn, x * sn + y * cs);\n\
    \  }\n  Point& operator+=(const Point& p) {\n    x += p.x; y += p.y;\n    return\
    \ *this;\n  }\n  Point& operator-=(const Point& p) {\n    x -= p.x; y -= p.y;\n\
    \    return *this;\n  }\n  Point& operator*=(const Real k) {\n    x *= k; y *=\
    \ k;\n    return *this;\n  }\n  Point& operator/=(const Real k) {\n    x /= k;\
    \ y /= k;\n    return *this;\n  }\n  bool operator<(const Point& p) const {\n\
    \    const int x_sgn = sgn(p.x - x);\n    return x_sgn != 0 ? x_sgn == 1 : sgn(p.y\
    \ - y) == 1;\n  }\n  bool operator<=(const Point& p) const { return !(p < *this);\
    \ }\n  bool operator>(const Point& p) const { return p < *this; }\n  bool operator>=(const\
    \ Point& p) const { return !(*this < p); }\n  Point operator+() const { return\
    \ *this; }\n  Point operator-() const { return Point(-x, -y); }\n  Point operator+(const\
    \ Point& p) const { return Point(*this) += p; }\n  Point operator-(const Point&\
    \ p) const { return Point(*this) -= p; }\n  Point operator*(const Real k) const\
    \ { return Point(*this) *= k; }\n  Point operator/(const Real k) const { return\
    \ Point(*this) /= k; }\n  friend std::ostream& operator<<(std::ostream& os, const\
    \ Point& p) {\n    return os << '(' << p.x << \", \" << p.y << ')';\n  }\n  friend\
    \ std::istream& operator>>(std::istream& is, Point& p) {\n    Real x, y; is >>\
    \ x >> y;\n    p = Point(x, y);\n    return is;\n  }\n};\n\nstruct Segment {\n\
    \  Point s, t;\n  explicit Segment(const Point& s = Point(0, 0), const Point&\
    \ t = Point(0, 0))\n      : s(s), t(t) {}\n};\nstruct Line : Segment {\n  using\
    \ Segment::Segment;\n  explicit Line(const Real a, const Real b, const Real c)\
    \ {\n    if (sgn(a) == 0) {\n      s = Point(0, -c / b); t = Point(1, s.y);\n\
    \    } else if (sgn(b) == 0) {\n      s = Point(-c / a, 0); t = Point(s.x, 1);\n\
    \    } else if (sgn(c) == 0) {\n      s = Point(0, 0); t = Point(1, -a / b);\n\
    \    } else {\n      s = Point(0, -c / b); t = Point(-c / a, 0);\n    }\n  }\n\
    };\n\nstruct Circle {\n  Point p; Real r;\n  explicit Circle(const Point& p =\
    \ Point(0, 0), const Real r = 0)\n      : p(p), r(r) {}\n};\n\nPoint unit_vector(const\
    \ Point& p) {\n  const Real a = p.abs();\n  return Point(p.x / a, p.y / a);\n\
    }\nstd::tuple<Point, Point> normal_unit_vector(const Point& p) {\n  const Point\
    \ u = unit_vector(p);\n  return {Point(-u.y, u.x), Point(u.y, -u.x)};\n}\n\nReal\
    \ cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\nReal\
    \ dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n\nint\
    \ ccw(const Point& a, const Point& b, const Point& c) {\n  const Point ab = b\
    \ - a, ac = c - a;\n  const int sign = sgn(cross(ab, ac));\n  if (sign == 0) {\n\
    \    if (sgn(dot(ab, ac)) == -1) return 2;\n    if (sgn(ac.norm() - ab.norm())\
    \ == 1) return -2;\n  }\n  return sign;\n}\n\nReal get_angle(const Point& a, const\
    \ Point& b, const Point& c) {\n  Real ab = (a - b).arg(), bc = (c - b).arg();\n\
    \  if (ab > bc) std::swap(ab, bc);\n  return std::min(bc - ab, static_cast<Real>(PI\
    \ * 2 - (bc - ab)));\n}\n\nReal closest_pair(std::vector<Point> ps) {\n  const\
    \ int n = ps.size();\n  assert(n >= 2);\n  std::sort(ps.begin(), ps.end());\n\
    \  const std::function<Real(int, int)> f =\n      [&ps, &f](const int left, const\
    \ int right) -> Real {\n        const int mid = (left + right) >> 1;\n       \
    \ Real x_mid = ps[mid].x, d = std::numeric_limits<Real>::max();\n        if (left\
    \ + 1 < mid) d = std::min(d, f(left, mid));\n        if (mid + 1 < right) d =\
    \ std::min(d, f(mid, right));\n        std::inplace_merge(std::next(ps.begin(),\
    \ left),\n                           std::next(ps.begin(), mid),\n           \
    \                std::next(ps.begin(), right),\n                           [](const\
    \ Point& a, const Point& b) -> bool {\n                             return sgn(b.y\
    \ - a.y) == 1;\n                           });\n        std::vector<Point> tmp;\n\
    \        for (int i = left; i < right; ++i) {\n          if (sgn(std::abs(ps[i].x\
    \ - x_mid) - d) == 1) continue;\n          for (int j = static_cast<int>(tmp.size())\
    \ - 1; j >= 0; --j) {\n            const Point v = ps[i] - tmp[j];\n         \
    \   if (sgn(v.y - d) == 1) break;\n            d = std::min(d, v.abs());\n   \
    \       }\n          tmp.emplace_back(ps[i]);\n        }\n        return d;\n\
    \      };\n  return f(0, n);\n}\n\nPoint projection(const Segment& a, const Point&\
    \ b) {\n  return a.s + (a.t - a.s) * dot(a.t - a.s, b - a.s) / (a.t - a.s).norm();\n\
    }\nPoint reflection(const Segment& a, const Point& b) {\n  return projection(a,\
    \ b) * 2 - b;\n}\n\nbool is_parallel(const Segment& a, const Segment& b) {\n \
    \ return sgn(cross(a.t - a.s, b.t - b.s)) == 0;\n}\nbool is_orthogonal(const Segment&\
    \ a, const Segment& b) {\n  return sgn(dot(a.t - a.s, b.t - b.s)) == 0;\n}\n\n\
    Real distance(const Point&, const Point&);\nReal distance(const Segment&, const\
    \ Point&);\nReal distance(const Line&, const Point&);\nint common_tangent_num(const\
    \ Circle&, const Circle&);\nbool has_intersected(const Segment& a, const Point&\
    \ b) {\n  return ccw(a.s, a.t, b) == 0;\n}\nbool has_intersected(const Segment&\
    \ a, const Segment& b) {\n  return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) <=\
    \ 0 &&\n         ccw(b.s, b.t, a.s) * ccw(b.s, b.t, a.t) <= 0;\n}\nbool has_intersected(const\
    \ Line& a, const Point& b) {\n  const int c = ccw(a.s, a.t, b);\n  return c !=\
    \ 1 && c != -1;\n}\nbool has_intersected(const Line& a, const Segment& b) {\n\
    \  return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) != 1;\n}\nbool has_intersected(const\
    \ Line& a, const Line& b) {\n  return sgn(cross(a.t - a.s, b.t - b.s)) != 0 ||\n\
    \         sgn(cross(a.t - a.s, b.s - a.s)) == 0;\n}\nbool has_intersected(const\
    \ Circle& a, const Point& b) {\n  return sgn(distance(a.p, b) - a.r) == 0;\n}\n\
    bool has_intersected(const Circle& a, const Segment& b) {\n  return sgn(a.r -\
    \ distance(b, a.p)) != -1 &&\n         sgn(std::max(distance(a.p, b.s), distance(a.p,\
    \ b.t)) - a.r) != -1;\n}\nbool has_intersected(const Circle& a, const Line& b)\
    \ {\n  return sgn(a.r - distance(b, a.p)) != -1;\n}\nbool has_intersected(const\
    \ Circle& a, const Circle& b) {\n  const int num = common_tangent_num(a, b);\n\
    \  return 1 <= num && num <= 3;\n}\n\nPoint intersection(const Line& a, const\
    \ Line& b) {\n  assert(has_intersected(a, b) && !is_parallel(a, b));\n  const\
    \ Point va = a.t - a.s, vb = b.t - b.s;\n  return a.s + va * cross(vb, b.s - a.s)\
    \ / cross(vb, va);\n}\nPoint intersection(const Segment& a, const Segment& b)\
    \ {\n  assert(has_intersected(a, b));\n  if (is_parallel(a, b)) {\n    if (sgn(distance(a.s,\
    \ b.s)) == 0) {\n      assert(sgn(dot(a.t - a.s, b.t - a.s)) == -1);\n      return\
    \ a.s;\n    } else if (sgn(distance(a.s, b.t)) == 0) {\n      assert(sgn(dot(a.t\
    \ - a.s, b.s - a.s)) == -1);\n      return a.s;\n    } else if (sgn(distance(a.t,\
    \ b.s)) == 0) {\n      assert(sgn(dot(a.s - a.t, b.t - a.t)) == -1);\n      return\
    \ a.t;\n    } else if (sgn(distance(a.t, b.t)) == 0) {\n      assert(sgn(dot(a.s\
    \ - a.t, b.s - a.t)) == -1);\n      return a.t;\n    } else {\n      assert(false);\n\
    \    }\n  } else {\n    return intersection(Line(a.s, a.t), Line(b.s, b.t));\n\
    \  }\n}\nPoint intersection(const Line& a, const Segment& b) {\n  assert(has_intersected(a,\
    \ b));\n  return intersection(a, Line(b.s, b.t));\n}\nstd::vector<Point> intersection(const\
    \ Circle& a, const Line& b) {\n  const Point pro = projection(b, a.p);\n  const\
    \ Real nor = (a.p - pro).norm();\n  const int sign = sgn(a.r - std::sqrt(nor));\n\
    \  if (sign == -1) return {};\n  if (sign == 0) return {pro};\n  const Point tmp\
    \ = unit_vector(b.t - b.s) * std::sqrt(a.r * a.r - nor);\n  return {pro + tmp,\
    \ pro - tmp};\n}\nstd::vector<Point> intersection(const Circle& a, const Segment&\
    \ b) {\n  if (!has_intersected(a, b)) return {};\n  const std::vector<Point> res\
    \ = intersection(a, Line(b.s, b.t));\n  if (sgn(distance(a.p, b.s) - a.r) != -1\
    \ &&\n      sgn(distance(a.p, b.t) - a.r) != -1) {\n    return res;\n  }\n  return\
    \ {res[sgn(dot(res[0] - b.s, res[0] - b.t)) == 1 ? 1 : 0]};\n}\nstd::vector<Point>\
    \ intersection(const Circle& a, const Circle& b) {\n  const int num = common_tangent_num(a,\
    \ b);\n  if (num == 0 || num == 4) return {};\n  const Real alpha = (b.p - a.p).arg();\n\
    \  if (num == 1 || num == 3) {\n    return {Point(a.p.x + a.r * std::cos(alpha),\n\
    \                  a.p.y + a.r * std::sin(alpha))};\n  }\n  const Real dist =\
    \ (b.p - a.p).norm();\n  const Real beta =\n      std::acos((dist + a.r * a.r\
    \ - b.r * b.r) / (2 * std::sqrt(dist) * a.r));\n  return {\n      a.p + Point(a.r\
    \ * std::cos(alpha + beta), a.r * std::sin(alpha + beta)),\n      a.p + Point(a.r\
    \ * std::cos(alpha - beta), a.r * std::sin(alpha - beta))};\n}\n\nReal distance(const\
    \ Point& a, const Point& b) { return (b - a).abs(); }\nReal distance(const Segment&\
    \ a, const Point& b) {\n  const Point foot = projection(a, b);\n  return has_intersected(a,\
    \ foot) ?\n         distance(foot, b) : std::min(distance(a.s, b), distance(a.t,\
    \ b));\n}\nReal distance(const Segment& a, const Segment& b) {\n  return has_intersected(a,\
    \ b) ? 0 :\n         std::min({distance(a, b.s), distance(a, b.t),\n         \
    \          distance(b, a.s), distance(b, a.t)});\n}\nReal distance(const Line&\
    \ a, const Point& b) {\n  return distance(projection(a, b), b);\n}\nReal distance(const\
    \ Line& a, const Segment& b) {\n  return has_intersected(a, b) ?\n         0 :\
    \ std::min(distance(a, b.s), distance(a, b.t));\n}\nReal distance(const Line&\
    \ a, const Line& b) {\n  return has_intersected(a, b) ? 0 : distance(a, b.s);\n\
    }\n\nstd::vector<Point> tangency(const Circle& a, const Point& b) {\n  const Real\
    \ dist = distance(a.p, b);\n  const int sign = sgn(dist - a.r);\n  if (sign ==\
    \ -1) return {};\n  if (sign == 0) return {b};\n  const Real alpha = (b - a.p).arg(),\
    \ beta = std::acos(a.r / dist);\n  return {\n      a.p + Point(a.r * std::cos(alpha\
    \ + beta), a.r * std::sin(alpha + beta)),\n      a.p + Point(a.r * std::cos(alpha\
    \ - beta), a.r * std::sin(alpha - beta))};\n}\nint common_tangent_num(const Circle&\
    \ a, const Circle& b) {\n  const Real dist = distance(a.p, b.p);\n  int sign =\
    \ sgn(a.r + b.r - dist);\n  if (sign == -1) return 4;\n  if (sign == 0) return\
    \ 3;\n  sign = sgn((sgn(a.r - b.r) == -1 ? b.r - a.r : a.r - b.r) - dist);\n \
    \ if (sign == -1) return 2;\n  if (sign == 0) return 1;\n  return 0;\n}\nstd::vector<Line>\
    \ common_tangent(const Circle& a, const Circle& b) {\n  std::vector<Line> tangents;\n\
    \  const Real dist = distance(a.p, b.p), argument = (b.p - a.p).arg();\n  int\
    \ sign = sgn(a.r + b.r - dist);\n  if (sign == -1) {\n    const Real ac = std::acos((a.r\
    \ + b.r) / dist);\n    Real alpha = argument + ac, cs = std::cos(alpha), sn =\
    \ std::sin(alpha);\n    tangents.emplace_back(a.p + Point(a.r * cs, a.r * sn),\n\
    \                          b.p + Point(-b.r * cs, -b.r * sn));\n    alpha = argument\
    \ - ac; cs = std::cos(alpha); sn = std::sin(alpha);\n    tangents.emplace_back(a.p\
    \ + Point(a.r * cs, a.r * sn),\n                          b.p + Point(-b.r * cs,\
    \ -b.r * sn));\n  } else if (sign == 0) {\n    const Point s =\n        a.p +\
    \ Point(a.r * std::cos(argument), a.r * std::sin(argument));\n    tangents.emplace_back(s,\
    \ s + std::get<0>(normal_unit_vector(b.p - a.p)));\n  }\n  if (sgn(b.r - a.r)\
    \ == -1) {\n    sign = sgn(a.r - b.r - dist);\n    if (sign == -1) {\n      const\
    \ Real at = std::acos((a.r - b.r) / dist);\n      Real alpha = argument + at,\
    \ cs = std::cos(alpha), sn = std::sin(alpha);\n      tangents.emplace_back(a.p\
    \ + Point(a.r * cs, a.r * sn),\n                            b.p + Point(b.r *\
    \ cs, b.r * sn));\n      alpha = argument - at; cs = std::cos(alpha); sn = std::sin(alpha);\n\
    \      tangents.emplace_back(a.p + Point(a.r * cs, a.r * sn),\n              \
    \              b.p + Point(b.r * cs, b.r * sn));\n    } else if (sign == 0) {\n\
    \      const Point s =\n          a.p + Point(a.r * std::cos(argument), a.r *\
    \ std::sin(argument));\n      tangents.emplace_back(s, s + std::get<0>(normal_unit_vector(b.p\
    \ - a.p)));\n    }\n  } else {\n    sign = sgn(b.r - a.r - dist);\n    if (sign\
    \ == -1) {\n      const Real at = std::acos((b.r - a.r) / dist);\n      Real alpha\
    \ = argument - at, cs = std::cos(alpha), sn = std::sin(alpha);\n      tangents.emplace_back(a.p\
    \ + Point(-a.r * cs, -a.r * sn),\n                            b.p + Point(-b.r\
    \ * cs, -b.r * sn));\n      alpha = argument + at; cs = std::cos(alpha); sn =\
    \ std::sin(alpha);\n      tangents.emplace_back(a.p + Point(-a.r * cs, -a.r *\
    \ sn),\n                            b.p + Point(-b.r * cs, -b.r * sn));\n    }\
    \ else if (sign == 0) {\n      const Point s =\n          b.p + Point(-b.r * std::cos(argument),\
    \ -b.r * std::sin(argument));\n      tangents.emplace_back(s, s + std::get<0>(normal_unit_vector(a.p\
    \ - b.p)));\n    }\n  }\n  return tangents;\n}\n\nReal intersection_area(const\
    \ Circle& a, const Circle& b) {\n  const Real nor = (b.p - a.p).norm(), dist =\
    \ std::sqrt(nor);\n  if (sgn(a.r + b.r - dist) != 1) return 0;\n  if (sgn(std::abs(a.r\
    \ - b.r) - dist) != -1) {\n    return std::min(a.r, b.r) * std::min(a.r, b.r)\
    \ * PI;\n  }\n  const Real alpha =\n      std::acos((nor + a.r * a.r - b.r * b.r)\
    \ / (2 * dist * a.r));\n  const Real beta = std::acos((nor + b.r * b.r - a.r *\
    \ a.r) / (2 * dist * b.r));\n  return (alpha - std::sin(alpha + alpha) * 0.5)\
    \ * a.r * a.r +\n         (beta - std::sin(beta + beta) * 0.5) * b.r * b.r;\n\
    }\n\nusing Polygon = std::vector<Point>;\n\nReal area(Polygon a) {\n  const int\
    \ n = a.size();\n  a.resize(n + 1);\n  a.back() = a.front();\n  Real res = 0;\n\
    \  for (int i = 0; i < n; ++i) {\n    res += cross(a[i], a[i + 1]);\n  }\n  return\
    \ res * 0.5;\n}\n\nPoint centroid(Polygon a) {\n  const int n = a.size();\n  a.resize(n\
    \ + 1);\n  a.back() = a.front();\n  Point res(0, 0);\n  Real den = 0;\n  for (int\
    \ i = 0; i < n; ++i) {\n    const Real cro = cross(a[i], a[i + 1]);\n    res +=\
    \ (a[i] + a[i + 1]) / 3 * cro;\n    den += cro;\n  }\n  return res / den;\n}\n\
    \nint contains(Polygon a, const Point &b) {\n  const int n = a.size();\n  a.resize(n\
    \ + 1);\n  a.back() = a.front();\n  bool is_in = false;\n  for (int i = 0; i <\
    \ n; ++i) {\n    Point p = a[i] - b, q = a[i + 1] - b;\n    if (sgn(q.y - p.y)\
    \ == -1) std::swap(p, q);\n    const int sign = sgn(cross(p, q));\n    if (sign\
    \ == 1 && sgn(p.y) != 1 && sgn(q.y) == 1) is_in = !is_in;\n    if (sign == 0 &&\
    \ sgn(dot(p, q)) != 1) return 1;\n  }\n  return is_in ? 2 : 0;\n}\n\nbool is_convex(Polygon\
    \ a) {\n  const int n = a.size();\n  a.resize(n + 2);\n  a[n] = a[0];\n  a[n +\
    \ 1] = a[1];\n  for (int i = 1; i <= n; ++i) {\n    if (ccw(a[i - 1], a[i], a[i\
    \ + 1]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon monotone_chain(std::vector<Point>\
    \ ps, const bool is_tight = true) {\n  const int n = ps.size();\n  std::sort(ps.begin(),\
    \ ps.end());\n  Polygon convex_hull(n << 1);\n  int idx = 0;\n  for (int i = 0;\
    \ i < n; convex_hull[idx++] = ps[i++]) {\n    while (idx >= 2 &&\n           sgn(cross(convex_hull[idx\
    \ - 1] - convex_hull[idx - 2],\n                     ps[i] - convex_hull[idx -\
    \ 1])) < is_tight) {\n      --idx;\n    }\n  }\n  for (int i = n - 2, border =\
    \ idx + 1; i >= 0; convex_hull[idx++] = ps[i--]) {\n    while (idx >= border &&\n\
    \           sgn(cross(convex_hull[idx - 1] - convex_hull[idx - 2],\n         \
    \            ps[i] - convex_hull[idx - 1])) < is_tight) {\n      --idx;\n    }\n\
    \  }\n  convex_hull.resize(idx - 1);\n  return convex_hull;\n}\n\nPolygon cut_convex(Polygon\
    \ a, const Line& b) {\n  const int n = a.size();\n  a.resize(n + 1);\n  a.back()\
    \ = a.front();\n  Polygon res;\n  for (int i = 0; i < n; ++i) {\n    const int\
    \ c = ccw(b.s, b.t, a[i]);\n    if (c != -1) res.emplace_back(a[i]);\n    if (c\
    \ * ccw(b.s, b.t, a[i + 1]) == -1) {\n      res.emplace_back(intersection(Line(a[i],\
    \ a[i + 1]), b));\n    }\n  }\n  return res.size() < 3 ? Polygon() : res;\n}\n\
    \nstd::tuple<Point, Point> rotating_calipers(Polygon a) {\n  const int n = a.size();\n\
    \  if (n <= 2) {\n    assert(n == 2);\n    return {a[0], a[1]};\n  }\n  a.resize(n\
    \ + 1);\n  a.back() = a.front();\n  int high = 0, low = 0;\n  for (int i = 1;\
    \ i < n; ++i) {\n    if (a[i].y > a[high].y) high = i;\n    if (a[i].y < a[low].y)\
    \ low = i;\n  }\n  Real max_norm = (a[high] - a[low]).norm();\n  int i = high,\
    \ j = low, argmax_i = i, argmax_j = j;\n  do {\n    int* i_or_j = &(sgn(cross(a[i\
    \ + 1] - a[i], a[j + 1] - a[j])) != -1 ? j : i);\n    if (++(*i_or_j) == n) *i_or_j\
    \ = 0;\n    const Real tmp = (a[j] - a[i]).norm();\n    if (sgn(tmp - max_norm)\
    \ == 1) {\n      max_norm = tmp;\n      argmax_i = i; argmax_j = j;\n    }\n \
    \ } while (i != high || j != low);\n  return {a[argmax_i], a[argmax_j]};\n}\n\n\
    }  // namespace geometry\n\n// namespace geometry {\n\n// using Integer = long\
    \ long;\n\n// int sgn(const Integer x) {\n//   return x > 0 ? 1 : (x < 0 ? -1\
    \ : 0);\n// }\n\n// struct Point {\n//   Integer x, y;\n//   explicit Point(const\
    \ Integer x = 0, const Integer y = 0) : x(x), y(y) {}\n//   Integer norm() const\
    \ { return x * x + y * y; }\n//   Point& operator+=(const Point& p) {\n//    \
    \ x += p.x; y += p.y;\n//     return *this;\n//   }\n//   Point& operator-=(const\
    \ Point& p) {\n//     x -= p.x; y -= p.y;\n//     return *this;\n//   }\n//  \
    \ Point& operator*=(const Integer k) {\n//     x *= k; y *= k;\n//     return\
    \ *this;\n//   }\n//   Point& operator/=(const Integer k) {\n//     x /= k; y\
    \ /= k;\n//     return *this;\n//   }\n//   bool operator<(const Point& p) const\
    \ {\n//     const int x_sgn = sgn(p.x - x);\n//     return x_sgn != 0 ? x_sgn\
    \ == 1 : sgn(p.y - y) == 1;\n//   }\n//   bool operator<=(const Point& p) const\
    \ { return !(p < *this); }\n//   bool operator>(const Point& p) const { return\
    \ p < *this; }\n//   bool operator>=(const Point& p) const { return !(*this <\
    \ p); }\n//   Point operator+() const { return *this; }\n//   Point operator-()\
    \ const { return Point(-x, -y); }\n//   Point operator+(const Point& p) const\
    \ { return Point(*this) += p; }\n//   Point operator-(const Point& p) const {\
    \ return Point(*this) -= p; }\n//   Point operator*(const Integer k) const { return\
    \ Point(*this) *= k; }\n//   Point operator/(const Integer k) const { return Point(*this)\
    \ /= k; }\n//   friend std::ostream& operator<<(std::ostream& os, const Point&\
    \ p) {\n//     return os << '(' << p.x << \", \" << p.y << ')';\n//   }\n//  \
    \ friend std::istream& operator>>(std::istream& is, Point& p) {\n//     Integer\
    \ x, y; is >> x >> y;\n//     p = Point(x, y);\n//     return is;\n//   }\n//\
    \ };\n\n// struct Segment {\n//   Point s, t;\n//   explicit Segment(const Point&\
    \ s = Point(0, 0), const Point& t = Point(0, 0))\n//       : s(s), t(t) {}\n//\
    \ };\n// struct Line : Segment {\n//   using Segment::Segment;\n// };\n\n// struct\
    \ Circle {\n//   Point p; Integer r;\n//   explicit Circle(const Point& p = Point(0,\
    \ 0), const Integer r = 0)\n//       : p(p), r(r) {}\n// };\n\n// Integer cross(const\
    \ Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n// Integer dot(const\
    \ Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n\n// int ccw(const\
    \ Point& a, const Point& b, const Point& c) {\n//   const Point ab = b - a, ac\
    \ = c - a;\n//   const int sign = sgn(cross(ab, ac));\n//   if (sign == 0) {\n\
    //     if (sgn(dot(ab, ac)) == -1) return 2;\n//     if (sgn(ac.norm() - ab.norm())\
    \ == 1) return -2;\n//   }\n//   return sign;\n// }\n\n// Integer closest_pair(std::vector<Point>\
    \ ps) {\n//   const int n = ps.size();\n//   assert(n >= 2);\n//   std::sort(ps.begin(),\
    \ ps.end());\n//   const std::function<Integer(int, int)> f =\n//       [&ps,\
    \ &f](const int left, const int right) -> Integer {\n//         const int mid\
    \ = (left + right) >> 1;\n//         Integer x_mid = ps[mid].x, d = std::numeric_limits<Integer>::max();\n\
    //         if (left + 1 < mid) d = std::min(d, f(left, mid));\n//         if (mid\
    \ + 1 < right) d = std::min(d, f(mid, right));\n//         std::inplace_merge(std::next(ps.begin(),\
    \ left),\n//                            std::next(ps.begin(), mid),\n//      \
    \                      std::next(ps.begin(), right),\n//                     \
    \       [](const Point& a, const Point& b) -> bool {\n//                     \
    \         return sgn(b.y - a.y) == 1;\n//                            });\n// \
    \        std::vector<Point> tmp;\n//         for (int i = left; i < right; ++i)\
    \ {\n//           if (sgn((ps[i].x - x_mid) * (ps[i].x - x_mid) - d) == 1) continue;\n\
    //           for (int j = static_cast<int>(tmp.size()) - 1; j >= 0; --j) {\n//\
    \             const Point v = ps[i] - tmp[j];\n//             if (sgn(v.y * v.y\
    \ - d) == 1) break;\n//             d = std::min(d, v.norm());\n//           }\n\
    //           tmp.emplace_back(ps[i]);\n//         }\n//         return d;\n//\
    \       };\n//   return f(0, n);\n// }\n\n// bool is_parallel(const Segment& a,\
    \ const Segment& b) {\n//   return sgn(cross(a.t - a.s, b.t - b.s)) == 0;\n//\
    \ }\n// bool is_orthogonal(const Segment& a, const Segment& b) {\n//   return\
    \ sgn(dot(a.t - a.s, b.t - b.s)) == 0;\n// }\n\n// int common_tangent_num(const\
    \ Circle&, const Circle&);\n// bool has_intersected(const Segment& a, const Point&\
    \ b) {\n//   return ccw(a.s, a.t, b) == 0;\n// }\n// bool has_intersected(const\
    \ Segment& a, const Segment& b) {\n//   return ccw(a.s, a.t, b.s) * ccw(a.s, a.t,\
    \ b.t) <= 0 &&\n//          ccw(b.s, b.t, a.s) * ccw(b.s, b.t, a.t) <= 0;\n//\
    \ }\n// bool has_intersected(const Line& a, const Point& b) {\n//   const int\
    \ c = ccw(a.s, a.t, b);\n//   return c != 1 && c != -1;\n// }\n// bool has_intersected(const\
    \ Line& a, const Segment& b) {\n//   return ccw(a.s, a.t, b.s) * ccw(a.s, a.t,\
    \ b.t) != 1;\n// }\n// bool has_intersected(const Line& a, const Line& b) {\n\
    //   return sgn(cross(a.t - a.s, b.t - b.s)) != 0 ||\n//          sgn(cross(a.t\
    \ - a.s, b.s - a.s)) == 0;\n// }\n// bool has_intersected(const Circle& a, const\
    \ Point& b) {\n//   return (a.p - b).norm() == a.r * a.r;\n// }\n// bool has_intersected(const\
    \ Circle& a, const Circle& b) {\n//   const int num = common_tangent_num(a, b);\n\
    //   return 1 <= num && num <= 3;\n// }\n\n// int common_tangent_num(const Circle&\
    \ a, const Circle& b) {\n//   const Integer dist = (a.p - b.p).norm();\n//   int\
    \ sign = sgn((a.r + b.r) * (a.r + b.r) - dist);\n//   if (sign == -1) return 4;\n\
    //   if (sign == 0) return 3;\n//   sign = sgn((b.r - a.r) * (b.r - a.r) - dist);\n\
    //   if (sign == -1) return 2;\n//   if (sign == 0) return 1;\n//   return 0;\n\
    // }\n\n// using Polygon = std::vector<Point>;\n\n// Integer area(Polygon a) {\n\
    //   const int n = a.size();\n//   a.resize(n + 1);\n//   a.back() = a.front();\n\
    //   Integer res = 0;\n//   for (int i = 0; i < n; ++i) {\n//     res += cross(a[i],\
    \ a[i + 1]);\n//   }\n//   // return res / 2;\n//   return res;\n// }\n\n// int\
    \ contains(Polygon a, const Point &b) {\n//   const int n = a.size();\n//   a.resize(n\
    \ + 1);\n//   a.back() = a.front();\n//   bool is_in = false;\n//   for (int i\
    \ = 0; i < n; ++i) {\n//     Point p = a[i] - b, q = a[i + 1] - b;\n//     if\
    \ (sgn(q.y - p.y) == -1) std::swap(p, q);\n//     const int sign = sgn(cross(p,\
    \ q));\n//     if (sign == 1 && sgn(p.y) != 1 && sgn(q.y) == 1) is_in = !is_in;\n\
    //     if (sign == 0 && sgn(dot(p, q)) != 1) return 1;\n//   }\n//   return is_in\
    \ ? 2 : 0;\n// }\n\n// bool is_convex(Polygon a) {\n//   const int n = a.size();\n\
    //   a.resize(n + 2);\n//   a[n] = a[0];\n//   a[n + 1] = a[1];\n//   for (int\
    \ i = 1; i <= n; ++i) {\n//     if (ccw(a[i - 1], a[i], a[i + 1]) == -1) return\
    \ false;\n//   }\n//   return true;\n// }\n\n// Polygon monotone_chain(std::vector<Point>\
    \ ps, const bool is_tight = true) {\n//   const int n = ps.size();\n//   std::sort(ps.begin(),\
    \ ps.end());\n//   Polygon convex_hull(n << 1);\n//   int idx = 0;\n//   for (int\
    \ i = 0; i < n; convex_hull[idx++] = ps[i++]) {\n//     while (idx >= 2 &&\n//\
    \            sgn(cross(convex_hull[idx - 1] - convex_hull[idx - 2],\n//      \
    \                ps[i] - convex_hull[idx - 1])) < is_tight) {\n//       --idx;\n\
    //     }\n//   }\n//   for (int i = n - 2, border = idx + 1; i >= 0; convex_hull[idx++]\
    \ = ps[i--]) {\n//     while (idx >= border &&\n//            sgn(cross(convex_hull[idx\
    \ - 1] - convex_hull[idx - 2],\n//                      ps[i] - convex_hull[idx\
    \ - 1])) < is_tight) {\n//       --idx;\n//     }\n//   }\n//   convex_hull.resize(idx\
    \ - 1);\n//   return convex_hull;\n// }\n\n// std::pair<Point, Point> rotating_calipers(Polygon\
    \ a) {\n//   const int n = a.size();\n//   if (n <= 2) {\n//     assert(n == 2);\n\
    //     return {a[0], a[1]};\n//   }\n//   a.resize(n + 1);\n//   a.back() = a.front();\n\
    //   int high = 0, low = 0;\n//   for (int i = 1; i < n; ++i) {\n//     if (a[i].y\
    \ > a[high].y) high = i;\n//     if (a[i].y < a[low].y) low = i;\n//   }\n// \
    \  Integer max_norm = (a[high] - a[low]).norm();\n//   int i = high, j = low,\
    \ argmax_i = i, argmax_j = j;\n//   do {\n//     int* i_or_j = &(sgn(cross(a[i\
    \ + 1] - a[i], a[j + 1] - a[j])) != -1 ? j : i);\n//     if (++(*i_or_j) == n)\
    \ *i_or_j = 0;\n//     const Integer tmp = (a[j] - a[i]).norm();\n//     if (sgn(tmp\
    \ - max_norm) == 1) {\n//       max_norm = tmp;\n//       argmax_i = i; argmax_j\
    \ = j;\n//     }\n//   } while (i != high || j != low);\n//   return {a[argmax_i],\
    \ a[argmax_j]};\n// }\n\n// }  // namespace geometry\n\n}  // namespace emthrm\n\
    \n#endif  // EMTHRM_GEOMETRY_GEOMETRY_HPP_\n"
  dependsOn: []
  isVerificationFile: false
  path: include/emthrm/geometry/geometry.hpp
  requiredBy:
  - include/emthrm/geometry/smallest_enclosing_circle.hpp
  timestamp: '2022-12-15 22:18:37+09:00'
  verificationStatus: LIBRARY_ALL_AC
  verifiedWith:
  - test/geometry/geometry.13.test.cpp
  - test/geometry/geometry.15.test.cpp
  - test/geometry/geometry.14.test.cpp
  - test/geometry/geometry.11.test.cpp
  - test/geometry/geometry.20.test.cpp
  - test/geometry/geometry.22.test.cpp
  - test/geometry/geometry.08.test.cpp
  - test/geometry/geometry.10.test.cpp
  - test/geometry/geometry.12.test.cpp
  - test/geometry/geometry.21.test.cpp
  - test/geometry/geometry.18.test.cpp
  - test/geometry/geometry.04.test.cpp
  - test/geometry/geometry.16.test.cpp
  - test/geometry/geometry.01.test.cpp
  - test/geometry/geometry.03.test.cpp
  - test/geometry/geometry.06.test.cpp
  - test/geometry/geometry.17.test.cpp
  - test/geometry/geometry.05.test.cpp
  - test/geometry/geometry.09.test.cpp
  - test/geometry/geometry.24.test.cpp
  - test/geometry/geometry.19.test.cpp
  - test/geometry/smallest_enclosing_circle.test.cpp
  - test/geometry/geometry.07.test.cpp
  - test/geometry/geometry.02.test.cpp
  - test/geometry/geometry.23.test.cpp
  - test/math/quadratic_equation.test.cpp
documentation_of: include/emthrm/geometry/geometry.hpp
layout: document
title: "\u8A08\u7B97\u5E7E\u4F55\u5B66 (computational geometry)"
---


## 時間計算量

||時間計算量|
|:--|:--|
|最近点対|$O(N\log{N})$|
|多角形の面積|$O(N)$|
|多角形の重心|$O(N)$|
|多角形に対する点の内外判定|$O(N)$|
|凸性判定|$O(N)$|
|monotone chain|$O(N\log{N})$|
|凸多角形の切断|$O(N)$|
|キャリパー法 (rotating calipers)|$O(N)$|


## 仕様

|名前|説明・戻り値|備考|
|:--|:--|:--|
|`Real`|`double`||
|`constexpr long double PI`|$\pi$||
|`int sgn(const Real x);`|$\begin{cases} 1 & (x > \varepsilon) \\\\ -1 & (x < -\varepsilon) \\\\ 0 & (\text{otherwise}) \end{cases}$|$\varepsilon = 10^{-8}$|
|`Real degree_to_radian(const Real d);`|$\frac{\pi d}{180}\,\mathrm{rad}$||
|`Real radian_to_degree(const Real r);`|$(\frac{180r}{\pi})^\circ$||


### 点

```cpp
struct Point;
```

#### メンバ変数

|名前|説明|
|:--|:--|
|`Real x`|$x$ 座標|
|`Real y`|$y$ 座標|

#### メンバ変数

|名前|効果・戻り値|備考|
|:--|:--|:--|
|`explicit Point(const Real x = 0, const Real y = 0);`|点 $(x, y)$ を表すオブジェクトを構築する。||
|`Real abs() const;`|$\lVert \boldsymbol{p} \rVert$||
|`Real arg() const;`|$\arg(x + iy)$|$[0, 2\pi)$|
|`Real norm() const;`|${\lVert \boldsymbol{p} \rVert}^2$||
|`Point rotate(const Real angle) const;`|原点周りに $\mathrm{angle}$ だけ回転させたときの座標 $(x^{\prime}, y^{\prime})$|$\begin{cases} x^{\prime} = x\cos(\mathrm{angle}) - y\sin(\mathrm{angle}) \\\\ y^{\prime} = x\sin(\mathrm{angle}) + y\cos(\mathrm{angle}) \end{cases}$|
|`Point& operator+=(const Point& p);`<br>`Point& operator-=(const Point& p);`<br>`Point& operator*=(const Real k);`<br>`Point& operator/=(const Real k)`<br>`Point operator+(const Point& p);`<br>`Point operator-(const Point& p);`<br>`Point operator*(const Real k);`<br>`Point operator/(const Real k);`||
|`bool operator<(const Point& p) const;`<br>`bool operator<=(const Point& p);`<br>`bool operator>(const Point& p);`<br>`bool operator>=(const Point& p);`|比較演算子|
|`Point operator+() const;`|$(x, y)$|
|`Point operator-() const;`|$(-x, -y)$|
|`friend std::ostream& operator<<(std::ostream& os, const Point& p);`||
|`friend std::istream& operator>>(std::istream& is, Point& p);`||


### 線分

```cpp
struct Segment;
```

#### メンバ変数

|名前|説明|
|:--|:--|
|`Point s`<br>`Point t`|端点|

#### メンバ関数

|名前|効果|
|:--|:--|
|`explicit Segment(const Point& s = Point(0, 0), const Point& t = Point(0, 0));`|端点 $s, t$ の線分を表すオブジェクトを構築する。|


### 直線

```cpp
struct Line : Segment;
```

#### メンバ関数

|名前|効果|備考|
|:--|:--|:--|
||継承コンストラクタ||
|`explicit Line(const Real a, const Real b, const Real c);`|直線 $ax + by + c = 0$ を表すオブジェクトを構築する。|`s`, `t` には代表する2点を格納する。|


### 円

```cpp
struct Circle;
```

#### メンバ変数

|名前|説明|
|:--|:--|
|`Point p`|中心|
|`Real r`|半径|

#### メンバ関数

|名前|効果|
|:--|:--|
|`explicit Circle(const Point& p = Point(0, 0), const Real r = 0);`|コンストラクタ|


### 多角形

|名前|説明|要件|
|:--|:--|:--|
|`Polygon`|`std::vector<Point>`|頂点は反時計回りに並ぶ。|


### ライブラリ

|名前|戻り値|備考|
|:--|:--|:--|
|`Point unit_vector(const Point& p);`|ベクトル $p$ の単位ベクトル||
|`std::tuple<Point, Point> normal_unit_vector(const Point& p);`|ベクトル $p$ の単位法線ベクトル|
|`Real cross(const Point& a, const Point& b);`|$\boldsymbol{a} \times \boldsymbol{b}$||
|`Real dot(const Point& a, const Point& b);`|$\boldsymbol{a} \cdot \boldsymbol{b}$||
|`int ccw(const Point& a, const Point& b, const Point& c);`|$\begin{cases} -2 & (\mathrm{A}, \mathrm{B}, \mathrm{C} \text{ の順で一直線上に並ぶ。}) \\\\ -1 & (\mathrm{AB} \text{ から見て } \mathrm{C} \text{ は右側にある。}) \\\\ 0 & (\mathrm{A}, \mathrm{C}, \mathrm{B} \text{ の順で一直線上に並ぶ。}) \\\\ 1 & (\mathrm{AB} \text{ から見て } \mathrm{C} \text{ は左側にある。}) \\\\ 2 & (\mathrm{C}, \mathrm{A}, \mathrm{B} \text{ の順で一直線上に並ぶ。}) \end{cases}$||
|`Real get_angle(const Point& a, const Point& b, const Point& c);`|$\angle{\mathrm{ABC}}$||
|`Real closest_pair(std::vector<Point> ps);`|点集合 $\mathrm{ps}$ の最近点対間距離||
|`Point projection(const Segment& a, const Point& b);`|点 $\mathrm{A}$ に対する点 $\mathrm{B}$ の射影||
|`Point reflection(const Segment& a, const Point& b);`|点 $\mathrm{A}$ に対する点 $\mathrm{B}$ の鏡映||
|`bool is_parallel(const Segment& a, const Segment& b);`|$\boldsymbol{a} \parallel \boldsymbol{b}$|$\Leftrightarrow \boldsymbol{a} \times \boldsymbol{b} = 0$|
|`bool is_orthogonal(const Segment& a, const Segment& b);`|$\boldsymbol{a} \perp \boldsymbol{b}$|$\Leftrightarrow \boldsymbol{a} \cdot \boldsymbol{b} = 0$|
|`bool has_intersected(const Segment& a, const Point& b);`<br>`bool has_intersected(const Segment& a, const Segment& b);`<br>`bool has_intersected(const Line& a, const Point& b);`<br>`bool has_intersected(const Line& a, const Segment& b);`<br>`bool has_intersected(const Line& a, const Line& b);`<br>`bool has_intersected(const Circle& a, const Point& b);`<br>`bool has_intersected(const Circle& a, const Segment& b);`<br>`bool has_intersected(const Circle& a, const Line& b);`<br>`bool has_intersected(const Circle& a, const Circle& b);`|$\mathrm{A}$ と $\mathrm{B}$ は交差しているか。||
|`Point intersection(const Line& a, const Line& b);`<br>`Point intersection(const Segment& a, const Segment& b);`<br>`Point intersection(const Line& a, const Segment& b);`<br>`std::vector<Point> intersection(const Circle& a, const Line& b);`<br>`std::vector<Point> intersection(const Circle& a, const Segment& b);`<br>`std::vector<Point> intersection(const Circle& a, const Circle& b);`|$\mathrm{A}$ と $\mathrm{B}$ の交点||
|`Real distance(const Point& a, const Point& b);`<br>`Real distance(const Segment& a, const Point& b);`<br>`Real distance(const Segment& a, const Segment& b);`<br>`Real distance(const Line& a, const Point& b);`<br>`Real distance(const Line& a, const Segment& b);`<br>`Real distance(const Line& a, const Line& b);`|$\mathrm{A}$ と $\mathrm{B}$ の距離||
|`std::vector<Point> tangency(const Circle& a, const Point& b);`|点 $\mathrm{B}$ から円 $\mathrm{A}$ に引いた接線の接点|円 $(x - a)^2 + (y - b)^2 = r^2$ 上の点 $(x_0, y_0)$ における接線の方程式は $(x_0 - a)(x - a) + (y_0 - b)(y - b) = r^2$ である。|
|`int common_tangent_num(const Circle& a, const Circle& b);`|円 $\mathrm{A}$ と円 $\mathrm{B}$ の共通接線の本数||
|`std::vector<Line> common_tangent(const Circle& a, const Circle& b);`|円 $\mathrm{A}$ と円 $\mathrm{B}$ の共通接線|2円が接していないとき、`s` は円 $\mathrm{A}$ における接点、`t` は円 $\mathrm{B}$ における接点が格納される。|
|`Real intersection_area(const Circle& a, const Circle& b);`|円 $\mathrm{A}$ と円 $\mathrm{B}$ の共通部分の面積||
|`Real area(Polygon a);`|多角形 $\mathrm{A}$ の面積||
|`Point centroid(Polygon a);`|多角形 $\mathrm{A}$ の重心||
|`int contains(Polygon a, const Point &b);`|点 $\mathrm{B}$ は多角形 $\mathrm{A}$ の内部に存在するか。|`0` は外部、`1` は線上、`2` は内部を表す。|
|`bool is_convex(Polygon a);`|多角形 $\mathrm{A}$ は凸性を満たすか。||
|`Polygon monotone_chain(std::vector<Point> ps, const bool is_tight = true);`|点集合 $\mathrm{ps}$ の凸包|`is_tight` は凸包の辺上にある点を含まないかを表す。<br>座標幅 $w$ のとき、頂点数は $O(\sqrt{w})$ 個である。|
|`Polygon cut_convex(Polygon a, const Line& b);`|直線 $\mathrm{B}$ で凸多角形 $\mathrm{A}$ を切断したときの左側の凸多角形||
|`std::tuple<Point, Point> rotating_calipers(Polygon a);`|凸多角形 $\mathrm{A}$ の直径||


## 参考文献

- https://www.ioi-jp.org/camp/2017/2017-sp_camp-hide.pdf
- https://sen-comp.hatenablog.com/archive/category/%E3%80%8C%E5%9F%BA%E7%A4%8E%E7%9A%84%E8%A8%88%E7%AE%97%E5%B9%BE%E4%BD%95%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AE%E4%BD%9C%E3%82%8A%E6%96%B9%E3%80%8D
- http://www.deqnotes.net/acmicpc/2d_geometry/
- https://ei1333.github.io/luzhiled/snippets/geometry/template.html

最近点対
- 秋葉拓哉，岩田陽一，北川宜稔：プログラミングコンテストチャレンジブック \[第2版\]，pp.324-326，マイナビ出版（2012）

接点
- https://mathtrain.jp/ennosessen

2円の共通接線の本数
- http://www.e-learning-jp.net/teach_math/mathA/text_1/6/11/001a.htm

2円の共通接線
- http://nutsu.com/blog/2007/102601_as_circletest6.html

多角形の面積
- https://blog.goo.ne.jp/m4g/e/82eb68689c322dc43d52ce16b29a9a74

2円の共通部分の面積
- https://drken1215.hatenablog.com/entry/2020/02/02/005800

点の多角形に対する内外判定
- https://www.nttpc.co.jp/technology/number_algorithm.html


## TODO

- https://github.com/spaghetti-source/algorithm/blob/master/geometry/_geom.cc
- 3次元幾何学
  - https://github.com/beet-aizu/library/tree/master/geometry/3D
  - https://lumakernel.github.io/ecasdqina/geometory/geometory3D
  - https://github.com/drken1215/algorithm/blob/master/Geometry/basic_elements_3D.cpp
  - https://github.com/primenumber/ProconLib/blob/master/Geometry/3DGeometry.cpp
  - https://mugen1337.github.io/procon/Geometry3D/all.cpp
  - https://sotanishy.github.io/cp-library-cpp/geometry/geometry3d.hpp
  - 3次元凸包
    - https://lumakernel.github.io/ecasdqina/geometory/ConvexHull3D
    - https://www.slideshare.net/abc3141/3-65377198
- monotone chain 以外の凸包を求めるアルゴリズム
  - https://www.jaist.ac.jp/~uehara/course/2014/i481f/pdf/ppt-3.pdf
  - http://www-ikn.ist.hokudai.ac.jp/~k-sekine/slides/convexhull.pdf
  - http://www.thothchildren.com/chapter/5b268e086298160664e807e9
- 凸包の併合
  - https://atcoder.jp/contests/abc244/tasks/abc244_h
  - https://twitter.com/tatyam_prime/status/1505549013260537858
- 動的凸包
  - https://codeforces.com/blog/entry/75929
  - https://judge.yosupo.jp/problem/convex_layers
  - https://atcoder.jp/contests/geocon2013/tasks/geocon2013_c
  - https://atcoder.jp/contests/abc244/tasks/abc244_h
- 線分アレンジメント
  - https://github.com/ei1333/library/blob/master/geometry/template.cpp
  - https://ei1333.github.io/luzhiled/snippets/geometry/template.html
  - https://ei1333.github.io/algorithm/segment-arrangement.html
  - https://github.com/beet-aizu/library/blob/master/geometry/geometry.cpp
  - https://tubo28.me/compprog/algorithm/segment-arrangement/
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/segment_arrangement.cc
  - http://www.prefield.com/algorithm/geometry/segment_arrangement.html
  - https://github.com/primenumber/ProconLib/blob/master/Geometry/Arrangement.cpp
  - https://onlinejudge.u-aizu.ac.jp/problems/1033
- 直線アレンジメント
  - http://www.prefield.com/algorithm/geometry/walk_arrangement.html
  - https://nya3.jp/libicpc/#%E5%B9%BE%E4%BD%95/%E3%81%9D%E3%81%AE%E4%BB%96/%E3%82%A2%E3%83%AC%E3%83%B3%E3%82%B8%E3%83%A1%E3%83%B3%E3%83%88
- 円と多角形の共通部分の面積
  - https://github.com/ei1333/library/blob/master/geometry/template.cpp
  - https://ei1333.github.io/luzhiled/snippets/geometry/template.html
  - https://github.com/beet-aizu/library/blob/master/geometry/geometry.cpp
  - https://drken1215.hatenablog.com/entry/2020/02/02/091000
  - https://github.com/drken1215/algorithm/blob/master/Geometry/area_common_circle_polygon.cpp
  - http://kyopro.hateblo.jp/entry/2019/08/01/192232
  - https://topcoder-g-hatena-ne-jp.jag-icpc.org/not522/20130728/1374979041.html
  - https://twitter.com/not_522/status/1008671743584583682
- 円の和集合の面積
  - https://docs.google.com/presentation/d/119Ve9FB0qTzN01P4EKmia-atXMiPSsJGEDWotVZ6GDg
- 点と半直線の距離
  - https://sen-comp.hatenablog.com/entry/2020/03/14/183251#distanceBetweenPointAndRay%E7%82%B9%E3%81%A8%E5%8D%8A%E7%9B%B4%E7%B7%9A%E3%81%AE%E8%B7%9D%E9%9B%A2
- 凸多角形の共通部分
  - http://www.prefield.com/algorithm/geometry/convex_intersect.html
  - http://gihyo.jp/dev/serial/01/geometry/0009
- 点の凸多角形に対する内外判定
  - http://www.prefield.com/algorithm/geometry/convex_contains.html
- 直線から最も遠い凸多角形上の点
  - http://www.prefield.com/algorithm/geometry/convex_extreme.html
- 二等分線
  - https://sotanishy.github.io/cp-library-cpp/geometry/bisector.hpp
  - https://github.com/beet-aizu/library/blob/master/geometry/geometry.cpp
  - https://github.com/drken1215/algorithm/blob/master/Geometry/convex_cut.cpp
- 点から凸多角形への接線
  - https://tjkendev.github.io/procon-library/python/geometry/convex_polygon_tangent.html
- アポロニウスの円 (circle of Apollonius)
  - https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%9D%E3%83%AD%E3%83%8B%E3%82%A6%E3%82%B9%E3%81%AE%E5%86%86
  - https://mathtrain.jp/apollonius
  - https://github.com/drken1215/algorithm/blob/master/Geometry/All.cpp
  - https://onlinejudge.u-aizu.ac.jp/problems/1039
- 3点を通る円
  - http://www.prefield.com/algorithm/geometry/misc.html
- ピックの定理 (Pick's theorem)
  - https://ja.wikipedia.org/wiki/%E3%83%94%E3%83%83%E3%82%AF%E3%81%AE%E5%AE%9A%E7%90%86
  - https://mugen1337.github.io/procon/GeometryInt/CountLattice.cpp
- 線分の併合
  - http://www.prefield.com/algorithm/geometry/merge_segments.html
  - https://github.com/ei1333/library/blob/master/geometry/template.cpp
  - https://ei1333.github.io/luzhiled/snippets/geometry/template.html
  - https://onlinejudge.u-aizu.ac.jp/problems/1033
- 点位置決定問題 (point location problem)
  - https://en.wikipedia.org/wiki/Point_location
  - http://www.orsj.or.jp/~wiki/wiki/index.php/%E7%82%B9%E4%BD%8D%E7%BD%AE%E6%B1%BA%E5%AE%9A
  - https://ikatakos.com/pot/programming_algorithm/geometry/planar_point_location
  - http://www-imai.is.s.u-tokyo.ac.jp/~tsuyoshi/tmp/compgeo-20040608.pdf
  - http://www.prefield.com/algorithm/geometry/point_location.html
- 串刺し問題
  - http://www.prefield.com/algorithm/geometry/stabbing_line.html
- 耳分解 (ear decomposition)
  - https://en.wikipedia.org/wiki/Ear_decomposition
  - http://www.prefield.com/algorithm/geometry/triangulate.html
- 多角形の平行移動
  - http://www.prefield.com/algorithm/geometry/shrink_polygon.html
- ドロネー図 (delaunay diagram)
  - https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%AD%E3%83%8D%E3%83%BC%E5%9B%B3
  - https://www.slideshare.net/Kinokkory/ss-25736696
  - http://www.orsj.or.jp/~wiki/wiki/index.php/%E3%83%89%E3%83%AD%E3%83%8D%E3%83%BC%E5%9B%B3
  - http://www.thothchildren.com/chapter/5bded85141f88f267247fdc6
  - http://hadashia.hatenablog.com/entry/2018/10/11/194602
  - http://www.prefield.com/algorithm/geometry/delaunay.html
  - https://sotanishy.github.io/cp-library-cpp/geometry/delaunay_diagram.hpp
- kd 木 (k-d tree)
  - https://ja.wikipedia.org/wiki/Kd%E6%9C%A8
  - https://www.slideshare.net/okuraofvegetable/ss-65377588
  - https://trap.jp/post/1489/
  - https://twitter.com/noshi91/status/1395285823403167745
  - https://github.com/beet-aizu/library/blob/master/datastructure/kdtree.cpp
  - https://github.com/primenumber/ProconLib/blob/master/Structure/kdTree.cpp
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/kd_tree.cc
  - http://www.prefield.com/algorithm/geometry/kdtree.html
  - https://tjkendev.github.io/procon-library/cpp/range_query/kd-tree.html
  - https://mugen1337.github.io/procon/DataStructure/KDTree.cpp
  - https://sotanishy.github.io/cp-library-cpp/data-structure/kd_tree.cpp
  - https://atcoder.jp/contests/abc234/tasks/abc234_h
  - https://atcoder.jp/contests/abc234/submissions/28417490
  - randomized k-d tree
    - https://github.com/spaghetti-source/algorithm/blob/master/geometry/randomized_kd_tree.cc
    - https://www.slideshare.net/keisukeumezawa5/scalable-nearest-neighbor-algorithms-for-high-dimensional-data-71772599
- BK-tree
  - https://en.wikipedia.org/wiki/BK-tree
  - https://postd.cc/bk-tree/
  - https://postd.cc/symspell-vs-bk-tree-100x-faster-fuzzy-string-search-spell-checking/
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/bk_tree.cc
  - http://agtn.hatenablog.com/entry/2017/05/13/183310
- vantage-point tree (VP tree)
  - https://en.wikipedia.org/wiki/Vantage-point_tree
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/vantage_point_tree.cc
- rectilinear minimum spanning tree
  - https://en.wikipedia.org/wiki/Rectilinear_minimum_spanning_tree
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/rectilinear_mst.cc
- 双対変換
  - http://www.prefield.com/algorithm/geometry/dual_transformation.html
- 双対グラフ (dual graph)
  - https://en.wikipedia.org/wiki/Dual_graph
  - https://firiexp.github.io/library/library/geometry/dualgraph.cpp.html
  - https://github.com/primenumber/ProconLib/blob/master/Geometry/DualGraph.cpp
  - https://onlinejudge.u-aizu.ac.jp/problems/0273
- 斜方投射
  - https://github.com/beet-aizu/library/blob/master/geometry/projectilemotion.cpp
- random ball cover
  - http://www.lcayton.com/rbc.pdf
  - http://jsatml.blogspot.com/2012/10/random-ball-cover.html
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/random_ball_cover.cc
- On Finding the Maxima of a Set of Vectors
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/coordinate_domination.cc
- タクシー幾何学 (taxicab geometry)
  - https://en.wikipedia.org/wiki/Taxicab_geometry
- 問題集
  - https://gist.github.com/MiSawa/16d5f84cf66fd2913c82
- 三角形の外心 / 内心 / 垂心


## Submissons

- [点の回転](https://atcoder.jp/contests/abc259/submissions/33133157)
- [単位ベクトル](https://atcoder.jp/contests/abc246/submissions/30680516)
- [`ccw(a, b, c)`](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_1_C/review/4325588/emthrm/C++14)
- ~~$\angle{\mathrm{ABC}}$~~
- [最近点対](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_5_A/review/4325777/emthrm/C++14)
- [射影](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_1_A/review/4325794/emthrm/C++14)
- [鏡映](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_1_B/review/4325814/emthrm/C++14)
- [平行](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_A/review/4325838/emthrm/C++14)
- [垂直](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_A/review/4325838/emthrm/C++14)
- [点と線分の交差判定](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_D/review/4325929/emthrm/C++14)
- [2線分の交差判定](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_B/review/4325860/emthrm/C++14)
- ~~点と直線の交差判定~~
- ~~線分と直線の交差判定~~
- ~~2直線の交差判定~~
- ~~点と円の交差判定~~
- [線分と円の交差判定](https://onlinejudge.u-aizu.ac.jp/solutions/problem/2276/review/4339412/emthrm/C++14)
- ~~直線と円の交差判定~~
- ~~2円の交差判定~~
- [2直線の交点](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_4_C/review/4326103/emthrm/C++14)
- [2線分の交点](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_C/review/4325877/emthrm/C++14)
- ~~線分と直線の交点~~
- [直線と円の交点](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_D/review/4325892/emthrm/C++14)
- [線分と円の交点](https://onlinejudge.u-aizu.ac.jp/solutions/problem/2316/review/4345536/emthrm/C++14)
- [2円の交点](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_E/review/4325909/emthrm/C++14)
- [2点の距離](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_F/review/4325939/emthrm/C++14)
- [点と線分の距離](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_D/review/4325929/emthrm/C++14)
- [2線分の距離](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_D/review/4325929/emthrm/C++14)
- ~~点と直線の距離~~
- ~~線分と直線の距離~~
- ~~2直線の距離~~
- [接点](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_F/review/4325939/emthrm/C++14)
- [2円の共通接線の本数](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_A/review/4325959/emthrm/C++14)
- [2円の共通接線](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_G/review/4325977/emthrm/C++14)
- [2円の共通部分の面積](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_I/review/4967134/emthrm/C++17)
- [多角形の面積](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_3_A/review/4326007/emthrm/C++14)
- ~~多角形の重心~~
- [多角形に対する点の内外判定](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_3_C/review/4326013/emthrm/C++14)
- [凸性判定](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_3_B/review/4326091/emthrm/C++14)
- [凸包](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_4_A/review/4326095/emthrm/C++14)
- [凸多角形の切断](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_4_C/review/4326103/emthrm/C++14)
- [凸多角形の直径](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_4_B/review/4326112/emthrm/C++14)
