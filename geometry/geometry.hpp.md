---
data:
  _extendedDependsOn: []
  _extendedRequiredBy:
  - icon: ':heavy_check_mark:'
    path: geometry/smallest_enclosing_circle.hpp
    title: "\u6700\u5C0F\u5305\u542B\u5186 (smallest enclosing circle)"
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.01.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (ccw(a,\
      \ b, c))"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.02.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u6700\u8FD1\
      \u70B9\u5BFE)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.03.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u5C04\u5F71\
      )"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.04.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u93E1\u6620\
      )"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.05.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u5E73\u884C\
      \ / \u5782\u76F4)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.06.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u7DDA\
      \u5206\u306E\u4EA4\u5DEE\u5224\u5B9A)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.07.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u7DDA\u5206\
      \u3068\u5186\u306E\u4EA4\u5DEE\u5224\u5B9A)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.08.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u7DDA\
      \u5206\u306E\u4EA4\u70B9)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.09.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u76F4\u7DDA\
      \u3068\u5186\u306E\u4EA4\u70B9)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.10.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u7DDA\u5206\
      \u3068\u5186\u306E\u4EA4\u70B9)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.11.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u5186\
      \u306E\u4EA4\u70B9)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.12.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u7DDA\
      \u5206\u306E\u8DDD\u96E2)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.13.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u63A5\u70B9\
      )"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.14.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u5186\
      \u306E\u5171\u901A\u63A5\u7DDA\u306E\u672C\u6570)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.15.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u5186\
      \u306E\u5171\u901A\u63A5\u7DDA)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.16.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u5186\
      \u306E\u5171\u901A\u90E8\u5206\u306E\u9762\u7A4D)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.17.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u591A\u89D2\
      \u5F62\u306E\u9762\u7A4D)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.18.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u591A\u89D2\
      \u5F62\u306B\u5BFE\u3059\u308B\u70B9\u306E\u5185\u5916\u5224\u5B9A)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.19.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u51F8\u6027\
      \u5224\u5B9A)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.20.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u51F8\u5305\
      )"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.21.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u51F8\u591A\
      \u89D2\u5F62\u306E\u5207\u65AD)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.22.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u51F8\u591A\
      \u89D2\u5F62\u306E\u76F4\u5F84)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/smallest_enclosing_circle.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u6700\u5C0F\u5305\u542B\u5186"
  - icon: ':heavy_check_mark:'
    path: test/math/quadratic_equation.test.cpp
    title: "\u6570\u5B66/\u4E00\u5143\u4E8C\u6B21\u65B9\u7A0B\u5F0F"
  _isVerificationFailed: false
  _pathExtension: hpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    links: []
  bundledCode: "#line 2 \"geometry/geometry.hpp\"\n#include <algorithm>\r\n#include\
    \ <cassert>\r\n#include <cmath>\r\n#include <functional>\r\n#include <iostream>\r\
    \n#include <iterator>\r\n#include <limits>\r\n#include <utility>\r\n#include <vector>\r\
    \n\r\nnamespace geometry {\r\n\r\nusing Real = double;\r\nconstexpr long double\
    \ PI = 3.14159265358979323846;\r\n\r\nint sgn(const Real x) {\r\n  static constexpr\
    \ Real EPS = 1e-8;\r\n  return x > EPS ? 1 : (x < -EPS ? -1 : 0);\r\n}\r\n\r\n\
    Real degree_to_radian(const Real d) { return d * PI / 180; }\r\nReal radian_to_degree(const\
    \ Real r) { return r * 180 / PI; }\r\n\r\nstruct Point {\r\n  Real x, y;\r\n \
    \ explicit Point(const Real x = 0, const Real y = 0) : x(x), y(y) {}\r\n  Real\
    \ abs() const { return std::sqrt(norm()); }\r\n  Real arg() const {\r\n    const\
    \ Real res = std::atan2(y, x);\r\n    return res < 0 ? res + PI * 2 : res;\r\n\
    \  }\r\n  Real norm() const { return x * x + y * y; }\r\n  Point rotate(const\
    \ Real angle) const {\r\n    const Real cs = std::cos(angle), sn = std::sin(angle);\r\
    \n    return Point(x * cs - y * sn, x * sn + y * cs);\r\n  }\r\n  Point unit_vector()\
    \ const {\r\n    const Real a = abs();\r\n    return Point(x / a, y / a);\r\n\
    \  }\r\n  std::pair<Point, Point> normal_unit_vector() const {\r\n    const Point\
    \ u = unit_vector();\r\n    return {Point(-u.y, u.x), Point(u.y, -u.x)};\r\n \
    \ }\r\n  Point& operator+=(const Point& p) {\r\n    x += p.x; y += p.y;\r\n  \
    \  return *this;\r\n  }\r\n  Point& operator-=(const Point& p) {\r\n    x -= p.x;\
    \ y -= p.y;\r\n    return *this;\r\n  }\r\n  Point& operator*=(const Real k) {\r\
    \n    x *= k; y *= k;\r\n    return *this;\r\n  }\r\n  Point& operator/=(const\
    \ Real k) {\r\n    x /= k; y /= k;\r\n    return *this;\r\n  }\r\n  bool operator<(const\
    \ Point& p) const {\r\n    const int x_sgn = sgn(p.x - x);\r\n    return x_sgn\
    \ != 0 ? x_sgn == 1 : sgn(p.y - y) == 1;\r\n  }\r\n  bool operator<=(const Point&\
    \ p) const { return !(p < *this); }\r\n  bool operator>(const Point& p) const\
    \ { return p < *this; }\r\n  bool operator>=(const Point& p) const { return !(*this\
    \ < p); }\r\n  Point operator+() const { return *this; }\r\n  Point operator-()\
    \ const { return Point(-x, -y); }\r\n  Point operator+(const Point& p) const {\
    \ return Point(*this) += p; }\r\n  Point operator-(const Point& p) const { return\
    \ Point(*this) -= p; }\r\n  Point operator*(const Real k) const { return Point(*this)\
    \ *= k; }\r\n  Point operator/(const Real k) const { return Point(*this) /= k;\
    \ }\r\n  friend std::ostream& operator<<(std::ostream& os, const Point& p) {\r\
    \n    return os << '(' << p.x << \", \" << p.y << ')';\r\n  }\r\n  friend std::istream&\
    \ operator>>(std::istream& is, Point& p) {\r\n    Real x, y; is >> x >> y;\r\n\
    \    p = Point(x, y);\r\n    return is;\r\n  }\r\n};\r\n\r\nstruct Segment {\r\
    \n  Point s, t;\r\n  explicit Segment(const Point& s = Point(0, 0), const Point&\
    \ t = Point(0, 0))\r\n      : s(s), t(t) {}\r\n};\r\nstruct Line : Segment {\r\
    \n  using Segment::Segment;\r\n  explicit Line(const Real a, const Real b, const\
    \ Real c) {\r\n    if (sgn(a) == 0) {\r\n      s = Point(0, -c / b); t = Point(1,\
    \ s.y);\r\n    } else if (sgn(b) == 0) {\r\n      s = Point(-c / a, 0); t = Point(s.x,\
    \ 1);\r\n    } else if (sgn(c) == 0) {\r\n      s = Point(0, 0); t = Point(1,\
    \ -a / b);\r\n    } else {\r\n      s = Point(0, -c / b); t = Point(-c / a, 0);\r\
    \n    }\r\n  }\r\n};\r\n\r\nstruct Circle {\r\n  Point p; Real r;\r\n  explicit\
    \ Circle(const Point& p = Point(0, 0), const Real r = 0)\r\n      : p(p), r(r)\
    \ {}\r\n};\r\n\r\nReal cross(const Point& a, const Point& b) { return a.x * b.y\
    \ - a.y * b.x; }\r\nReal dot(const Point& a, const Point& b) { return a.x * b.x\
    \ + a.y * b.y; }\r\n\r\nint ccw(const Point& a, const Point& b, const Point& c)\
    \ {\r\n  const Point ab = b - a, ac = c - a;\r\n  const int sign = sgn(cross(ab,\
    \ ac));\r\n  if (sign == 0) {\r\n    if (sgn(dot(ab, ac)) == -1) return 2;\r\n\
    \    if (sgn(ac.norm() - ab.norm()) == 1) return -2;\r\n  }\r\n  return sign;\r\
    \n}\r\n\r\nReal get_angle(const Point& a, const Point& b, const Point& c) {\r\n\
    \  Real ab = (a - b).arg(), bc = (c - b).arg();\r\n  if (ab > bc) std::swap(ab,\
    \ bc);\r\n  return std::min(bc - ab, static_cast<Real>(PI * 2 - (bc - ab)));\r\
    \n}\r\n\r\nReal closest_pair(std::vector<Point> ps) {\r\n  const int n = ps.size();\r\
    \n  assert(n >= 2);\r\n  std::sort(ps.begin(), ps.end());\r\n  const std::function<Real(int,\
    \ int)> f =\r\n      [&ps, &f](const int left, const int right) -> Real {\r\n\
    \        const int mid = (left + right) >> 1;\r\n        Real x_mid = ps[mid].x,\
    \ d = std::numeric_limits<Real>::max();\r\n        if (left + 1 < mid) d = std::min(d,\
    \ f(left, mid));\r\n        if (mid + 1 < right) d = std::min(d, f(mid, right));\r\
    \n        std::inplace_merge(std::next(ps.begin(), left),\r\n                \
    \           std::next(ps.begin(), mid),\r\n                           std::next(ps.begin(),\
    \ right),\r\n                           [](const Point& a, const Point& b) ->\
    \ bool {\r\n                             return sgn(b.y - a.y) == 1;\r\n     \
    \                      });\r\n        std::vector<Point> tmp;\r\n        for (int\
    \ i = left; i < right; ++i) {\r\n          if (sgn(std::abs(ps[i].x - x_mid) -\
    \ d) == 1) continue;\r\n          for (int j = static_cast<int>(tmp.size()) -\
    \ 1; j >= 0; --j) {\r\n            const Point v = ps[i] - tmp[j];\r\n       \
    \     if (sgn(v.y - d) == 1) break;\r\n            d = std::min(d, v.abs());\r\
    \n          }\r\n          tmp.emplace_back(ps[i]);\r\n        }\r\n        return\
    \ d;\r\n      };\r\n  return f(0, n);\r\n}\r\n\r\nPoint projection(const Segment&\
    \ a, const Point& b) {\r\n  return a.s + (a.t - a.s) * dot(a.t - a.s, b - a.s)\
    \ / (a.t - a.s).norm();\r\n}\r\nPoint reflection(const Segment& a, const Point&\
    \ b) {\r\n  return projection(a, b) * 2 - b;\r\n}\r\n\r\nbool is_parallel(const\
    \ Segment& a, const Segment& b) {\r\n  return sgn(cross(a.t - a.s, b.t - b.s))\
    \ == 0;\r\n}\r\nbool is_orthogonal(const Segment& a, const Segment& b) {\r\n \
    \ return sgn(dot(a.t - a.s, b.t - b.s)) == 0;\r\n}\r\n\r\nReal distance(const\
    \ Point&, const Point&);\r\nReal distance(const Segment&, const Point&);\r\nReal\
    \ distance(const Line&, const Point&);\r\nint common_tangent_num(const Circle&,\
    \ const Circle&);\r\nbool has_intersected(const Segment& a, const Point& b) {\r\
    \n  return ccw(a.s, a.t, b) == 0;\r\n}\r\nbool has_intersected(const Segment&\
    \ a, const Segment& b) {\r\n  return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) <=\
    \ 0 &&\r\n         ccw(b.s, b.t, a.s) * ccw(b.s, b.t, a.t) <= 0;\r\n}\r\nbool\
    \ has_intersected(const Line& a, const Point& b) {\r\n  const int c = ccw(a.s,\
    \ a.t, b);\r\n  return c != 1 && c != -1;\r\n}\r\nbool has_intersected(const Line&\
    \ a, const Segment& b) {\r\n  return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) !=\
    \ 1;\r\n}\r\nbool has_intersected(const Line& a, const Line& b) {\r\n  return\
    \ sgn(cross(a.t - a.s, b.t - b.s)) != 0 ||\r\n         sgn(cross(a.t - a.s, b.s\
    \ - a.s)) == 0;\r\n}\r\nbool has_intersected(const Circle& a, const Point& b)\
    \ {\r\n  return sgn(distance(a.p, b) - a.r) == 0;\r\n}\r\nbool has_intersected(const\
    \ Circle& a, const Segment& b) {\r\n  return sgn(a.r - distance(b, a.p)) != -1\
    \ &&\r\n         sgn(std::max(distance(a.p, b.s), distance(a.p, b.t)) - a.r) !=\
    \ -1;\r\n}\r\nbool has_intersected(const Circle& a, const Line& b) {\r\n  return\
    \ sgn(a.r - distance(b, a.p)) != -1;\r\n}\r\nbool has_intersected(const Circle&\
    \ a, const Circle& b) {\r\n  const int num = common_tangent_num(a, b);\r\n  return\
    \ 1 <= num && num <= 3;\r\n}\r\n\r\nPoint intersection(const Line& a, const Line&\
    \ b) {\r\n  assert(has_intersected(a, b) && !is_parallel(a, b));\r\n  const Point\
    \ va = a.t - a.s, vb = b.t - b.s;\r\n  return a.s + va * cross(vb, b.s - a.s)\
    \ / cross(vb, va);\r\n}\r\nPoint intersection(const Segment& a, const Segment&\
    \ b) {\r\n  assert(has_intersected(a, b));\r\n  if (is_parallel(a, b)) {\r\n \
    \   if (sgn(distance(a.s, b.s)) == 0) {\r\n      assert(sgn(dot(a.t - a.s, b.t\
    \ - a.s)) == -1);\r\n      return a.s;\r\n    } else if (sgn(distance(a.s, b.t))\
    \ == 0) {\r\n      assert(sgn(dot(a.t - a.s, b.s - a.s)) == -1);\r\n      return\
    \ a.s;\r\n    } else if (sgn(distance(a.t, b.s)) == 0) {\r\n      assert(sgn(dot(a.s\
    \ - a.t, b.t - a.t)) == -1);\r\n      return a.t;\r\n    } else if (sgn(distance(a.t,\
    \ b.t)) == 0) {\r\n      assert(sgn(dot(a.s - a.t, b.s - a.t)) == -1);\r\n   \
    \   return a.t;\r\n    } else {\r\n      assert(false);\r\n    }\r\n  } else {\r\
    \n    return intersection(Line(a.s, a.t), Line(b.s, b.t));\r\n  }\r\n}\r\nPoint\
    \ intersection(const Line& a, const Segment& b) {\r\n  assert(has_intersected(a,\
    \ b));\r\n  return intersection(a, Line(b.s, b.t));\r\n}\r\nstd::vector<Point>\
    \ intersection(const Circle& a, const Line& b) {\r\n  const Point pro = projection(b,\
    \ a.p);\r\n  const Real nor = (a.p - pro).norm();\r\n  const int sign = sgn(a.r\
    \ - std::sqrt(nor));\r\n  if (sign == -1) return {};\r\n  if (sign == 0) return\
    \ {pro};\r\n  const Point tmp = (b.t - b.s).unit_vector() * std::sqrt(a.r * a.r\
    \ - nor);\r\n  return {pro + tmp, pro - tmp};\r\n}\r\nstd::vector<Point> intersection(const\
    \ Circle& a, const Segment& b) {\r\n  if (!has_intersected(a, b)) return {};\r\
    \n  const std::vector<Point> res = intersection(a, Line(b.s, b.t));\r\n  if (sgn(distance(a.p,\
    \ b.s) - a.r) != -1 &&\r\n      sgn(distance(a.p, b.t) - a.r) != -1) {\r\n   \
    \ return res;\r\n  }\r\n  return {res[sgn(dot(res[0] - b.s, res[0] - b.t)) ==\
    \ 1 ? 1 : 0]};\r\n}\r\nstd::vector<Point> intersection(const Circle& a, const\
    \ Circle& b) {\r\n  const int num = common_tangent_num(a, b);\r\n  if (num ==\
    \ 0 || num == 4) return {};\r\n  const Real alpha = (b.p - a.p).arg();\r\n  if\
    \ (num == 1 || num == 3) {\r\n    return {Point(a.p.x + a.r * std::cos(alpha),\r\
    \n                  a.p.y + a.r * std::sin(alpha))};\r\n  }\r\n  const Real dist\
    \ = (b.p - a.p).norm();\r\n  const Real beta =\r\n      std::acos((dist + a.r\
    \ * a.r - b.r * b.r) / (2 * std::sqrt(dist) * a.r));\r\n  return {\r\n      a.p\
    \ + Point(a.r * std::cos(alpha + beta), a.r * std::sin(alpha + beta)),\r\n   \
    \   a.p + Point(a.r * std::cos(alpha - beta), a.r * std::sin(alpha - beta))};\r\
    \n}\r\n\r\nReal distance(const Point& a, const Point& b) { return (b - a).abs();\
    \ }\r\nReal distance(const Segment& a, const Point& b) {\r\n  const Point foot\
    \ = projection(a, b);\r\n  return has_intersected(a, foot) ?\r\n         distance(foot,\
    \ b) : std::min(distance(a.s, b), distance(a.t, b));\r\n}\r\nReal distance(const\
    \ Segment& a, const Segment& b) {\r\n  return has_intersected(a, b) ? 0 :\r\n\
    \         std::min({distance(a, b.s), distance(a, b.t),\r\n                  \
    \ distance(b, a.s), distance(b, a.t)});\r\n}\r\nReal distance(const Line& a, const\
    \ Point& b) {\r\n  return distance(projection(a, b), b);\r\n}\r\nReal distance(const\
    \ Line& a, const Segment& b) {\r\n  return has_intersected(a, b) ?\r\n       \
    \  0 : std::min(distance(a, b.s), distance(a, b.t));\r\n}\r\nReal distance(const\
    \ Line& a, const Line& b) {\r\n  return has_intersected(a, b) ? 0 : distance(a,\
    \ b.s);\r\n}\r\n\r\nstd::vector<Point> tangency(const Circle& a, const Point&\
    \ b) {\r\n  const Real dist = distance(a.p, b);\r\n  const int sign = sgn(dist\
    \ - a.r);\r\n  if (sign == -1) return {};\r\n  if (sign == 0) return {b};\r\n\
    \  const Real alpha = (b - a.p).arg(), beta = std::acos(a.r / dist);\r\n  return\
    \ {\r\n      a.p + Point(a.r * std::cos(alpha + beta), a.r * std::sin(alpha +\
    \ beta)),\r\n      a.p + Point(a.r * std::cos(alpha - beta), a.r * std::sin(alpha\
    \ - beta))};\r\n}\r\nint common_tangent_num(const Circle& a, const Circle& b)\
    \ {\r\n  const Real dist = distance(a.p, b.p);\r\n  int sign = sgn(a.r + b.r -\
    \ dist);\r\n  if (sign == -1) return 4;\r\n  if (sign == 0) return 3;\r\n  sign\
    \ = sgn((sgn(a.r - b.r) == -1 ? b.r - a.r : a.r - b.r) - dist);\r\n  if (sign\
    \ == -1) return 2;\r\n  if (sign == 0) return 1;\r\n  return 0;\r\n}\r\nstd::vector<Line>\
    \ common_tangent(const Circle& a, const Circle& b) {\r\n  std::vector<Line> tangents;\r\
    \n  const Real dist = distance(a.p, b.p), argument = (b.p - a.p).arg();\r\n  int\
    \ sign = sgn(a.r + b.r - dist);\r\n  if (sign == -1) {\r\n    const Real ac =\
    \ std::acos((a.r + b.r) / dist);\r\n    Real alpha = argument + ac, cs = std::cos(alpha),\
    \ sn = std::sin(alpha);\r\n    tangents.emplace_back(a.p + Point(a.r * cs, a.r\
    \ * sn),\r\n                          b.p + Point(-b.r * cs, -b.r * sn));\r\n\
    \    alpha = argument - ac; cs = std::cos(alpha); sn = std::sin(alpha);\r\n  \
    \  tangents.emplace_back(a.p + Point(a.r * cs, a.r * sn),\r\n                \
    \          b.p + Point(-b.r * cs, -b.r * sn));\r\n  } else if (sign == 0) {\r\n\
    \    const Point s =\r\n        a.p + Point(a.r * std::cos(argument), a.r * std::sin(argument));\r\
    \n    tangents.emplace_back(s, s + (b.p - a.p).normal_unit_vector().first);\r\n\
    \  }\r\n  if (sgn(b.r - a.r) == -1) {\r\n    sign = sgn(a.r - b.r - dist);\r\n\
    \    if (sign == -1) {\r\n      const Real at = std::acos((a.r - b.r) / dist);\r\
    \n      Real alpha = argument + at, cs = std::cos(alpha), sn = std::sin(alpha);\r\
    \n      tangents.emplace_back(a.p + Point(a.r * cs, a.r * sn),\r\n           \
    \                 b.p + Point(b.r * cs, b.r * sn));\r\n      alpha = argument\
    \ - at; cs = std::cos(alpha); sn = std::sin(alpha);\r\n      tangents.emplace_back(a.p\
    \ + Point(a.r * cs, a.r * sn),\r\n                            b.p + Point(b.r\
    \ * cs, b.r * sn));\r\n    } else if (sign == 0) {\r\n      const Point s =\r\n\
    \          a.p + Point(a.r * std::cos(argument), a.r * std::sin(argument));\r\n\
    \      tangents.emplace_back(s, s + (b.p - a.p).normal_unit_vector().first);\r\
    \n    }\r\n  } else {\r\n    sign = sgn(b.r - a.r - dist);\r\n    if (sign ==\
    \ -1) {\r\n      const Real at = std::acos((b.r - a.r) / dist);\r\n      Real\
    \ alpha = argument - at, cs = std::cos(alpha), sn = std::sin(alpha);\r\n     \
    \ tangents.emplace_back(a.p + Point(-a.r * cs, -a.r * sn),\r\n               \
    \             b.p + Point(-b.r * cs, -b.r * sn));\r\n      alpha = argument +\
    \ at; cs = std::cos(alpha); sn = std::sin(alpha);\r\n      tangents.emplace_back(a.p\
    \ + Point(-a.r * cs, -a.r * sn),\r\n                            b.p + Point(-b.r\
    \ * cs, -b.r * sn));\r\n    } else if (sign == 0) {\r\n      const Point s =\r\
    \n          b.p + Point(-b.r * std::cos(argument), -b.r * std::sin(argument));\r\
    \n      tangents.emplace_back(s, s + (a.p - b.p).normal_unit_vector().first);\r\
    \n    }\r\n  }\r\n  return tangents;\r\n}\r\n\r\nReal intersection_area(const\
    \ Circle& a, const Circle& b) {\r\n  const Real nor = (b.p - a.p).norm(), dist\
    \ = std::sqrt(nor);\r\n  if (sgn(a.r + b.r - dist) != 1) return 0;\r\n  if (sgn(std::abs(a.r\
    \ - b.r) - dist) != -1) {\r\n    return std::min(a.r, b.r) * std::min(a.r, b.r)\
    \ * PI;\r\n  }\r\n  const Real alpha =\r\n      std::acos((nor + a.r * a.r - b.r\
    \ * b.r) / (2 * dist * a.r));\r\n  const Real beta = std::acos((nor + b.r * b.r\
    \ - a.r * a.r) / (2 * dist * b.r));\r\n  return (alpha - std::sin(alpha + alpha)\
    \ * 0.5) * a.r * a.r +\r\n         (beta - std::sin(beta + beta) * 0.5) * b.r\
    \ * b.r;\r\n}\r\n\r\nusing Polygon = std::vector<Point>;\r\n\r\nReal area(Polygon\
    \ a) {\r\n  const int n = a.size();\r\n  a.resize(n + 1);\r\n  a.back() = a.front();\r\
    \n  Real res = 0;\r\n  for (int i = 0; i < n; ++i) {\r\n    res += cross(a[i],\
    \ a[i + 1]);\r\n  }\r\n  return res * 0.5;\r\n}\r\n\r\nPoint centroid(Polygon\
    \ a) {\r\n  const int n = a.size();\r\n  a.resize(n + 1);\r\n  a.back() = a.front();\r\
    \n  Point res(0, 0);\r\n  Real den = 0;\r\n  for (int i = 0; i < n; ++i) {\r\n\
    \    const Real cro = cross(a[i], a[i + 1]);\r\n    res += (a[i] + a[i + 1]) /\
    \ 3 * cro;\r\n    den += cro;\r\n  }\r\n  return res / den;\r\n}\r\n\r\nint contains(Polygon\
    \ a, const Point &b) {\r\n  const int n = a.size();\r\n  a.resize(n + 1);\r\n\
    \  a.back() = a.front();\r\n  bool is_in = false;\r\n  for (int i = 0; i < n;\
    \ ++i) {\r\n    Point p = a[i] - b, q = a[i + 1] - b;\r\n    if (sgn(q.y - p.y)\
    \ == -1) std::swap(p, q);\r\n    const int sign = sgn(cross(p, q));\r\n    if\
    \ (sign == 1 && sgn(p.y) != 1 && sgn(q.y) == 1) is_in = !is_in;\r\n    if (sign\
    \ == 0 && sgn(dot(p, q)) != 1) return 1;\r\n  }\r\n  return is_in ? 2 : 0;\r\n\
    }\r\n\r\nbool is_convex(Polygon a) {\r\n  const int n = a.size();\r\n  a.resize(n\
    \ + 2);\r\n  a[n] = a[0];\r\n  a[n + 1] = a[1];\r\n  for (int i = 1; i <= n; ++i)\
    \ {\r\n    if (ccw(a[i - 1], a[i], a[i + 1]) == -1) return false;\r\n  }\r\n \
    \ return true;\r\n}\r\n\r\nPolygon monotone_chain(std::vector<Point> ps, const\
    \ bool is_tight = true) {\r\n  const int n = ps.size();\r\n  std::sort(ps.begin(),\
    \ ps.end());\r\n  Polygon convex_hull(n << 1);\r\n  int idx = 0;\r\n  for (int\
    \ i = 0; i < n; convex_hull[idx++] = ps[i++]) {\r\n    while (idx >= 2 &&\r\n\
    \           sgn(cross(convex_hull[idx - 1] - convex_hull[idx - 2],\r\n       \
    \              ps[i] - convex_hull[idx - 1])) < is_tight) {\r\n      --idx;\r\n\
    \    }\r\n  }\r\n  for (int i = n - 2, border = idx + 1; i >= 0; convex_hull[idx++]\
    \ = ps[i--]) {\r\n    while (idx >= border &&\r\n           sgn(cross(convex_hull[idx\
    \ - 1] - convex_hull[idx - 2],\r\n                     ps[i] - convex_hull[idx\
    \ - 1])) < is_tight) {\r\n      --idx;\r\n    }\r\n  }\r\n  convex_hull.resize(idx\
    \ - 1);\r\n  return convex_hull;\r\n}\r\n\r\nPolygon cut_convex(Polygon a, const\
    \ Line& b) {\r\n  const int n = a.size();\r\n  a.resize(n + 1);\r\n  a.back()\
    \ = a.front();\r\n  Polygon res;\r\n  for (int i = 0; i < n; ++i) {\r\n    const\
    \ int c = ccw(b.s, b.t, a[i]);\r\n    if (c != -1) res.emplace_back(a[i]);\r\n\
    \    if (c * ccw(b.s, b.t, a[i + 1]) == -1) {\r\n      res.emplace_back(intersection(Line(a[i],\
    \ a[i + 1]), b));\r\n    }\r\n  }\r\n  return res.size() < 3 ? Polygon() : res;\r\
    \n}\r\n\r\nstd::pair<Point, Point> rotating_calipers(Polygon a) {\r\n  const int\
    \ n = a.size();\r\n  if (n <= 2) {\r\n    assert(n == 2);\r\n    return {a[0],\
    \ a[1]};\r\n  }\r\n  a.resize(n + 1);\r\n  a.back() = a.front();\r\n  int high\
    \ = 0, low = 0;\r\n  for (int i = 1; i < n; ++i) {\r\n    if (a[i].y > a[high].y)\
    \ high = i;\r\n    if (a[i].y < a[low].y) low = i;\r\n  }\r\n  Real max_norm =\
    \ (a[high] - a[low]).norm();\r\n  int i = high, j = low, argmax_i = i, argmax_j\
    \ = j;\r\n  do {\r\n    int* i_or_j = &(sgn(cross(a[i + 1] - a[i], a[j + 1] -\
    \ a[j])) != -1 ? j : i);\r\n    if (++(*i_or_j) == n) *i_or_j = 0;\r\n    const\
    \ Real tmp = (a[j] - a[i]).norm();\r\n    if (sgn(tmp - max_norm) == 1) {\r\n\
    \      max_norm = tmp;\r\n      argmax_i = i; argmax_j = j;\r\n    }\r\n  } while\
    \ (i != high || j != low);\r\n  return {a[argmax_i], a[argmax_j]};\r\n}\r\n\r\n\
    }  // namespace geometry\r\n\r\n// namespace geometry {\r\n\r\n// using Integer\
    \ = long long;\r\n\r\n// int sgn(const Integer x) {\r\n//   return x > 0 ? 1 :\
    \ (x < 0 ? -1 : 0);\r\n// }\r\n\r\n// struct Point {\r\n//   Integer x, y;\r\n\
    //   explicit Point(const Integer x = 0, const Integer y = 0) : x(x), y(y) {}\r\
    \n//   Integer norm() const { return x * x + y * y; }\r\n//   Point& operator+=(const\
    \ Point& p) {\r\n//     x += p.x; y += p.y;\r\n//     return *this;\r\n//   }\r\
    \n//   Point& operator-=(const Point& p) {\r\n//     x -= p.x; y -= p.y;\r\n//\
    \     return *this;\r\n//   }\r\n//   Point& operator*=(const Integer k) {\r\n\
    //     x *= k; y *= k;\r\n//     return *this;\r\n//   }\r\n//   Point& operator/=(const\
    \ Integer k) {\r\n//     x /= k; y /= k;\r\n//     return *this;\r\n//   }\r\n\
    //   bool operator<(const Point& p) const {\r\n//     const int x_sgn = sgn(p.x\
    \ - x);\r\n//     return x_sgn != 0 ? x_sgn == 1 : sgn(p.y - y) == 1;\r\n//  \
    \ }\r\n//   bool operator<=(const Point& p) const { return !(p < *this); }\r\n\
    //   bool operator>(const Point& p) const { return p < *this; }\r\n//   bool operator>=(const\
    \ Point& p) const { return !(*this < p); }\r\n//   Point operator+() const { return\
    \ *this; }\r\n//   Point operator-() const { return Point(-x, -y); }\r\n//   Point\
    \ operator+(const Point& p) const { return Point(*this) += p; }\r\n//   Point\
    \ operator-(const Point& p) const { return Point(*this) -= p; }\r\n//   Point\
    \ operator*(const Integer k) const { return Point(*this) *= k; }\r\n//   Point\
    \ operator/(const Integer k) const { return Point(*this) /= k; }\r\n//   friend\
    \ std::ostream& operator<<(std::ostream& os, const Point& p) {\r\n//     return\
    \ os << '(' << p.x << \", \" << p.y << ')';\r\n//   }\r\n//   friend std::istream&\
    \ operator>>(std::istream& is, Point& p) {\r\n//     Integer x, y; is >> x >>\
    \ y;\r\n//     p = Point(x, y);\r\n//     return is;\r\n//   }\r\n// };\r\n\r\n\
    // struct Segment {\r\n//   Point s, t;\r\n//   explicit Segment(const Point&\
    \ s = Point(0, 0), const Point& t = Point(0, 0))\r\n//       : s(s), t(t) {}\r\
    \n// };\r\n// struct Line : Segment {\r\n//   using Segment::Segment;\r\n// };\r\
    \n\r\n// struct Circle {\r\n//   Point p; Integer r;\r\n//   explicit Circle(const\
    \ Point& p = Point(0, 0), const Integer r = 0)\r\n//       : p(p), r(r) {}\r\n\
    // };\r\n\r\n// Integer cross(const Point& a, const Point& b) { return a.x * b.y\
    \ - a.y * b.x; }\r\n// Integer dot(const Point& a, const Point& b) { return a.x\
    \ * b.x + a.y * b.y; }\r\n\r\n// int ccw(const Point& a, const Point& b, const\
    \ Point& c) {\r\n//   const Point ab = b - a, ac = c - a;\r\n//   const int sign\
    \ = sgn(cross(ab, ac));\r\n//   if (sign == 0) {\r\n//     if (sgn(dot(ab, ac))\
    \ == -1) return 2;\r\n//     if (sgn(ac.norm() - ab.norm()) == 1) return -2;\r\
    \n//   }\r\n//   return sign;\r\n// }\r\n\r\n// Integer closest_pair(std::vector<Point>\
    \ ps) {\r\n//   const int n = ps.size();\r\n//   assert(n >= 2);\r\n//   std::sort(ps.begin(),\
    \ ps.end());\r\n//   const std::function<Integer(int, int)> f =\r\n//       [&ps,\
    \ &f](const int left, const int right) -> Integer {\r\n//         const int mid\
    \ = (left + right) >> 1;\r\n//         Integer x_mid = ps[mid].x, d = std::numeric_limits<Integer>::max();\r\
    \n//         if (left + 1 < mid) d = std::min(d, f(left, mid));\r\n//        \
    \ if (mid + 1 < right) d = std::min(d, f(mid, right));\r\n//         std::inplace_merge(std::next(ps.begin(),\
    \ left),\r\n//                            std::next(ps.begin(), mid),\r\n//  \
    \                          std::next(ps.begin(), right),\r\n//               \
    \             [](const Point& a, const Point& b) -> bool {\r\n//             \
    \                 return sgn(b.y - a.y) == 1;\r\n//                          \
    \  });\r\n//         std::vector<Point> tmp;\r\n//         for (int i = left;\
    \ i < right; ++i) {\r\n//           if (sgn((ps[i].x - x_mid) * (ps[i].x - x_mid)\
    \ - d) == 1) continue;\r\n//           for (int j = static_cast<int>(tmp.size())\
    \ - 1; j >= 0; --j) {\r\n//             const Point v = ps[i] - tmp[j];\r\n//\
    \             if (sgn(v.y * v.y - d) == 1) break;\r\n//             d = std::min(d,\
    \ v.norm());\r\n//           }\r\n//           tmp.emplace_back(ps[i]);\r\n//\
    \         }\r\n//         return d;\r\n//       };\r\n//   return f(0, n);\r\n\
    // }\r\n\r\n// bool is_parallel(const Segment& a, const Segment& b) {\r\n//  \
    \ return sgn(cross(a.t - a.s, b.t - b.s)) == 0;\r\n// }\r\n// bool is_orthogonal(const\
    \ Segment& a, const Segment& b) {\r\n//   return sgn(dot(a.t - a.s, b.t - b.s))\
    \ == 0;\r\n// }\r\n\r\n// int common_tangent_num(const Circle&, const Circle&);\r\
    \n// bool has_intersected(const Segment& a, const Point& b) {\r\n//   return ccw(a.s,\
    \ a.t, b) == 0;\r\n// }\r\n// bool has_intersected(const Segment& a, const Segment&\
    \ b) {\r\n//   return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) <= 0 &&\r\n//  \
    \        ccw(b.s, b.t, a.s) * ccw(b.s, b.t, a.t) <= 0;\r\n// }\r\n// bool has_intersected(const\
    \ Line& a, const Point& b) {\r\n//   const int c = ccw(a.s, a.t, b);\r\n//   return\
    \ c != 1 && c != -1;\r\n// }\r\n// bool has_intersected(const Line& a, const Segment&\
    \ b) {\r\n//   return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) != 1;\r\n// }\r\n\
    // bool has_intersected(const Line& a, const Line& b) {\r\n//   return sgn(cross(a.t\
    \ - a.s, b.t - b.s)) != 0 ||\r\n//          sgn(cross(a.t - a.s, b.s - a.s)) ==\
    \ 0;\r\n// }\r\n// bool has_intersected(const Circle& a, const Point& b) {\r\n\
    //   return (a.p - b).norm() == a.r * a.r;\r\n// }\r\n// bool has_intersected(const\
    \ Circle& a, const Circle& b) {\r\n//   const int num = common_tangent_num(a,\
    \ b);\r\n//   return 1 <= num && num <= 3;\r\n// }\r\n\r\n// int common_tangent_num(const\
    \ Circle& a, const Circle& b) {\r\n//   const Integer dist = (a.p - b.p).norm();\r\
    \n//   int sign = sgn((a.r + b.r) * (a.r + b.r) - dist);\r\n//   if (sign == -1)\
    \ return 4;\r\n//   if (sign == 0) return 3;\r\n//   sign = sgn((b.r - a.r) *\
    \ (b.r - a.r) - dist);\r\n//   if (sign == -1) return 2;\r\n//   if (sign == 0)\
    \ return 1;\r\n//   return 0;\r\n// }\r\n\r\n// using Polygon = std::vector<Point>;\r\
    \n\r\n// Integer area(Polygon a) {\r\n//   const int n = a.size();\r\n//   a.resize(n\
    \ + 1);\r\n//   a.back() = a.front();\r\n//   Integer res = 0;\r\n//   for (int\
    \ i = 0; i < n; ++i) {\r\n//     res += cross(a[i], a[i + 1]);\r\n//   }\r\n//\
    \   // return res / 2;\r\n//   return res;\r\n// }\r\n\r\n// int contains(Polygon\
    \ a, const Point &b) {\r\n//   const int n = a.size();\r\n//   a.resize(n + 1);\r\
    \n//   a.back() = a.front();\r\n//   bool is_in = false;\r\n//   for (int i =\
    \ 0; i < n; ++i) {\r\n//     Point p = a[i] - b, q = a[i + 1] - b;\r\n//     if\
    \ (sgn(q.y - p.y) == -1) std::swap(p, q);\r\n//     const int sign = sgn(cross(p,\
    \ q));\r\n//     if (sign == 1 && sgn(p.y) != 1 && sgn(q.y) == 1) is_in = !is_in;\r\
    \n//     if (sign == 0 && sgn(dot(p, q)) != 1) return 1;\r\n//   }\r\n//   return\
    \ is_in ? 2 : 0;\r\n// }\r\n\r\n// bool is_convex(Polygon a) {\r\n//   const int\
    \ n = a.size();\r\n//   a.resize(n + 2);\r\n//   a[n] = a[0];\r\n//   a[n + 1]\
    \ = a[1];\r\n//   for (int i = 1; i <= n; ++i) {\r\n//     if (ccw(a[i - 1], a[i],\
    \ a[i + 1]) == -1) return false;\r\n//   }\r\n//   return true;\r\n// }\r\n\r\n\
    // Polygon monotone_chain(std::vector<Point> ps, const bool is_tight = true) {\r\
    \n//   const int n = ps.size();\r\n//   std::sort(ps.begin(), ps.end());\r\n//\
    \   Polygon convex_hull(n << 1);\r\n//   int idx = 0;\r\n//   for (int i = 0;\
    \ i < n; convex_hull[idx++] = ps[i++]) {\r\n//     while (idx >= 2 &&\r\n//  \
    \          sgn(cross(convex_hull[idx - 1] - convex_hull[idx - 2],\r\n//      \
    \                ps[i] - convex_hull[idx - 1])) < is_tight) {\r\n//       --idx;\r\
    \n//     }\r\n//   }\r\n//   for (int i = n - 2, border = idx + 1; i >= 0; convex_hull[idx++]\
    \ = ps[i--]) {\r\n//     while (idx >= border &&\r\n//            sgn(cross(convex_hull[idx\
    \ - 1] - convex_hull[idx - 2],\r\n//                      ps[i] - convex_hull[idx\
    \ - 1])) < is_tight) {\r\n//       --idx;\r\n//     }\r\n//   }\r\n//   convex_hull.resize(idx\
    \ - 1);\r\n//   return convex_hull;\r\n// }\r\n\r\n// std::pair<Point, Point>\
    \ rotating_calipers(Polygon a) {\r\n//   const int n = a.size();\r\n//   if (n\
    \ <= 2) {\r\n//     assert(n == 2);\r\n//     return {a[0], a[1]};\r\n//   }\r\
    \n//   a.resize(n + 1);\r\n//   a.back() = a.front();\r\n//   int high = 0, low\
    \ = 0;\r\n//   for (int i = 1; i < n; ++i) {\r\n//     if (a[i].y > a[high].y)\
    \ high = i;\r\n//     if (a[i].y < a[low].y) low = i;\r\n//   }\r\n//   Integer\
    \ max_norm = (a[high] - a[low]).norm();\r\n//   int i = high, j = low, argmax_i\
    \ = i, argmax_j = j;\r\n//   do {\r\n//     int* i_or_j = &(sgn(cross(a[i + 1]\
    \ - a[i], a[j + 1] - a[j])) != -1 ? j : i);\r\n//     if (++(*i_or_j) == n) *i_or_j\
    \ = 0;\r\n//     const Integer tmp = (a[j] - a[i]).norm();\r\n//     if (sgn(tmp\
    \ - max_norm) == 1) {\r\n//       max_norm = tmp;\r\n//       argmax_i = i; argmax_j\
    \ = j;\r\n//     }\r\n//   } while (i != high || j != low);\r\n//   return {a[argmax_i],\
    \ a[argmax_j]};\r\n// }\r\n\r\n// }  // namespace geometry\r\n"
  code: "#pragma once\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <cmath>\r\
    \n#include <functional>\r\n#include <iostream>\r\n#include <iterator>\r\n#include\
    \ <limits>\r\n#include <utility>\r\n#include <vector>\r\n\r\nnamespace geometry\
    \ {\r\n\r\nusing Real = double;\r\nconstexpr long double PI = 3.14159265358979323846;\r\
    \n\r\nint sgn(const Real x) {\r\n  static constexpr Real EPS = 1e-8;\r\n  return\
    \ x > EPS ? 1 : (x < -EPS ? -1 : 0);\r\n}\r\n\r\nReal degree_to_radian(const Real\
    \ d) { return d * PI / 180; }\r\nReal radian_to_degree(const Real r) { return\
    \ r * 180 / PI; }\r\n\r\nstruct Point {\r\n  Real x, y;\r\n  explicit Point(const\
    \ Real x = 0, const Real y = 0) : x(x), y(y) {}\r\n  Real abs() const { return\
    \ std::sqrt(norm()); }\r\n  Real arg() const {\r\n    const Real res = std::atan2(y,\
    \ x);\r\n    return res < 0 ? res + PI * 2 : res;\r\n  }\r\n  Real norm() const\
    \ { return x * x + y * y; }\r\n  Point rotate(const Real angle) const {\r\n  \
    \  const Real cs = std::cos(angle), sn = std::sin(angle);\r\n    return Point(x\
    \ * cs - y * sn, x * sn + y * cs);\r\n  }\r\n  Point unit_vector() const {\r\n\
    \    const Real a = abs();\r\n    return Point(x / a, y / a);\r\n  }\r\n  std::pair<Point,\
    \ Point> normal_unit_vector() const {\r\n    const Point u = unit_vector();\r\n\
    \    return {Point(-u.y, u.x), Point(u.y, -u.x)};\r\n  }\r\n  Point& operator+=(const\
    \ Point& p) {\r\n    x += p.x; y += p.y;\r\n    return *this;\r\n  }\r\n  Point&\
    \ operator-=(const Point& p) {\r\n    x -= p.x; y -= p.y;\r\n    return *this;\r\
    \n  }\r\n  Point& operator*=(const Real k) {\r\n    x *= k; y *= k;\r\n    return\
    \ *this;\r\n  }\r\n  Point& operator/=(const Real k) {\r\n    x /= k; y /= k;\r\
    \n    return *this;\r\n  }\r\n  bool operator<(const Point& p) const {\r\n   \
    \ const int x_sgn = sgn(p.x - x);\r\n    return x_sgn != 0 ? x_sgn == 1 : sgn(p.y\
    \ - y) == 1;\r\n  }\r\n  bool operator<=(const Point& p) const { return !(p <\
    \ *this); }\r\n  bool operator>(const Point& p) const { return p < *this; }\r\n\
    \  bool operator>=(const Point& p) const { return !(*this < p); }\r\n  Point operator+()\
    \ const { return *this; }\r\n  Point operator-() const { return Point(-x, -y);\
    \ }\r\n  Point operator+(const Point& p) const { return Point(*this) += p; }\r\
    \n  Point operator-(const Point& p) const { return Point(*this) -= p; }\r\n  Point\
    \ operator*(const Real k) const { return Point(*this) *= k; }\r\n  Point operator/(const\
    \ Real k) const { return Point(*this) /= k; }\r\n  friend std::ostream& operator<<(std::ostream&\
    \ os, const Point& p) {\r\n    return os << '(' << p.x << \", \" << p.y << ')';\r\
    \n  }\r\n  friend std::istream& operator>>(std::istream& is, Point& p) {\r\n \
    \   Real x, y; is >> x >> y;\r\n    p = Point(x, y);\r\n    return is;\r\n  }\r\
    \n};\r\n\r\nstruct Segment {\r\n  Point s, t;\r\n  explicit Segment(const Point&\
    \ s = Point(0, 0), const Point& t = Point(0, 0))\r\n      : s(s), t(t) {}\r\n\
    };\r\nstruct Line : Segment {\r\n  using Segment::Segment;\r\n  explicit Line(const\
    \ Real a, const Real b, const Real c) {\r\n    if (sgn(a) == 0) {\r\n      s =\
    \ Point(0, -c / b); t = Point(1, s.y);\r\n    } else if (sgn(b) == 0) {\r\n  \
    \    s = Point(-c / a, 0); t = Point(s.x, 1);\r\n    } else if (sgn(c) == 0) {\r\
    \n      s = Point(0, 0); t = Point(1, -a / b);\r\n    } else {\r\n      s = Point(0,\
    \ -c / b); t = Point(-c / a, 0);\r\n    }\r\n  }\r\n};\r\n\r\nstruct Circle {\r\
    \n  Point p; Real r;\r\n  explicit Circle(const Point& p = Point(0, 0), const\
    \ Real r = 0)\r\n      : p(p), r(r) {}\r\n};\r\n\r\nReal cross(const Point& a,\
    \ const Point& b) { return a.x * b.y - a.y * b.x; }\r\nReal dot(const Point& a,\
    \ const Point& b) { return a.x * b.x + a.y * b.y; }\r\n\r\nint ccw(const Point&\
    \ a, const Point& b, const Point& c) {\r\n  const Point ab = b - a, ac = c - a;\r\
    \n  const int sign = sgn(cross(ab, ac));\r\n  if (sign == 0) {\r\n    if (sgn(dot(ab,\
    \ ac)) == -1) return 2;\r\n    if (sgn(ac.norm() - ab.norm()) == 1) return -2;\r\
    \n  }\r\n  return sign;\r\n}\r\n\r\nReal get_angle(const Point& a, const Point&\
    \ b, const Point& c) {\r\n  Real ab = (a - b).arg(), bc = (c - b).arg();\r\n \
    \ if (ab > bc) std::swap(ab, bc);\r\n  return std::min(bc - ab, static_cast<Real>(PI\
    \ * 2 - (bc - ab)));\r\n}\r\n\r\nReal closest_pair(std::vector<Point> ps) {\r\n\
    \  const int n = ps.size();\r\n  assert(n >= 2);\r\n  std::sort(ps.begin(), ps.end());\r\
    \n  const std::function<Real(int, int)> f =\r\n      [&ps, &f](const int left,\
    \ const int right) -> Real {\r\n        const int mid = (left + right) >> 1;\r\
    \n        Real x_mid = ps[mid].x, d = std::numeric_limits<Real>::max();\r\n  \
    \      if (left + 1 < mid) d = std::min(d, f(left, mid));\r\n        if (mid +\
    \ 1 < right) d = std::min(d, f(mid, right));\r\n        std::inplace_merge(std::next(ps.begin(),\
    \ left),\r\n                           std::next(ps.begin(), mid),\r\n       \
    \                    std::next(ps.begin(), right),\r\n                       \
    \    [](const Point& a, const Point& b) -> bool {\r\n                        \
    \     return sgn(b.y - a.y) == 1;\r\n                           });\r\n      \
    \  std::vector<Point> tmp;\r\n        for (int i = left; i < right; ++i) {\r\n\
    \          if (sgn(std::abs(ps[i].x - x_mid) - d) == 1) continue;\r\n        \
    \  for (int j = static_cast<int>(tmp.size()) - 1; j >= 0; --j) {\r\n         \
    \   const Point v = ps[i] - tmp[j];\r\n            if (sgn(v.y - d) == 1) break;\r\
    \n            d = std::min(d, v.abs());\r\n          }\r\n          tmp.emplace_back(ps[i]);\r\
    \n        }\r\n        return d;\r\n      };\r\n  return f(0, n);\r\n}\r\n\r\n\
    Point projection(const Segment& a, const Point& b) {\r\n  return a.s + (a.t -\
    \ a.s) * dot(a.t - a.s, b - a.s) / (a.t - a.s).norm();\r\n}\r\nPoint reflection(const\
    \ Segment& a, const Point& b) {\r\n  return projection(a, b) * 2 - b;\r\n}\r\n\
    \r\nbool is_parallel(const Segment& a, const Segment& b) {\r\n  return sgn(cross(a.t\
    \ - a.s, b.t - b.s)) == 0;\r\n}\r\nbool is_orthogonal(const Segment& a, const\
    \ Segment& b) {\r\n  return sgn(dot(a.t - a.s, b.t - b.s)) == 0;\r\n}\r\n\r\n\
    Real distance(const Point&, const Point&);\r\nReal distance(const Segment&, const\
    \ Point&);\r\nReal distance(const Line&, const Point&);\r\nint common_tangent_num(const\
    \ Circle&, const Circle&);\r\nbool has_intersected(const Segment& a, const Point&\
    \ b) {\r\n  return ccw(a.s, a.t, b) == 0;\r\n}\r\nbool has_intersected(const Segment&\
    \ a, const Segment& b) {\r\n  return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) <=\
    \ 0 &&\r\n         ccw(b.s, b.t, a.s) * ccw(b.s, b.t, a.t) <= 0;\r\n}\r\nbool\
    \ has_intersected(const Line& a, const Point& b) {\r\n  const int c = ccw(a.s,\
    \ a.t, b);\r\n  return c != 1 && c != -1;\r\n}\r\nbool has_intersected(const Line&\
    \ a, const Segment& b) {\r\n  return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) !=\
    \ 1;\r\n}\r\nbool has_intersected(const Line& a, const Line& b) {\r\n  return\
    \ sgn(cross(a.t - a.s, b.t - b.s)) != 0 ||\r\n         sgn(cross(a.t - a.s, b.s\
    \ - a.s)) == 0;\r\n}\r\nbool has_intersected(const Circle& a, const Point& b)\
    \ {\r\n  return sgn(distance(a.p, b) - a.r) == 0;\r\n}\r\nbool has_intersected(const\
    \ Circle& a, const Segment& b) {\r\n  return sgn(a.r - distance(b, a.p)) != -1\
    \ &&\r\n         sgn(std::max(distance(a.p, b.s), distance(a.p, b.t)) - a.r) !=\
    \ -1;\r\n}\r\nbool has_intersected(const Circle& a, const Line& b) {\r\n  return\
    \ sgn(a.r - distance(b, a.p)) != -1;\r\n}\r\nbool has_intersected(const Circle&\
    \ a, const Circle& b) {\r\n  const int num = common_tangent_num(a, b);\r\n  return\
    \ 1 <= num && num <= 3;\r\n}\r\n\r\nPoint intersection(const Line& a, const Line&\
    \ b) {\r\n  assert(has_intersected(a, b) && !is_parallel(a, b));\r\n  const Point\
    \ va = a.t - a.s, vb = b.t - b.s;\r\n  return a.s + va * cross(vb, b.s - a.s)\
    \ / cross(vb, va);\r\n}\r\nPoint intersection(const Segment& a, const Segment&\
    \ b) {\r\n  assert(has_intersected(a, b));\r\n  if (is_parallel(a, b)) {\r\n \
    \   if (sgn(distance(a.s, b.s)) == 0) {\r\n      assert(sgn(dot(a.t - a.s, b.t\
    \ - a.s)) == -1);\r\n      return a.s;\r\n    } else if (sgn(distance(a.s, b.t))\
    \ == 0) {\r\n      assert(sgn(dot(a.t - a.s, b.s - a.s)) == -1);\r\n      return\
    \ a.s;\r\n    } else if (sgn(distance(a.t, b.s)) == 0) {\r\n      assert(sgn(dot(a.s\
    \ - a.t, b.t - a.t)) == -1);\r\n      return a.t;\r\n    } else if (sgn(distance(a.t,\
    \ b.t)) == 0) {\r\n      assert(sgn(dot(a.s - a.t, b.s - a.t)) == -1);\r\n   \
    \   return a.t;\r\n    } else {\r\n      assert(false);\r\n    }\r\n  } else {\r\
    \n    return intersection(Line(a.s, a.t), Line(b.s, b.t));\r\n  }\r\n}\r\nPoint\
    \ intersection(const Line& a, const Segment& b) {\r\n  assert(has_intersected(a,\
    \ b));\r\n  return intersection(a, Line(b.s, b.t));\r\n}\r\nstd::vector<Point>\
    \ intersection(const Circle& a, const Line& b) {\r\n  const Point pro = projection(b,\
    \ a.p);\r\n  const Real nor = (a.p - pro).norm();\r\n  const int sign = sgn(a.r\
    \ - std::sqrt(nor));\r\n  if (sign == -1) return {};\r\n  if (sign == 0) return\
    \ {pro};\r\n  const Point tmp = (b.t - b.s).unit_vector() * std::sqrt(a.r * a.r\
    \ - nor);\r\n  return {pro + tmp, pro - tmp};\r\n}\r\nstd::vector<Point> intersection(const\
    \ Circle& a, const Segment& b) {\r\n  if (!has_intersected(a, b)) return {};\r\
    \n  const std::vector<Point> res = intersection(a, Line(b.s, b.t));\r\n  if (sgn(distance(a.p,\
    \ b.s) - a.r) != -1 &&\r\n      sgn(distance(a.p, b.t) - a.r) != -1) {\r\n   \
    \ return res;\r\n  }\r\n  return {res[sgn(dot(res[0] - b.s, res[0] - b.t)) ==\
    \ 1 ? 1 : 0]};\r\n}\r\nstd::vector<Point> intersection(const Circle& a, const\
    \ Circle& b) {\r\n  const int num = common_tangent_num(a, b);\r\n  if (num ==\
    \ 0 || num == 4) return {};\r\n  const Real alpha = (b.p - a.p).arg();\r\n  if\
    \ (num == 1 || num == 3) {\r\n    return {Point(a.p.x + a.r * std::cos(alpha),\r\
    \n                  a.p.y + a.r * std::sin(alpha))};\r\n  }\r\n  const Real dist\
    \ = (b.p - a.p).norm();\r\n  const Real beta =\r\n      std::acos((dist + a.r\
    \ * a.r - b.r * b.r) / (2 * std::sqrt(dist) * a.r));\r\n  return {\r\n      a.p\
    \ + Point(a.r * std::cos(alpha + beta), a.r * std::sin(alpha + beta)),\r\n   \
    \   a.p + Point(a.r * std::cos(alpha - beta), a.r * std::sin(alpha - beta))};\r\
    \n}\r\n\r\nReal distance(const Point& a, const Point& b) { return (b - a).abs();\
    \ }\r\nReal distance(const Segment& a, const Point& b) {\r\n  const Point foot\
    \ = projection(a, b);\r\n  return has_intersected(a, foot) ?\r\n         distance(foot,\
    \ b) : std::min(distance(a.s, b), distance(a.t, b));\r\n}\r\nReal distance(const\
    \ Segment& a, const Segment& b) {\r\n  return has_intersected(a, b) ? 0 :\r\n\
    \         std::min({distance(a, b.s), distance(a, b.t),\r\n                  \
    \ distance(b, a.s), distance(b, a.t)});\r\n}\r\nReal distance(const Line& a, const\
    \ Point& b) {\r\n  return distance(projection(a, b), b);\r\n}\r\nReal distance(const\
    \ Line& a, const Segment& b) {\r\n  return has_intersected(a, b) ?\r\n       \
    \  0 : std::min(distance(a, b.s), distance(a, b.t));\r\n}\r\nReal distance(const\
    \ Line& a, const Line& b) {\r\n  return has_intersected(a, b) ? 0 : distance(a,\
    \ b.s);\r\n}\r\n\r\nstd::vector<Point> tangency(const Circle& a, const Point&\
    \ b) {\r\n  const Real dist = distance(a.p, b);\r\n  const int sign = sgn(dist\
    \ - a.r);\r\n  if (sign == -1) return {};\r\n  if (sign == 0) return {b};\r\n\
    \  const Real alpha = (b - a.p).arg(), beta = std::acos(a.r / dist);\r\n  return\
    \ {\r\n      a.p + Point(a.r * std::cos(alpha + beta), a.r * std::sin(alpha +\
    \ beta)),\r\n      a.p + Point(a.r * std::cos(alpha - beta), a.r * std::sin(alpha\
    \ - beta))};\r\n}\r\nint common_tangent_num(const Circle& a, const Circle& b)\
    \ {\r\n  const Real dist = distance(a.p, b.p);\r\n  int sign = sgn(a.r + b.r -\
    \ dist);\r\n  if (sign == -1) return 4;\r\n  if (sign == 0) return 3;\r\n  sign\
    \ = sgn((sgn(a.r - b.r) == -1 ? b.r - a.r : a.r - b.r) - dist);\r\n  if (sign\
    \ == -1) return 2;\r\n  if (sign == 0) return 1;\r\n  return 0;\r\n}\r\nstd::vector<Line>\
    \ common_tangent(const Circle& a, const Circle& b) {\r\n  std::vector<Line> tangents;\r\
    \n  const Real dist = distance(a.p, b.p), argument = (b.p - a.p).arg();\r\n  int\
    \ sign = sgn(a.r + b.r - dist);\r\n  if (sign == -1) {\r\n    const Real ac =\
    \ std::acos((a.r + b.r) / dist);\r\n    Real alpha = argument + ac, cs = std::cos(alpha),\
    \ sn = std::sin(alpha);\r\n    tangents.emplace_back(a.p + Point(a.r * cs, a.r\
    \ * sn),\r\n                          b.p + Point(-b.r * cs, -b.r * sn));\r\n\
    \    alpha = argument - ac; cs = std::cos(alpha); sn = std::sin(alpha);\r\n  \
    \  tangents.emplace_back(a.p + Point(a.r * cs, a.r * sn),\r\n                \
    \          b.p + Point(-b.r * cs, -b.r * sn));\r\n  } else if (sign == 0) {\r\n\
    \    const Point s =\r\n        a.p + Point(a.r * std::cos(argument), a.r * std::sin(argument));\r\
    \n    tangents.emplace_back(s, s + (b.p - a.p).normal_unit_vector().first);\r\n\
    \  }\r\n  if (sgn(b.r - a.r) == -1) {\r\n    sign = sgn(a.r - b.r - dist);\r\n\
    \    if (sign == -1) {\r\n      const Real at = std::acos((a.r - b.r) / dist);\r\
    \n      Real alpha = argument + at, cs = std::cos(alpha), sn = std::sin(alpha);\r\
    \n      tangents.emplace_back(a.p + Point(a.r * cs, a.r * sn),\r\n           \
    \                 b.p + Point(b.r * cs, b.r * sn));\r\n      alpha = argument\
    \ - at; cs = std::cos(alpha); sn = std::sin(alpha);\r\n      tangents.emplace_back(a.p\
    \ + Point(a.r * cs, a.r * sn),\r\n                            b.p + Point(b.r\
    \ * cs, b.r * sn));\r\n    } else if (sign == 0) {\r\n      const Point s =\r\n\
    \          a.p + Point(a.r * std::cos(argument), a.r * std::sin(argument));\r\n\
    \      tangents.emplace_back(s, s + (b.p - a.p).normal_unit_vector().first);\r\
    \n    }\r\n  } else {\r\n    sign = sgn(b.r - a.r - dist);\r\n    if (sign ==\
    \ -1) {\r\n      const Real at = std::acos((b.r - a.r) / dist);\r\n      Real\
    \ alpha = argument - at, cs = std::cos(alpha), sn = std::sin(alpha);\r\n     \
    \ tangents.emplace_back(a.p + Point(-a.r * cs, -a.r * sn),\r\n               \
    \             b.p + Point(-b.r * cs, -b.r * sn));\r\n      alpha = argument +\
    \ at; cs = std::cos(alpha); sn = std::sin(alpha);\r\n      tangents.emplace_back(a.p\
    \ + Point(-a.r * cs, -a.r * sn),\r\n                            b.p + Point(-b.r\
    \ * cs, -b.r * sn));\r\n    } else if (sign == 0) {\r\n      const Point s =\r\
    \n          b.p + Point(-b.r * std::cos(argument), -b.r * std::sin(argument));\r\
    \n      tangents.emplace_back(s, s + (a.p - b.p).normal_unit_vector().first);\r\
    \n    }\r\n  }\r\n  return tangents;\r\n}\r\n\r\nReal intersection_area(const\
    \ Circle& a, const Circle& b) {\r\n  const Real nor = (b.p - a.p).norm(), dist\
    \ = std::sqrt(nor);\r\n  if (sgn(a.r + b.r - dist) != 1) return 0;\r\n  if (sgn(std::abs(a.r\
    \ - b.r) - dist) != -1) {\r\n    return std::min(a.r, b.r) * std::min(a.r, b.r)\
    \ * PI;\r\n  }\r\n  const Real alpha =\r\n      std::acos((nor + a.r * a.r - b.r\
    \ * b.r) / (2 * dist * a.r));\r\n  const Real beta = std::acos((nor + b.r * b.r\
    \ - a.r * a.r) / (2 * dist * b.r));\r\n  return (alpha - std::sin(alpha + alpha)\
    \ * 0.5) * a.r * a.r +\r\n         (beta - std::sin(beta + beta) * 0.5) * b.r\
    \ * b.r;\r\n}\r\n\r\nusing Polygon = std::vector<Point>;\r\n\r\nReal area(Polygon\
    \ a) {\r\n  const int n = a.size();\r\n  a.resize(n + 1);\r\n  a.back() = a.front();\r\
    \n  Real res = 0;\r\n  for (int i = 0; i < n; ++i) {\r\n    res += cross(a[i],\
    \ a[i + 1]);\r\n  }\r\n  return res * 0.5;\r\n}\r\n\r\nPoint centroid(Polygon\
    \ a) {\r\n  const int n = a.size();\r\n  a.resize(n + 1);\r\n  a.back() = a.front();\r\
    \n  Point res(0, 0);\r\n  Real den = 0;\r\n  for (int i = 0; i < n; ++i) {\r\n\
    \    const Real cro = cross(a[i], a[i + 1]);\r\n    res += (a[i] + a[i + 1]) /\
    \ 3 * cro;\r\n    den += cro;\r\n  }\r\n  return res / den;\r\n}\r\n\r\nint contains(Polygon\
    \ a, const Point &b) {\r\n  const int n = a.size();\r\n  a.resize(n + 1);\r\n\
    \  a.back() = a.front();\r\n  bool is_in = false;\r\n  for (int i = 0; i < n;\
    \ ++i) {\r\n    Point p = a[i] - b, q = a[i + 1] - b;\r\n    if (sgn(q.y - p.y)\
    \ == -1) std::swap(p, q);\r\n    const int sign = sgn(cross(p, q));\r\n    if\
    \ (sign == 1 && sgn(p.y) != 1 && sgn(q.y) == 1) is_in = !is_in;\r\n    if (sign\
    \ == 0 && sgn(dot(p, q)) != 1) return 1;\r\n  }\r\n  return is_in ? 2 : 0;\r\n\
    }\r\n\r\nbool is_convex(Polygon a) {\r\n  const int n = a.size();\r\n  a.resize(n\
    \ + 2);\r\n  a[n] = a[0];\r\n  a[n + 1] = a[1];\r\n  for (int i = 1; i <= n; ++i)\
    \ {\r\n    if (ccw(a[i - 1], a[i], a[i + 1]) == -1) return false;\r\n  }\r\n \
    \ return true;\r\n}\r\n\r\nPolygon monotone_chain(std::vector<Point> ps, const\
    \ bool is_tight = true) {\r\n  const int n = ps.size();\r\n  std::sort(ps.begin(),\
    \ ps.end());\r\n  Polygon convex_hull(n << 1);\r\n  int idx = 0;\r\n  for (int\
    \ i = 0; i < n; convex_hull[idx++] = ps[i++]) {\r\n    while (idx >= 2 &&\r\n\
    \           sgn(cross(convex_hull[idx - 1] - convex_hull[idx - 2],\r\n       \
    \              ps[i] - convex_hull[idx - 1])) < is_tight) {\r\n      --idx;\r\n\
    \    }\r\n  }\r\n  for (int i = n - 2, border = idx + 1; i >= 0; convex_hull[idx++]\
    \ = ps[i--]) {\r\n    while (idx >= border &&\r\n           sgn(cross(convex_hull[idx\
    \ - 1] - convex_hull[idx - 2],\r\n                     ps[i] - convex_hull[idx\
    \ - 1])) < is_tight) {\r\n      --idx;\r\n    }\r\n  }\r\n  convex_hull.resize(idx\
    \ - 1);\r\n  return convex_hull;\r\n}\r\n\r\nPolygon cut_convex(Polygon a, const\
    \ Line& b) {\r\n  const int n = a.size();\r\n  a.resize(n + 1);\r\n  a.back()\
    \ = a.front();\r\n  Polygon res;\r\n  for (int i = 0; i < n; ++i) {\r\n    const\
    \ int c = ccw(b.s, b.t, a[i]);\r\n    if (c != -1) res.emplace_back(a[i]);\r\n\
    \    if (c * ccw(b.s, b.t, a[i + 1]) == -1) {\r\n      res.emplace_back(intersection(Line(a[i],\
    \ a[i + 1]), b));\r\n    }\r\n  }\r\n  return res.size() < 3 ? Polygon() : res;\r\
    \n}\r\n\r\nstd::pair<Point, Point> rotating_calipers(Polygon a) {\r\n  const int\
    \ n = a.size();\r\n  if (n <= 2) {\r\n    assert(n == 2);\r\n    return {a[0],\
    \ a[1]};\r\n  }\r\n  a.resize(n + 1);\r\n  a.back() = a.front();\r\n  int high\
    \ = 0, low = 0;\r\n  for (int i = 1; i < n; ++i) {\r\n    if (a[i].y > a[high].y)\
    \ high = i;\r\n    if (a[i].y < a[low].y) low = i;\r\n  }\r\n  Real max_norm =\
    \ (a[high] - a[low]).norm();\r\n  int i = high, j = low, argmax_i = i, argmax_j\
    \ = j;\r\n  do {\r\n    int* i_or_j = &(sgn(cross(a[i + 1] - a[i], a[j + 1] -\
    \ a[j])) != -1 ? j : i);\r\n    if (++(*i_or_j) == n) *i_or_j = 0;\r\n    const\
    \ Real tmp = (a[j] - a[i]).norm();\r\n    if (sgn(tmp - max_norm) == 1) {\r\n\
    \      max_norm = tmp;\r\n      argmax_i = i; argmax_j = j;\r\n    }\r\n  } while\
    \ (i != high || j != low);\r\n  return {a[argmax_i], a[argmax_j]};\r\n}\r\n\r\n\
    }  // namespace geometry\r\n\r\n// namespace geometry {\r\n\r\n// using Integer\
    \ = long long;\r\n\r\n// int sgn(const Integer x) {\r\n//   return x > 0 ? 1 :\
    \ (x < 0 ? -1 : 0);\r\n// }\r\n\r\n// struct Point {\r\n//   Integer x, y;\r\n\
    //   explicit Point(const Integer x = 0, const Integer y = 0) : x(x), y(y) {}\r\
    \n//   Integer norm() const { return x * x + y * y; }\r\n//   Point& operator+=(const\
    \ Point& p) {\r\n//     x += p.x; y += p.y;\r\n//     return *this;\r\n//   }\r\
    \n//   Point& operator-=(const Point& p) {\r\n//     x -= p.x; y -= p.y;\r\n//\
    \     return *this;\r\n//   }\r\n//   Point& operator*=(const Integer k) {\r\n\
    //     x *= k; y *= k;\r\n//     return *this;\r\n//   }\r\n//   Point& operator/=(const\
    \ Integer k) {\r\n//     x /= k; y /= k;\r\n//     return *this;\r\n//   }\r\n\
    //   bool operator<(const Point& p) const {\r\n//     const int x_sgn = sgn(p.x\
    \ - x);\r\n//     return x_sgn != 0 ? x_sgn == 1 : sgn(p.y - y) == 1;\r\n//  \
    \ }\r\n//   bool operator<=(const Point& p) const { return !(p < *this); }\r\n\
    //   bool operator>(const Point& p) const { return p < *this; }\r\n//   bool operator>=(const\
    \ Point& p) const { return !(*this < p); }\r\n//   Point operator+() const { return\
    \ *this; }\r\n//   Point operator-() const { return Point(-x, -y); }\r\n//   Point\
    \ operator+(const Point& p) const { return Point(*this) += p; }\r\n//   Point\
    \ operator-(const Point& p) const { return Point(*this) -= p; }\r\n//   Point\
    \ operator*(const Integer k) const { return Point(*this) *= k; }\r\n//   Point\
    \ operator/(const Integer k) const { return Point(*this) /= k; }\r\n//   friend\
    \ std::ostream& operator<<(std::ostream& os, const Point& p) {\r\n//     return\
    \ os << '(' << p.x << \", \" << p.y << ')';\r\n//   }\r\n//   friend std::istream&\
    \ operator>>(std::istream& is, Point& p) {\r\n//     Integer x, y; is >> x >>\
    \ y;\r\n//     p = Point(x, y);\r\n//     return is;\r\n//   }\r\n// };\r\n\r\n\
    // struct Segment {\r\n//   Point s, t;\r\n//   explicit Segment(const Point&\
    \ s = Point(0, 0), const Point& t = Point(0, 0))\r\n//       : s(s), t(t) {}\r\
    \n// };\r\n// struct Line : Segment {\r\n//   using Segment::Segment;\r\n// };\r\
    \n\r\n// struct Circle {\r\n//   Point p; Integer r;\r\n//   explicit Circle(const\
    \ Point& p = Point(0, 0), const Integer r = 0)\r\n//       : p(p), r(r) {}\r\n\
    // };\r\n\r\n// Integer cross(const Point& a, const Point& b) { return a.x * b.y\
    \ - a.y * b.x; }\r\n// Integer dot(const Point& a, const Point& b) { return a.x\
    \ * b.x + a.y * b.y; }\r\n\r\n// int ccw(const Point& a, const Point& b, const\
    \ Point& c) {\r\n//   const Point ab = b - a, ac = c - a;\r\n//   const int sign\
    \ = sgn(cross(ab, ac));\r\n//   if (sign == 0) {\r\n//     if (sgn(dot(ab, ac))\
    \ == -1) return 2;\r\n//     if (sgn(ac.norm() - ab.norm()) == 1) return -2;\r\
    \n//   }\r\n//   return sign;\r\n// }\r\n\r\n// Integer closest_pair(std::vector<Point>\
    \ ps) {\r\n//   const int n = ps.size();\r\n//   assert(n >= 2);\r\n//   std::sort(ps.begin(),\
    \ ps.end());\r\n//   const std::function<Integer(int, int)> f =\r\n//       [&ps,\
    \ &f](const int left, const int right) -> Integer {\r\n//         const int mid\
    \ = (left + right) >> 1;\r\n//         Integer x_mid = ps[mid].x, d = std::numeric_limits<Integer>::max();\r\
    \n//         if (left + 1 < mid) d = std::min(d, f(left, mid));\r\n//        \
    \ if (mid + 1 < right) d = std::min(d, f(mid, right));\r\n//         std::inplace_merge(std::next(ps.begin(),\
    \ left),\r\n//                            std::next(ps.begin(), mid),\r\n//  \
    \                          std::next(ps.begin(), right),\r\n//               \
    \             [](const Point& a, const Point& b) -> bool {\r\n//             \
    \                 return sgn(b.y - a.y) == 1;\r\n//                          \
    \  });\r\n//         std::vector<Point> tmp;\r\n//         for (int i = left;\
    \ i < right; ++i) {\r\n//           if (sgn((ps[i].x - x_mid) * (ps[i].x - x_mid)\
    \ - d) == 1) continue;\r\n//           for (int j = static_cast<int>(tmp.size())\
    \ - 1; j >= 0; --j) {\r\n//             const Point v = ps[i] - tmp[j];\r\n//\
    \             if (sgn(v.y * v.y - d) == 1) break;\r\n//             d = std::min(d,\
    \ v.norm());\r\n//           }\r\n//           tmp.emplace_back(ps[i]);\r\n//\
    \         }\r\n//         return d;\r\n//       };\r\n//   return f(0, n);\r\n\
    // }\r\n\r\n// bool is_parallel(const Segment& a, const Segment& b) {\r\n//  \
    \ return sgn(cross(a.t - a.s, b.t - b.s)) == 0;\r\n// }\r\n// bool is_orthogonal(const\
    \ Segment& a, const Segment& b) {\r\n//   return sgn(dot(a.t - a.s, b.t - b.s))\
    \ == 0;\r\n// }\r\n\r\n// int common_tangent_num(const Circle&, const Circle&);\r\
    \n// bool has_intersected(const Segment& a, const Point& b) {\r\n//   return ccw(a.s,\
    \ a.t, b) == 0;\r\n// }\r\n// bool has_intersected(const Segment& a, const Segment&\
    \ b) {\r\n//   return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) <= 0 &&\r\n//  \
    \        ccw(b.s, b.t, a.s) * ccw(b.s, b.t, a.t) <= 0;\r\n// }\r\n// bool has_intersected(const\
    \ Line& a, const Point& b) {\r\n//   const int c = ccw(a.s, a.t, b);\r\n//   return\
    \ c != 1 && c != -1;\r\n// }\r\n// bool has_intersected(const Line& a, const Segment&\
    \ b) {\r\n//   return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) != 1;\r\n// }\r\n\
    // bool has_intersected(const Line& a, const Line& b) {\r\n//   return sgn(cross(a.t\
    \ - a.s, b.t - b.s)) != 0 ||\r\n//          sgn(cross(a.t - a.s, b.s - a.s)) ==\
    \ 0;\r\n// }\r\n// bool has_intersected(const Circle& a, const Point& b) {\r\n\
    //   return (a.p - b).norm() == a.r * a.r;\r\n// }\r\n// bool has_intersected(const\
    \ Circle& a, const Circle& b) {\r\n//   const int num = common_tangent_num(a,\
    \ b);\r\n//   return 1 <= num && num <= 3;\r\n// }\r\n\r\n// int common_tangent_num(const\
    \ Circle& a, const Circle& b) {\r\n//   const Integer dist = (a.p - b.p).norm();\r\
    \n//   int sign = sgn((a.r + b.r) * (a.r + b.r) - dist);\r\n//   if (sign == -1)\
    \ return 4;\r\n//   if (sign == 0) return 3;\r\n//   sign = sgn((b.r - a.r) *\
    \ (b.r - a.r) - dist);\r\n//   if (sign == -1) return 2;\r\n//   if (sign == 0)\
    \ return 1;\r\n//   return 0;\r\n// }\r\n\r\n// using Polygon = std::vector<Point>;\r\
    \n\r\n// Integer area(Polygon a) {\r\n//   const int n = a.size();\r\n//   a.resize(n\
    \ + 1);\r\n//   a.back() = a.front();\r\n//   Integer res = 0;\r\n//   for (int\
    \ i = 0; i < n; ++i) {\r\n//     res += cross(a[i], a[i + 1]);\r\n//   }\r\n//\
    \   // return res / 2;\r\n//   return res;\r\n// }\r\n\r\n// int contains(Polygon\
    \ a, const Point &b) {\r\n//   const int n = a.size();\r\n//   a.resize(n + 1);\r\
    \n//   a.back() = a.front();\r\n//   bool is_in = false;\r\n//   for (int i =\
    \ 0; i < n; ++i) {\r\n//     Point p = a[i] - b, q = a[i + 1] - b;\r\n//     if\
    \ (sgn(q.y - p.y) == -1) std::swap(p, q);\r\n//     const int sign = sgn(cross(p,\
    \ q));\r\n//     if (sign == 1 && sgn(p.y) != 1 && sgn(q.y) == 1) is_in = !is_in;\r\
    \n//     if (sign == 0 && sgn(dot(p, q)) != 1) return 1;\r\n//   }\r\n//   return\
    \ is_in ? 2 : 0;\r\n// }\r\n\r\n// bool is_convex(Polygon a) {\r\n//   const int\
    \ n = a.size();\r\n//   a.resize(n + 2);\r\n//   a[n] = a[0];\r\n//   a[n + 1]\
    \ = a[1];\r\n//   for (int i = 1; i <= n; ++i) {\r\n//     if (ccw(a[i - 1], a[i],\
    \ a[i + 1]) == -1) return false;\r\n//   }\r\n//   return true;\r\n// }\r\n\r\n\
    // Polygon monotone_chain(std::vector<Point> ps, const bool is_tight = true) {\r\
    \n//   const int n = ps.size();\r\n//   std::sort(ps.begin(), ps.end());\r\n//\
    \   Polygon convex_hull(n << 1);\r\n//   int idx = 0;\r\n//   for (int i = 0;\
    \ i < n; convex_hull[idx++] = ps[i++]) {\r\n//     while (idx >= 2 &&\r\n//  \
    \          sgn(cross(convex_hull[idx - 1] - convex_hull[idx - 2],\r\n//      \
    \                ps[i] - convex_hull[idx - 1])) < is_tight) {\r\n//       --idx;\r\
    \n//     }\r\n//   }\r\n//   for (int i = n - 2, border = idx + 1; i >= 0; convex_hull[idx++]\
    \ = ps[i--]) {\r\n//     while (idx >= border &&\r\n//            sgn(cross(convex_hull[idx\
    \ - 1] - convex_hull[idx - 2],\r\n//                      ps[i] - convex_hull[idx\
    \ - 1])) < is_tight) {\r\n//       --idx;\r\n//     }\r\n//   }\r\n//   convex_hull.resize(idx\
    \ - 1);\r\n//   return convex_hull;\r\n// }\r\n\r\n// std::pair<Point, Point>\
    \ rotating_calipers(Polygon a) {\r\n//   const int n = a.size();\r\n//   if (n\
    \ <= 2) {\r\n//     assert(n == 2);\r\n//     return {a[0], a[1]};\r\n//   }\r\
    \n//   a.resize(n + 1);\r\n//   a.back() = a.front();\r\n//   int high = 0, low\
    \ = 0;\r\n//   for (int i = 1; i < n; ++i) {\r\n//     if (a[i].y > a[high].y)\
    \ high = i;\r\n//     if (a[i].y < a[low].y) low = i;\r\n//   }\r\n//   Integer\
    \ max_norm = (a[high] - a[low]).norm();\r\n//   int i = high, j = low, argmax_i\
    \ = i, argmax_j = j;\r\n//   do {\r\n//     int* i_or_j = &(sgn(cross(a[i + 1]\
    \ - a[i], a[j + 1] - a[j])) != -1 ? j : i);\r\n//     if (++(*i_or_j) == n) *i_or_j\
    \ = 0;\r\n//     const Integer tmp = (a[j] - a[i]).norm();\r\n//     if (sgn(tmp\
    \ - max_norm) == 1) {\r\n//       max_norm = tmp;\r\n//       argmax_i = i; argmax_j\
    \ = j;\r\n//     }\r\n//   } while (i != high || j != low);\r\n//   return {a[argmax_i],\
    \ a[argmax_j]};\r\n// }\r\n\r\n// }  // namespace geometry\r\n"
  dependsOn: []
  isVerificationFile: false
  path: geometry/geometry.hpp
  requiredBy:
  - geometry/smallest_enclosing_circle.hpp
  timestamp: '2022-03-25 02:44:38+09:00'
  verificationStatus: LIBRARY_ALL_AC
  verifiedWith:
  - test/math/quadratic_equation.test.cpp
  - test/geometry/geometry.08.test.cpp
  - test/geometry/geometry.09.test.cpp
  - test/geometry/geometry.01.test.cpp
  - test/geometry/geometry.06.test.cpp
  - test/geometry/geometry.19.test.cpp
  - test/geometry/geometry.17.test.cpp
  - test/geometry/geometry.11.test.cpp
  - test/geometry/geometry.12.test.cpp
  - test/geometry/geometry.18.test.cpp
  - test/geometry/geometry.13.test.cpp
  - test/geometry/geometry.10.test.cpp
  - test/geometry/geometry.07.test.cpp
  - test/geometry/geometry.20.test.cpp
  - test/geometry/geometry.03.test.cpp
  - test/geometry/geometry.05.test.cpp
  - test/geometry/geometry.04.test.cpp
  - test/geometry/smallest_enclosing_circle.test.cpp
  - test/geometry/geometry.21.test.cpp
  - test/geometry/geometry.15.test.cpp
  - test/geometry/geometry.22.test.cpp
  - test/geometry/geometry.02.test.cpp
  - test/geometry/geometry.16.test.cpp
  - test/geometry/geometry.14.test.cpp
documentation_of: geometry/geometry.hpp
layout: document
title: "\u8A08\u7B97\u5E7E\u4F55\u5B66 (computational geometry)"
---


## 

|||
|:--:|:--:|
||$O(N\log{N})$|
||$O(N)$|
||$O(N)$|
||$O(N)$|
||$O(N)$|
|monotone chain|$O(N\log{N})$|
||$O(N)$|
| (rotating calipers)|$O(N)$|


## 

|||
|:--:|:--:|
|`sgn(x)`|$\begin{cases} 1 & (x > \varepsilon) \\\\ -1 & (x < -\varepsilon) \\\\ 0 & (\text{otherwise}) \end{cases}$|
|`degree_to_radian(d)`|$\frac{\pi d}{180}\,\mathrm{rad}$|
|`radian_to_degree(r)`|$(\frac{180r}{\pi})^\circ$|

- 

||||
|:--:|:--:|:--:|
|`Point(x = 0, y = 0)`| $(x, y)$||
|`x`, `y`|$(x, y)$||
|`abs()`|$\lVert \boldsymbol{p} \rVert$||
|`arg()`|$\arg(x + iy)$|$[0, 2\pi)$|
|`norm()`|${\lVert \boldsymbol{p} \rVert}^2$||
|`rotate(angle)`| $\mathrm{angle}$  $(x^{\prime}, y^{\prime})$|$\begin{cases} x^{\prime} = x\cos(\mathrm{angle}) - y\sin(\mathrm{angle}) \\\\ y^{\prime} = x\sin(\mathrm{angle}) + y\cos(\mathrm{angle}) \end{cases}$|
|`unit_vector()`|||
|`normal_unit_vector()`||

- 

|||
|:--:|:--:|
|`Segment(s = (0, 0), t = (0, 0))`| $s$,  $t$ |
|`s`||
|`t`||

- 

||||
|:--:|:--:|:--:|
|`Line(s = (0, 0), t = (0, 0))`| $s$,  $t$ ||
|`Line(a, b, c)`|$ax + by + c = 0$ |`s`, `t` 2|
|`s`||
|`t`||

- 

|||
|:--:|:--:|
|`Circle(p = (0, 0), r = 0)`| $\mathrm{P}$,  $r$ |
|`p`||
|`r`||

- 



- 

||||
|:--:|:--:|:--:|
|`cross(a, b)`|$\boldsymbol{a} \times \boldsymbol{b}$||
|`dot(a, b)`|$\boldsymbol{a} \cdot \boldsymbol{b}$||
|`ccw(a, b, c)`|$\begin{cases} -2 & (\mathrm{A}, \mathrm{B}, \mathrm{C} \text{ }) \\\\ -1 & (\mathrm{AB} \text{  } \mathrm{C} \text{ }) \\\\ 0 & (\mathrm{A}, \mathrm{C}, \mathrm{B} \text{ }) \\\\ 1 & (\mathrm{AB} \text{  } \mathrm{C} \text{ }) \\\\ 2 & (\mathrm{C}, \mathrm{A}, \mathrm{B} \text{ }) \end{cases}$||
|`get_angle(a, b, c)`|$\angle{\mathrm{ABC}}$||
|`closest_pair(ps)`| $\mathrm{ps}$ ||
|`projection(a, b)`| $\mathrm{A}$  $\mathrm{B}$ ||
|`reflection(a, b)`| $\mathrm{A}$  $\mathrm{B}$ ||
|`is_parallel(a, b)`|$\boldsymbol{a} \parallel \boldsymbol{b}$|$\Leftrightarrow \boldsymbol{a} \times \boldsymbol{b} = 0$|
|`is_orthogonal(a, b)`|$\boldsymbol{a} \perp \boldsymbol{b}$|$\Leftrightarrow \boldsymbol{a} \cdot \boldsymbol{b} = 0$|
|`has_intersected(a, b)`| $\mathrm{A}$  $\mathrm{B}$ ||
|`intersection(a, b)`| $\mathrm{A}$  $\mathrm{B}$ ||
|`distance(a, b)`| $\mathrm{A}$  $\mathrm{B}$ ||
|`tangency(a, b)`| $\mathrm{B}$  $\mathrm{A}$ | $(x - a)^2 + (y - b)^2 = r^2$  $(x_0, y_0)$  $(x_0 - a)(x - a) + (y_0 - b)(y - b) = r^2$ |
|`common_tangent_num(a, b)`| $\mathrm{A}$  $\mathrm{B}$ ||
|`common_tangent(a, b)`| $\mathrm{A}$  $\mathrm{B}$ |2`s`  $\mathrm{A}$ `t`  $\mathrm{B}$ |
|`intersection_area(a, b)`| $\mathrm{A}$  $\mathrm{B}$ ||
|`area(a)`| $\mathrm{A}$ ||
|`centroid(a)`| $\mathrm{A}$ ||
|`contains(a, b)`| $\mathrm{B}$  $\mathrm{A}$ ||
|`is_convex(a)`| $\mathrm{A}$ ||
|`monotone_chain(ps,  = true)`| $\mathrm{ps}$ | $w$  $O(\sqrt{w})$ |
|`cut_convex(a, b)`| $\mathrm{B}$  $\mathrm{A}$ ||
|`rotating_calipers(a)`| $\mathrm{A}$ ||


## 

- https://www.ioi-jp.org/camp/2017/2017-sp_camp-hide.pdf
- https://sen-comp.hatenablog.com/archive/category/%E3%80%8C%E5%9F%BA%E7%A4%8E%E7%9A%84%E8%A8%88%E7%AE%97%E5%B9%BE%E4%BD%95%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AE%E4%BD%9C%E3%82%8A%E6%96%B9%E3%80%8D
- http://www.deqnotes.net/acmicpc/2d_geometry/
- https://ei1333.github.io/luzhiled/snippets/geometry/template.html


-  \[2\]pp.324-3262012


- https://mathtrain.jp/ennosessen

2
- http://www.e-learning-jp.net/teach_math/mathA/text_1/6/11/001a.htm

2
- http://nutsu.com/blog/2007/102601_as_circletest6.html


- https://blog.goo.ne.jp/m4g/e/82eb68689c322dc43d52ce16b29a9a74

2
- https://drken1215.hatenablog.com/entry/2020/02/02/005800


- https://www.nttpc.co.jp/technology/number_algorithm.html


## ToDo

- https://github.com/spaghetti-source/algorithm/blob/master/geometry/_geom.cc
- 3
  - https://github.com/beet-aizu/library/tree/master/geometry/3D
  - https://lumakernel.github.io/ecasdqina/geometory/geometory3D
  - https://github.com/drken1215/algorithm/blob/master/Geometry/basic_elements_3D.cpp
  - https://github.com/primenumber/ProconLib/blob/master/Geometry/3DGeometry.cpp
  - 3
    - https://lumakernel.github.io/ecasdqina/geometory/ConvexHull3D
    - https://www.slideshare.net/abc3141/3-65377198
- 
  - https://codeforces.com/blog/entry/75929
  - https://judge.yosupo.jp/problem/convex_layers
  - https://atcoder.jp/contests/geocon2013/tasks/geocon2013_c
- 
  - https://github.com/ei1333/library/blob/master/geometry/template.cpp
  - https://ei1333.github.io/luzhiled/snippets/geometry/template.html
  - https://ei1333.github.io/algorithm/segment-arrangement.html
  - https://github.com/beet-aizu/library/blob/master/geometry/geometry.cpp
  - https://tubo28.me/compprog/algorithm/segment-arrangement/
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/segment_arrangement.cc
  - http://www.prefield.com/algorithm/geometry/segment_arrangement.html
  - https://github.com/primenumber/ProconLib/blob/master/Geometry/Arrangement.cpp
  - https://onlinejudge.u-aizu.ac.jp/problems/1033
- 
  - http://www.prefield.com/algorithm/geometry/walk_arrangement.html
  - https://nya3.jp/libicpc/#%E5%B9%BE%E4%BD%95/%E3%81%9D%E3%81%AE%E4%BB%96/%E3%82%A2%E3%83%AC%E3%83%B3%E3%82%B8%E3%83%A1%E3%83%B3%E3%83%88
- 
  - https://github.com/ei1333/library/blob/master/geometry/template.cpp
  - https://ei1333.github.io/luzhiled/snippets/geometry/template.html
  - https://github.com/beet-aizu/library/blob/master/geometry/geometry.cpp
  - https://drken1215.hatenablog.com/entry/2020/02/02/091000
  - https://github.com/drken1215/algorithm/blob/master/Geometry/area_common_circle_polygon.cpp
  - http://kyopro.hateblo.jp/entry/2019/08/01/192232
  - https://topcoder-g-hatena-ne-jp.jag-icpc.org/not522/20130728/1374979041.html
  - https://twitter.com/not_522/status/1008671743584583682
- 
  - https://docs.google.com/presentation/d/119Ve9FB0qTzN01P4EKmia-atXMiPSsJGEDWotVZ6GDg
- 
  - https://sen-comp.hatenablog.com/entry/2020/03/14/183251#distanceBetweenPointAndRay%E7%82%B9%E3%81%A8%E5%8D%8A%E7%9B%B4%E7%B7%9A%E3%81%AE%E8%B7%9D%E9%9B%A2
- 
  - http://www.prefield.com/algorithm/geometry/convex_intersect.html
  - http://gihyo.jp/dev/serial/01/geometry/0009
- 
  - http://www.prefield.com/algorithm/geometry/convex_contains.html
- 
  - http://www.prefield.com/algorithm/geometry/convex_extreme.html
- monotone chain 
  - https://www.jaist.ac.jp/~uehara/course/2014/i481f/pdf/ppt-3.pdf
  - http://www-ikn.ist.hokudai.ac.jp/~k-sekine/slides/convexhull.pdf
  - http://www.thothchildren.com/chapter/5b268e086298160664e807e9
- 
  - https://github.com/beet-aizu/library/blob/master/geometry/geometry.cpp
  - https://github.com/drken1215/algorithm/blob/master/Geometry/convex_cut.cpp
- 
  - https://tjkendev.github.io/procon-library/python/geometry/convex_polygon_tangent.html
-  (circle of Apollonius)
  - https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%9D%E3%83%AD%E3%83%8B%E3%82%A6%E3%82%B9%E3%81%AE%E5%86%86
  - https://mathtrain.jp/apollonius
  - https://github.com/drken1215/algorithm/blob/master/Geometry/All.cpp
  - https://onlinejudge.u-aizu.ac.jp/problems/1039
- 3
  - http://www.prefield.com/algorithm/geometry/misc.html
-  (Pick's theorem)
  - https://ja.wikipedia.org/wiki/%E3%83%94%E3%83%83%E3%82%AF%E3%81%AE%E5%AE%9A%E7%90%86
- 
  - http://www.prefield.com/algorithm/geometry/merge_segments.html
  - https://github.com/ei1333/library/blob/master/geometry/template.cpp
  - https://ei1333.github.io/luzhiled/snippets/geometry/template.html
  - https://onlinejudge.u-aizu.ac.jp/problems/1033
-  (point location problem)
  - https://en.wikipedia.org/wiki/Point_location
  - http://www.orsj.or.jp/~wiki/wiki/index.php/%E7%82%B9%E4%BD%8D%E7%BD%AE%E6%B1%BA%E5%AE%9A
  - https://ikatakos.com/pot/programming_algorithm/geometry/planar_point_location
  - http://www-imai.is.s.u-tokyo.ac.jp/~tsuyoshi/tmp/compgeo-20040608.pdf
  - http://www.prefield.com/algorithm/geometry/point_location.html
- 
  - http://www.prefield.com/algorithm/geometry/stabbing_line.html
-  (ear decomposition)
  - https://en.wikipedia.org/wiki/Ear_decomposition
  - http://www.prefield.com/algorithm/geometry/triangulate.html
- 
  - http://www.prefield.com/algorithm/geometry/shrink_polygon.html
-  (delaunay diagram)
  - https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%AD%E3%83%8D%E3%83%BC%E5%9B%B3
  - https://www.slideshare.net/Kinokkory/ss-25736696
  - http://www.orsj.or.jp/~wiki/wiki/index.php/%E3%83%89%E3%83%AD%E3%83%8D%E3%83%BC%E5%9B%B3
  - http://www.thothchildren.com/chapter/5bded85141f88f267247fdc6
  - http://hadashia.hatenablog.com/entry/2018/10/11/194602
  - http://www.prefield.com/algorithm/geometry/delaunay.html
- kd  (k-d tree)
  - https://ja.wikipedia.org/wiki/Kd%E6%9C%A8
  - https://www.slideshare.net/okuraofvegetable/ss-65377588
  - https://trap.jp/post/1489/
  - https://twitter.com/noshi91/status/1395285823403167745
  - https://github.com/beet-aizu/library/blob/master/datastructure/kdtree.cpp
  - https://github.com/primenumber/ProconLib/blob/master/Structure/kdTree.cpp
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/kd_tree.cc
  - http://www.prefield.com/algorithm/geometry/kdtree.html
  - https://tjkendev.github.io/procon-library/cpp/range_query/kd-tree.html
  - https://atcoder.jp/contests/abc234/tasks/abc234_h
  - https://atcoder.jp/contests/abc234/submissions/28417490
  - randomized k-d tree
    - https://github.com/spaghetti-source/algorithm/blob/master/geometry/randomized_kd_tree.cc
    - https://www.slideshare.net/keisukeumezawa5/scalable-nearest-neighbor-algorithms-for-high-dimensional-data-71772599
- BK-tree
  - https://en.wikipedia.org/wiki/BK-tree
  - https://postd.cc/bk-tree/
  - https://postd.cc/symspell-vs-bk-tree-100x-faster-fuzzy-string-search-spell-checking/
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/bk_tree.cc
  - http://agtn.hatenablog.com/entry/2017/05/13/183310
- vantage-point tree (VP tree)
  - https://en.wikipedia.org/wiki/Vantage-point_tree
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/vantage_point_tree.cc
- rectilinear minimum spanning tree
  - https://en.wikipedia.org/wiki/Rectilinear_minimum_spanning_tree
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/rectilinear_mst.cc
- 
  - http://www.prefield.com/algorithm/geometry/dual_transformation.html
-  (dual graph)
  - https://en.wikipedia.org/wiki/Dual_graph
  - https://firiexp.github.io/library/library/geometry/dualgraph.cpp.html
  - https://github.com/primenumber/ProconLib/blob/master/Geometry/DualGraph.cpp
  - https://onlinejudge.u-aizu.ac.jp/problems/0273
- 
  - https://github.com/beet-aizu/library/blob/master/geometry/projectilemotion.cpp
- random ball cover
  - http://www.lcayton.com/rbc.pdf
  - http://jsatml.blogspot.com/2012/10/random-ball-cover.html
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/random_ball_cover.cc
- On Finding the Maxima of a Set of Vectors
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/coordinate_domination.cc
-  (taxicab geometry)
  - https://en.wikipedia.org/wiki/Taxicab_geometry
- 
  - https://gist.github.com/MiSawa/16d5f84cf66fd2913c82
-  /  / 


## Verified

- [`ccw(a, b, c)`](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_1_C/review/4325588/emthrm/C++14)
- $\angle{\mathrm{ABC}}$
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_5_A/review/4325777/emthrm/C++14)
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_1_A/review/4325794/emthrm/C++14)
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_1_B/review/4325814/emthrm/C++14)
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_A/review/4325838/emthrm/C++14)
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_A/review/4325838/emthrm/C++14)
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_D/review/4325929/emthrm/C++14)
- [2](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_B/review/4325860/emthrm/C++14)
- 
- 
- 2
- 
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/2276/review/4339412/emthrm/C++14)
- 
- 2
- [2](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_4_C/review/4326103/emthrm/C++14)
- [2](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_C/review/4325877/emthrm/C++14)
- 
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_D/review/4325892/emthrm/C++14)
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/2316/review/4345536/emthrm/C++14)
- [2](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_E/review/4325909/emthrm/C++14)
- [2](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_F/review/4325939/emthrm/C++14)
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_D/review/4325929/emthrm/C++14)
- [2](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_D/review/4325929/emthrm/C++14)
- 
- 
- 2
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_F/review/4325939/emthrm/C++14)
- [2](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_A/review/4325959/emthrm/C++14)
- [2](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_G/review/4325977/emthrm/C++14)
- [2](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_I/review/4967134/emthrm/C++17)
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_3_A/review/4326007/emthrm/C++14)
- 
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_3_C/review/4326013/emthrm/C++14)
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_3_B/review/4326091/emthrm/C++14)
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_4_A/review/4326095/emthrm/C++14)
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_4_C/review/4326103/emthrm/C++14)
- [](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_4_B/review/4326112/emthrm/C++14)
