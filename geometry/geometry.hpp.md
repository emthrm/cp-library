---
data:
  _extendedDependsOn: []
  _extendedRequiredBy:
  - icon: ':x:'
    path: geometry/smallest_enclosing_circle.hpp
    title: "\u6700\u5C0F\u5305\u542B\u5186 (smallest enclosing circle)"
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.01.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (ccw(a,\
      \ b, c))"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.02.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u6700\u8FD1\
      \u70B9\u5BFE)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.03.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u5C04\u5F71\
      )"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.04.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u93E1\u6620\
      )"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.05.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u5E73\u884C\
      \ / \u5782\u76F4)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.06.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u7DDA\
      \u5206\u306E\u4EA4\u5DEE\u5224\u5B9A)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.07.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u7DDA\u5206\
      \u3068\u5186\u306E\u4EA4\u5DEE\u5224\u5B9A)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.08.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u7DDA\
      \u5206\u306E\u4EA4\u70B9)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.09.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u76F4\u7DDA\
      \u3068\u5186\u306E\u4EA4\u70B9)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.10.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u7DDA\u5206\
      \u3068\u5186\u306E\u4EA4\u70B9)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.11.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u5186\
      \u306E\u4EA4\u70B9)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.12.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u7DDA\
      \u5206\u306E\u8DDD\u96E2)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.13.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u63A5\u70B9\
      )"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.14.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u5186\
      \u306E\u5171\u901A\u63A5\u7DDA\u306E\u672C\u6570)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.15.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u5186\
      \u306E\u5171\u901A\u63A5\u7DDA)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.16.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (2\u5186\
      \u306E\u5171\u901A\u90E8\u5206\u306E\u9762\u7A4D)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.17.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u591A\u89D2\
      \u5F62\u306E\u9762\u7A4D)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.18.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u591A\u89D2\
      \u5F62\u306E\u5185\u5916\u5224\u5B9A)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.19.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u51F8\u6027\
      \u5224\u5B9A)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.20.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u51F8\u5305\
      )"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.21.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u51F8\u591A\
      \u89D2\u5F62\u306E\u5207\u65AD)"
  - icon: ':heavy_check_mark:'
    path: test/geometry/geometry.22.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u8A08\u7B97\u5E7E\u4F55\u5B66 (\u51F8\u591A\
      \u89D2\u5F62\u306E\u76F4\u5F84)"
  - icon: ':x:'
    path: test/geometry/smallest_enclosing_circle.test.cpp
    title: "\u8A08\u7B97\u5E7E\u4F55\u5B66/\u6700\u5C0F\u5305\u542B\u5186"
  - icon: ':heavy_check_mark:'
    path: test/math/quadratic_equation.test.cpp
    title: "\u6570\u5B66/\u4E00\u5143\u4E8C\u6B21\u65B9\u7A0B\u5F0F"
  _isVerificationFailed: true
  _pathExtension: hpp
  _verificationStatusIcon: ':question:'
  attributes:
    links: []
  bundledCode: "#line 2 \"geometry/geometry.hpp\"\n#include <algorithm>\r\n#include\
    \ <cassert>\r\n#include <cmath>\r\n#include <functional>\r\n#include <iostream>\r\
    \n#include <limits>\r\n#include <utility>\r\n#include <vector>\r\n\r\nnamespace\
    \ geometry {\r\nusing Real = double;\r\nconstexpr long double PI = 3.14159265358979323846;\r\
    \n\r\nint sgn(Real x) {\r\n  static constexpr Real EPS = 1e-8;\r\n  return x >\
    \ EPS ? 1 : x < -EPS ? -1 : 0;\r\n}\r\n\r\nReal degree_to_radian(Real d) { return\
    \ d * PI / 180; }\r\nReal radian_to_degree(Real r) { return r * 180 / PI; }\r\n\
    \r\nstruct Point {\r\n  Real x, y;\r\n  Point(Real x = 0, Real y = 0) : x(x),\
    \ y(y) {}\r\n  Real abs() const { return std::sqrt(norm()); }\r\n  Real arg()\
    \ const { Real res = std::atan2(y, x); return res < 0 ? res + PI * 2 : res; }\r\
    \n  Real norm() const { return x * x + y * y; }\r\n  Point rotate(Real angle)\
    \ const { Real cs = std::cos(angle), sn = std::sin(angle); return Point(x * cs\
    \ - y * sn, x * sn + y * cs); }\r\n  Point unit_vector() const { Real a = abs();\
    \ return Point(x / a, y / a); }\r\n  std::pair<Point, Point> normal_unit_vector()\
    \ const { Point p = unit_vector(); return {Point(-p.y, p.x), Point(p.y, -p.x)};\
    \ }\r\n  Point &operator+=(const Point &p) { x += p.x; y += p.y; return *this;\
    \ }\r\n  Point &operator-=(const Point &p) { x -= p.x; y -= p.y; return *this;\
    \ }\r\n  Point &operator*=(Real k) { x *= k; y *= k; return *this; }\r\n  Point\
    \ &operator/=(Real k) { x /= k; y /= k; return *this; }\r\n  bool operator<(const\
    \ Point &p) const { int x_sgn = sgn(p.x - x); return x_sgn != 0 ? x_sgn == 1 :\
    \ sgn(p.y - y) == 1; }\r\n  bool operator<=(const Point &p) const { return !(p\
    \ < *this); }\r\n  bool operator>(const Point &p) const { return p < *this; }\r\
    \n  bool operator>=(const Point &p) const { return !(*this < p); }\r\n  Point\
    \ operator+() const { return *this; }\r\n  Point operator-() const { return Point(-x,\
    \ -y); }\r\n  Point operator+(const Point &p) const { return Point(*this) += p;\
    \ }\r\n  Point operator-(const Point &p) const { return Point(*this) -= p; }\r\
    \n  Point operator*(Real k) const { return Point(*this) *= k; }\r\n  Point operator/(Real\
    \ k) const { return Point(*this) /= k; }\r\n  friend std::ostream &operator<<(std::ostream\
    \ &os, const Point &p) { return os << '(' << p.x << \", \" << p.y << ')'; }\r\n\
    \  friend std::istream &operator>>(std::istream &is, Point &p) { Real x, y; is\
    \ >> x >> y; p = Point(x, y); return is; }\r\n};\r\n\r\nstruct Segment {\r\n \
    \ Point s, t;\r\n  Segment(const Point &s = {0, 0}, const Point &t = {0, 0}) :\
    \ s(s), t(t) {}\r\n};\r\nstruct Line : Segment {\r\n  using Segment::Segment;\r\
    \n  Line(Real a, Real b, Real c) {\r\n    if (sgn(a) == 0) {\r\n      s = Point(0,\
    \ -c / b); t = Point(1, s.y);\r\n    } else if (sgn(b) == 0) {\r\n      s = Point(-c\
    \ / a, 0); t = Point(s.x, 1);\r\n    } else if (sgn(c) == 0) {\r\n      s = Point(0,\
    \ 0); t = Point(1, -a / b);\r\n    } else {\r\n      s = Point(0, -c / b); t =\
    \ Point(-c / a, 0);\r\n    }\r\n  }\r\n};\r\n\r\nstruct Circle {\r\n  Point p;\
    \ Real r;\r\n  Circle(const Point &p = {0, 0}, Real r = 0) : p(p), r(r) {}\r\n\
    };\r\n\r\nReal cross(const Point &a, const Point &b) { return a.x * b.y - a.y\
    \ * b.x; }\r\nReal dot(const Point &a, const Point &b) { return a.x * b.x + a.y\
    \ * b.y; }\r\n\r\nint ccw(const Point &a, const Point &b, const Point &c) {\r\n\
    \  Point ab = b - a, ac = c - a;\r\n  int sign = sgn(cross(ab, ac));\r\n  if (sign\
    \ == 0) {\r\n    if (sgn(dot(ab, ac)) == -1) return 2;\r\n    if (sgn(ac.norm()\
    \ - ab.norm()) == 1) return -2;\r\n  }\r\n  return sign;\r\n}\r\n\r\nReal get_angle(const\
    \ Point &a, const Point &b, const Point &c) {\r\n  Real ba_arg = (a - b).arg(),\
    \ bc_arg = (c - b).arg();\r\n  if (ba_arg > bc_arg) std::swap(ba_arg, bc_arg);\r\
    \n  return std::min(bc_arg - ba_arg, static_cast<Real>(PI * 2 - (bc_arg - ba_arg)));\r\
    \n}\r\n\r\nReal closest_pair(std::vector<Point> ps) {\r\n  int n = ps.size();\r\
    \n  assert(n > 1);\r\n  std::sort(ps.begin(), ps.end());\r\n  std::function<Real(int,\
    \ int)> rec = [&ps, &rec](int left, int right) -> Real {\r\n    int mid = (left\
    \ + right) >> 1;\r\n    Real x_mid = ps[mid].x, d = std::numeric_limits<Real>::max();\r\
    \n    if (left + 1 < mid) {\r\n      Real tmp = rec(left, mid);\r\n      if (tmp\
    \ < d) d = tmp;\r\n    }\r\n    if (mid + 1 < right) {\r\n      Real tmp = rec(mid,\
    \ right);\r\n      if (tmp < d) d = tmp;\r\n    }\r\n    std::inplace_merge(ps.begin()\
    \ + left, ps.begin() + mid, ps.begin() + right, [&](const Point &a, const Point\
    \ &b) -> bool { return sgn(b.y - a.y) == 1; });\r\n    std::vector<Point> tmp;\r\
    \n    for (int i = left; i < right; ++i) {\r\n      if (sgn(std::abs(ps[i].x -\
    \ x_mid) - d) == 1) continue;\r\n      for (int j = static_cast<int>(tmp.size())\
    \ - 1; j >= 0; --j) {\r\n        Point now = ps[i] - tmp[j];\r\n        if (sgn(now.y\
    \ - d) == 1) break;\r\n        Real tmp = now.abs();\r\n        if (tmp < d) d\
    \ = tmp;\r\n      }\r\n      tmp.emplace_back(ps[i]);\r\n    }\r\n    return d;\r\
    \n  };\r\n  return rec(0, n);\r\n}\r\n\r\nPoint projection(const Segment &a, const\
    \ Point &b) { return a.s + (a.t - a.s) * dot(a.t - a.s, b - a.s) / (a.t - a.s).norm();\
    \ }\r\nPoint reflection(const Segment &a, const Point &b) { return projection(a,\
    \ b) * 2 - b; }\r\n\r\nbool is_parallel(const Segment &a, const Segment &b) {\
    \ return sgn(cross(a.t - a.s, b.t - b.s)) == 0; }\r\nbool is_orthogonal(const\
    \ Segment &a, const Segment &b) { return sgn(dot(a.t - a.s, b.t - b.s)) == 0;\
    \ }\r\n\r\nReal distance(const Point&, const Point&);\r\nReal distance(const Segment&,\
    \ const Point&);\r\nReal distance(const Line&, const Point&);\r\nint sizeof_common_tangent(const\
    \ Circle&, const Circle&);\r\nbool has_intersected(const Segment &a, const Point\
    \ &b) { return ccw(a.s, a.t, b) == 0; }\r\nbool has_intersected(const Segment\
    \ &a, const Segment &b) { return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) <= 0\
    \ && ccw(b.s, b.t, a.s) * ccw(b.s, b.t, a.t) <= 0; }\r\nbool has_intersected(const\
    \ Line &a, const Point &b) { int c = ccw(a.s, a.t, b); return c != 1 && c != -1;\
    \ }\r\nbool has_intersected(const Line &a, const Segment &b) { return ccw(a.s,\
    \ a.t, b.s) * ccw(a.s, a.t, b.t) != 1; }\r\nbool has_intersected(const Line &a,\
    \ const Line &b) { return sgn(cross(a.t - a.s, b.t - b.s)) != 0 || sgn(cross(a.t\
    \ - a.s, b.s - a.s)) == 0; }\r\nbool has_intersected(const Circle &a, const Point\
    \ &b) { return sgn(distance(a.p, b) - a.r) == 0; }\r\nbool has_intersected(const\
    \ Circle &a, const Segment &b) { return sgn(a.r - distance(b, a.p)) != -1 && sgn(std::max(distance(a.p,\
    \ b.s), distance(a.p, b.t)) - a.r) != -1; }\r\nbool has_intersected(const Circle\
    \ &a, const Line &b) { return sgn(a.r - distance(b, a.p)) != -1; }\r\nbool has_intersected(const\
    \ Circle &a, const Circle &b) { return sizeof_common_tangent(a, b) > 0; }\r\n\r\
    \nPoint intersection(const Line &a, const Line &b) {\r\n  assert(has_intersected(a,\
    \ b) && !is_parallel(a, b));\r\n  return a.s + (a.t - a.s) * cross(b.t - b.s,\
    \ b.s - a.s) / cross(b.t - b.s, a.t - a.s);\r\n}\r\nPoint intersection(const Segment\
    \ &a, const Segment &b) {\r\n  assert(has_intersected(a, b));\r\n  if (is_parallel(a,\
    \ b)) {\r\n    if (sgn(distance(a.s, b.s)) == 0) {\r\n      assert(sgn(dot(a.t\
    \ - a.s, b.t - a.s)) == -1);\r\n      return a.s;\r\n    } else if (sgn(distance(a.s,\
    \ b.t)) == 0) {\r\n      assert(sgn(dot(a.t - a.s, b.s - a.s)) == -1);\r\n   \
    \   return a.s;\r\n    } else if (sgn(distance(a.t, b.s)) == 0) {\r\n      assert(sgn(dot(a.s\
    \ - a.t, b.t - a.t)) == -1);\r\n      return a.t;\r\n    } else if (sgn(distance(a.t,\
    \ b.t)) == 0) {\r\n      assert(sgn(dot(a.s - a.t, b.s - a.t)) == -1);\r\n   \
    \   return a.t;\r\n    } else {\r\n      assert(false);\r\n    }\r\n  } else {\r\
    \n    return intersection(Line(a.s, a.t), Line(b.s, b.t));\r\n  }\r\n}\r\nPoint\
    \ intersection(const Line &a, const Segment &b) {\r\n  assert(has_intersected(a,\
    \ b));\r\n  return intersection(a, Line(b.s, b.t));\r\n}\r\nstd::vector<Point>\
    \ intersection(const Circle &a, const Line &b) {\r\n  Point pro = projection(b,\
    \ a.p);\r\n  Real nor = (a.p - pro).norm();\r\n  int sign = sgn(a.r - std::sqrt(nor));\r\
    \n  if (sign == -1) return {};\r\n  if (sign == 0) return {pro};\r\n  Point v\
    \ = (b.t - b.s).unit_vector() * std::sqrt(a.r * a.r - nor);\r\n  return {pro +\
    \ v, pro - v};\r\n}\r\nstd::vector<Point> intersection(const Circle &a, const\
    \ Segment &b) {\r\n  if (!has_intersected(a, b)) return {};\r\n  std::vector<Point>\
    \ res = intersection(a, Line(b.s, b.t));\r\n  if (sgn(distance(a.p, b.s) - a.r)\
    \ != -1 && sgn(distance(a.p, b.t) - a.r) != -1) return res;\r\n  return {sgn(dot(res[0]\
    \ - b.s, res[0] - b.t)) == 1 ? res[1] : res[0]};\r\n}\r\nstd::vector<Point> intersection(const\
    \ Circle &a, const Circle &b) {\r\n  int sz = sizeof_common_tangent(a, b);\r\n\
    \  if (sz == 0 || sz == 4) return {};\r\n  Real alpha = (b.p - a.p).arg();\r\n\
    \  if (sz == 1 || sz == 3) return {Point(a.p.x + a.r * std::cos(alpha), a.p.y\
    \ + a.r * std::sin(alpha))};\r\n  Real dist = (b.p - a.p).norm(), beta = std::acos((dist\
    \ + a.r * a.r - b.r * b.r) / (2 * std::sqrt(dist) * a.r));\r\n  return {a.p +\
    \ Point(a.r * std::cos(alpha + beta), a.r * std::sin(alpha + beta)), a.p + Point(a.r\
    \ * std::cos(alpha - beta), a.r * std::sin(alpha - beta))};\r\n}\r\n\r\nReal distance(const\
    \ Point &a, const Point &b) { return (b - a).abs(); }\r\nReal distance(const Segment\
    \ &a, const Point &b) {\r\n  Point foot = projection(a, b);\r\n  return has_intersected(a,\
    \ foot) ? distance(foot, b) : std::min(distance(a.s, b), distance(a.t, b));\r\n\
    }\r\nReal distance(const Segment &a, const Segment &b) { return has_intersected(a,\
    \ b) ? 0 : std::min({distance(a, b.s), distance(a, b.t), distance(b, a.s), distance(b,\
    \ a.t)}); }\r\nReal distance(const Line &a, const Point &b) { return distance(projection(a,\
    \ b), b); }\r\nReal distance(const Line &a, const Segment &b) { return has_intersected(a,\
    \ b) ? 0 : std::min(distance(a, b.s), distance(a, b.t)); }\r\nReal distance(const\
    \ Line &a, const Line &b) { return has_intersected(a, b) ? 0 : distance(a, b.s);\
    \ }\r\n\r\nstd::vector<Point> tangency(const Circle &a, const Point &b) {\r\n\
    \  Real dist = distance(a.p, b);\r\n  int sign = sgn(dist - a.r);\r\n  if (sign\
    \ == -1) return {};\r\n  if (sign == 0) return {b};\r\n  Real alpha = (b - a.p).arg(),\
    \ beta = std::acos(a.r / dist);\r\n  return {a.p + Point(a.r * std::cos(alpha\
    \ + beta), a.r * std::sin(alpha + beta)), a.p + Point(a.r * std::cos(alpha - beta),\
    \ a.r * std::sin(alpha - beta))};\r\n}\r\nint sizeof_common_tangent(const Circle\
    \ &a, const Circle &b) {\r\n  Real dist = distance(a.p, b.p);\r\n  int sign =\
    \ sgn(a.r + b.r - dist);\r\n  if (sign == -1) return 4;\r\n  if (sign == 0) return\
    \ 3;\r\n  sign = sgn((sgn(a.r - b.r) == -1 ? b.r - a.r : a.r - b.r) - dist);\r\
    \n  if (sign == -1) return 2;\r\n  if (sign == 0) return 1;\r\n  return 0;\r\n\
    }\r\nstd::vector<Line> common_tangent(const Circle &a, const Circle &b) {\r\n\
    \  std::vector<Line> tangents;\r\n  Real dist = distance(a.p, b.p), argument =\
    \ (b.p - a.p).arg();\r\n  int sign = sgn(a.r + b.r - dist);\r\n  if (sign == -1)\
    \ {\r\n    Real ac = std::acos((a.r + b.r) / dist), alpha = argument + ac, cs\
    \ = std::cos(alpha), sn = std::sin(alpha);\r\n    tangents.emplace_back(a.p +\
    \ Point(a.r * cs, a.r * sn), b.p + Point(-b.r * cs, -b.r * sn));\r\n    alpha\
    \ = argument - ac; cs = std::cos(alpha); sn = std::sin(alpha);\r\n    tangents.emplace_back(a.p\
    \ + Point(a.r * cs, a.r * sn), b.p + Point(-b.r * cs, -b.r * sn));\r\n  } else\
    \ if (sign == 0) {\r\n    Point s = a.p + Point(a.r * std::cos(argument), a.r\
    \ * std::sin(argument));\r\n    tangents.emplace_back(s, s + (b.p - a.p).normal_unit_vector().first);\r\
    \n  }\r\n  if (sgn(b.r - a.r) == -1) {\r\n    sign = sgn(a.r - b.r - dist);\r\n\
    \    if (sign == -1) {\r\n      Real at = std::acos((a.r - b.r) / dist), alpha\
    \ = argument + at, cs = std::cos(alpha), sn = std::sin(alpha);\r\n      tangents.emplace_back(a.p\
    \ + Point(a.r * cs, a.r * sn), b.p + Point(b.r * cs, b.r * sn));\r\n      alpha\
    \ = argument - at; cs = std::cos(alpha); sn = std::sin(alpha);\r\n      tangents.emplace_back(a.p\
    \ + Point(a.r * cs, a.r * sn), b.p + Point(b.r * cs, b.r * sn));\r\n    } else\
    \ if (sign == 0) {\r\n      Point s = a.p + Point(a.r * std::cos(argument), a.r\
    \ * std::sin(argument));\r\n      tangents.emplace_back(s, s + (b.p - a.p).normal_unit_vector().first);\r\
    \n    }\r\n  } else {\r\n    sign = sgn(b.r - a.r - dist);\r\n    if (sign ==\
    \ -1) {\r\n      Real at = std::acos((b.r - a.r) / dist), alpha = argument - at,\
    \ cs = std::cos(alpha), sn = std::sin(alpha);\r\n      tangents.emplace_back(a.p\
    \ + Point(-a.r * cs, -a.r * sn), b.p + Point(-b.r * cs, -b.r * sn));\r\n     \
    \ alpha = argument + at; cs = std::cos(alpha); sn = std::sin(alpha);\r\n     \
    \ tangents.emplace_back(a.p + Point(-a.r * cs, -a.r * sn), b.p + Point(-b.r *\
    \ cs, -b.r * sn));\r\n    } else if (sign == 0) {\r\n      Point s = b.p + Point(-b.r\
    \ * std::cos(argument), -b.r * std::sin(argument));\r\n      tangents.emplace_back(s,\
    \ s + (a.p - b.p).normal_unit_vector().first);\r\n    }\r\n  }\r\n  return tangents;\r\
    \n}\r\n\r\nReal intersection_area(const Circle &a, const Circle &b) {\r\n  Real\
    \ nor = (b.p - a.p).norm(), dist = std::sqrt(nor);\r\n  if (sgn(a.r + b.r - dist)\
    \ != 1) return 0;\r\n  if (sgn(std::abs(a.r - b.r) - dist) != -1) return std::min(a.r,\
    \ b.r) * std::min(a.r, b.r) * PI;\r\n  Real alpha = std::acos((nor + a.r * a.r\
    \ - b.r * b.r) / (2 * dist * a.r)), beta = std::acos((nor + b.r * b.r - a.r *\
    \ a.r) / (2 * dist * b.r));\r\n  return (alpha - std::sin(alpha + alpha) * 0.5)\
    \ * a.r * a.r + (beta - std::sin(beta + beta) * 0.5) * b.r * b.r;\r\n}\r\n\r\n\
    using Polygon = std::vector<Point>;\r\n\r\nReal area(const Polygon &a) {\r\n \
    \ int n = a.size();\r\n  Real res = 0;\r\n  for (int i = 0; i < n; ++i) res +=\
    \ cross(a[i], a[(i + 1) % n]);\r\n  return res * 0.5;\r\n}\r\n\r\nPoint centroid(const\
    \ Polygon &a) {\r\n  Point res(0, 0);\r\n  int n = a.size();\r\n  Real den = 0;\r\
    \n  for (int i = 0; i < n; ++i) {\r\n    Real cro = cross(a[i], a[(i + 1) % n]);\r\
    \n    res += (a[i] + a[(i + 1) % n]) / 3 * cro;\r\n    den += cro;\r\n  }\r\n\
    \  return res / den;\r\n}\r\n\r\nint is_contained(const Polygon &a, const Point\
    \ &b) {\r\n  int n = a.size();\r\n  bool is_in = false;\r\n  for (int i = 0; i\
    \ < n; ++i) {\r\n    Point p = a[i] - b, q = a[(i + 1) % n] - b;\r\n    if (sgn(q.y\
    \ - p.y) == -1) std::swap(p, q);\r\n    int sign = sgn(cross(p, q));\r\n    if\
    \ (sign == 1 && sgn(p.y) != 1 && sgn(q.y) == 1) is_in = !is_in;\r\n    if (sign\
    \ == 0 && sgn(dot(p, q)) != 1) return 1;\r\n  }\r\n  return is_in ? 2 : 0;\r\n\
    }\r\n\r\nbool is_convex(const Polygon &a) {\r\n  int n = a.size();\r\n  for (int\
    \ i = 0; i < n; ++i) {\r\n    if (ccw(a[(i - 1 + n) % n], a[i], a[(i + 1) % n])\
    \ == -1) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nPolygon monotone_chain(std::vector<Point>\
    \ ps, bool tight = true) {\r\n  std::sort(ps.begin(), ps.end());\r\n  int n =\
    \ ps.size(), idx = 0;\r\n  Polygon convex_hull(n << 1);\r\n  for (int i = 0; i\
    \ < n; convex_hull[idx++] = ps[i++]) {\r\n    while (idx >= 2 && sgn(cross(convex_hull[idx\
    \ - 1] - convex_hull[idx - 2], ps[i] - convex_hull[idx - 1])) < tight) --idx;\r\
    \n  }\r\n  for (int i = n - 2, border = idx + 1; i >= 0; convex_hull[idx++] =\
    \ ps[i--]) {\r\n    while (idx >= border && sgn(cross(convex_hull[idx - 1] - convex_hull[idx\
    \ - 2], ps[i] - convex_hull[idx - 1])) < tight) --idx;\r\n  }\r\n  convex_hull.resize(idx\
    \ - 1);\r\n  return convex_hull;\r\n}\r\n\r\nPolygon cut_convex(const Polygon\
    \ &a, const Line &b) {\r\n  int n = a.size();\r\n  Polygon res;\r\n  for (int\
    \ i = 0; i < n; ++i) {\r\n    int c = ccw(b.s, b.t, a[i]);\r\n    if (c != -1)\
    \ res.emplace_back(a[i]);\r\n    if (c * ccw(b.s, b.t, a[(i + 1) % n]) == -1)\
    \ res.emplace_back(intersection(Line(a[i], a[(i + 1) % n]), b));\r\n  }\r\n  if\
    \ (res.size() < 3) res.clear();\r\n  return res;\r\n}\r\n\r\nstd::pair<Point,\
    \ Point> rotating_calipers(const Polygon &a) {\r\n  int n = a.size(), high = 0,\
    \ low = 0;\r\n  if (n <= 2) {\r\n    assert(n == 2);\r\n    return {a[0], a[1]};\r\
    \n  }\r\n  for (int i = 1; i < n; ++i) {\r\n    if (a[i].y > a[high].y) high =\
    \ i;\r\n    if (a[i].y < a[low].y) low = i;\r\n  }\r\n  Real max_norm = (a[high]\
    \ - a[low]).norm();\r\n  int i = high, j = low, max_i = i, max_j = j;\r\n  do\
    \ {\r\n    ((sgn(cross(a[(i + 1) % n] - a[i], a[(j + 1) % n] - a[j])) != -1 ?\
    \ j : i) += 1) %= n;\r\n    Real tmp = (a[j] - a[i]).norm();\r\n    if (sgn(tmp\
    \ - max_norm) == 1) {\r\n      max_norm = tmp;\r\n      max_i = i; max_j = j;\r\
    \n    }\r\n  } while (i != high || j != low);\r\n  return {a[max_i], a[max_j]};\r\
    \n}\r\n}  // geometry\r\n"
  code: "#pragma once\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <cmath>\r\
    \n#include <functional>\r\n#include <iostream>\r\n#include <limits>\r\n#include\
    \ <utility>\r\n#include <vector>\r\n\r\nnamespace geometry {\r\nusing Real = double;\r\
    \nconstexpr long double PI = 3.14159265358979323846;\r\n\r\nint sgn(Real x) {\r\
    \n  static constexpr Real EPS = 1e-8;\r\n  return x > EPS ? 1 : x < -EPS ? -1\
    \ : 0;\r\n}\r\n\r\nReal degree_to_radian(Real d) { return d * PI / 180; }\r\n\
    Real radian_to_degree(Real r) { return r * 180 / PI; }\r\n\r\nstruct Point {\r\
    \n  Real x, y;\r\n  Point(Real x = 0, Real y = 0) : x(x), y(y) {}\r\n  Real abs()\
    \ const { return std::sqrt(norm()); }\r\n  Real arg() const { Real res = std::atan2(y,\
    \ x); return res < 0 ? res + PI * 2 : res; }\r\n  Real norm() const { return x\
    \ * x + y * y; }\r\n  Point rotate(Real angle) const { Real cs = std::cos(angle),\
    \ sn = std::sin(angle); return Point(x * cs - y * sn, x * sn + y * cs); }\r\n\
    \  Point unit_vector() const { Real a = abs(); return Point(x / a, y / a); }\r\
    \n  std::pair<Point, Point> normal_unit_vector() const { Point p = unit_vector();\
    \ return {Point(-p.y, p.x), Point(p.y, -p.x)}; }\r\n  Point &operator+=(const\
    \ Point &p) { x += p.x; y += p.y; return *this; }\r\n  Point &operator-=(const\
    \ Point &p) { x -= p.x; y -= p.y; return *this; }\r\n  Point &operator*=(Real\
    \ k) { x *= k; y *= k; return *this; }\r\n  Point &operator/=(Real k) { x /= k;\
    \ y /= k; return *this; }\r\n  bool operator<(const Point &p) const { int x_sgn\
    \ = sgn(p.x - x); return x_sgn != 0 ? x_sgn == 1 : sgn(p.y - y) == 1; }\r\n  bool\
    \ operator<=(const Point &p) const { return !(p < *this); }\r\n  bool operator>(const\
    \ Point &p) const { return p < *this; }\r\n  bool operator>=(const Point &p) const\
    \ { return !(*this < p); }\r\n  Point operator+() const { return *this; }\r\n\
    \  Point operator-() const { return Point(-x, -y); }\r\n  Point operator+(const\
    \ Point &p) const { return Point(*this) += p; }\r\n  Point operator-(const Point\
    \ &p) const { return Point(*this) -= p; }\r\n  Point operator*(Real k) const {\
    \ return Point(*this) *= k; }\r\n  Point operator/(Real k) const { return Point(*this)\
    \ /= k; }\r\n  friend std::ostream &operator<<(std::ostream &os, const Point &p)\
    \ { return os << '(' << p.x << \", \" << p.y << ')'; }\r\n  friend std::istream\
    \ &operator>>(std::istream &is, Point &p) { Real x, y; is >> x >> y; p = Point(x,\
    \ y); return is; }\r\n};\r\n\r\nstruct Segment {\r\n  Point s, t;\r\n  Segment(const\
    \ Point &s = {0, 0}, const Point &t = {0, 0}) : s(s), t(t) {}\r\n};\r\nstruct\
    \ Line : Segment {\r\n  using Segment::Segment;\r\n  Line(Real a, Real b, Real\
    \ c) {\r\n    if (sgn(a) == 0) {\r\n      s = Point(0, -c / b); t = Point(1, s.y);\r\
    \n    } else if (sgn(b) == 0) {\r\n      s = Point(-c / a, 0); t = Point(s.x,\
    \ 1);\r\n    } else if (sgn(c) == 0) {\r\n      s = Point(0, 0); t = Point(1,\
    \ -a / b);\r\n    } else {\r\n      s = Point(0, -c / b); t = Point(-c / a, 0);\r\
    \n    }\r\n  }\r\n};\r\n\r\nstruct Circle {\r\n  Point p; Real r;\r\n  Circle(const\
    \ Point &p = {0, 0}, Real r = 0) : p(p), r(r) {}\r\n};\r\n\r\nReal cross(const\
    \ Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }\r\nReal dot(const\
    \ Point &a, const Point &b) { return a.x * b.x + a.y * b.y; }\r\n\r\nint ccw(const\
    \ Point &a, const Point &b, const Point &c) {\r\n  Point ab = b - a, ac = c -\
    \ a;\r\n  int sign = sgn(cross(ab, ac));\r\n  if (sign == 0) {\r\n    if (sgn(dot(ab,\
    \ ac)) == -1) return 2;\r\n    if (sgn(ac.norm() - ab.norm()) == 1) return -2;\r\
    \n  }\r\n  return sign;\r\n}\r\n\r\nReal get_angle(const Point &a, const Point\
    \ &b, const Point &c) {\r\n  Real ba_arg = (a - b).arg(), bc_arg = (c - b).arg();\r\
    \n  if (ba_arg > bc_arg) std::swap(ba_arg, bc_arg);\r\n  return std::min(bc_arg\
    \ - ba_arg, static_cast<Real>(PI * 2 - (bc_arg - ba_arg)));\r\n}\r\n\r\nReal closest_pair(std::vector<Point>\
    \ ps) {\r\n  int n = ps.size();\r\n  assert(n > 1);\r\n  std::sort(ps.begin(),\
    \ ps.end());\r\n  std::function<Real(int, int)> rec = [&ps, &rec](int left, int\
    \ right) -> Real {\r\n    int mid = (left + right) >> 1;\r\n    Real x_mid = ps[mid].x,\
    \ d = std::numeric_limits<Real>::max();\r\n    if (left + 1 < mid) {\r\n     \
    \ Real tmp = rec(left, mid);\r\n      if (tmp < d) d = tmp;\r\n    }\r\n    if\
    \ (mid + 1 < right) {\r\n      Real tmp = rec(mid, right);\r\n      if (tmp <\
    \ d) d = tmp;\r\n    }\r\n    std::inplace_merge(ps.begin() + left, ps.begin()\
    \ + mid, ps.begin() + right, [&](const Point &a, const Point &b) -> bool { return\
    \ sgn(b.y - a.y) == 1; });\r\n    std::vector<Point> tmp;\r\n    for (int i =\
    \ left; i < right; ++i) {\r\n      if (sgn(std::abs(ps[i].x - x_mid) - d) == 1)\
    \ continue;\r\n      for (int j = static_cast<int>(tmp.size()) - 1; j >= 0; --j)\
    \ {\r\n        Point now = ps[i] - tmp[j];\r\n        if (sgn(now.y - d) == 1)\
    \ break;\r\n        Real tmp = now.abs();\r\n        if (tmp < d) d = tmp;\r\n\
    \      }\r\n      tmp.emplace_back(ps[i]);\r\n    }\r\n    return d;\r\n  };\r\
    \n  return rec(0, n);\r\n}\r\n\r\nPoint projection(const Segment &a, const Point\
    \ &b) { return a.s + (a.t - a.s) * dot(a.t - a.s, b - a.s) / (a.t - a.s).norm();\
    \ }\r\nPoint reflection(const Segment &a, const Point &b) { return projection(a,\
    \ b) * 2 - b; }\r\n\r\nbool is_parallel(const Segment &a, const Segment &b) {\
    \ return sgn(cross(a.t - a.s, b.t - b.s)) == 0; }\r\nbool is_orthogonal(const\
    \ Segment &a, const Segment &b) { return sgn(dot(a.t - a.s, b.t - b.s)) == 0;\
    \ }\r\n\r\nReal distance(const Point&, const Point&);\r\nReal distance(const Segment&,\
    \ const Point&);\r\nReal distance(const Line&, const Point&);\r\nint sizeof_common_tangent(const\
    \ Circle&, const Circle&);\r\nbool has_intersected(const Segment &a, const Point\
    \ &b) { return ccw(a.s, a.t, b) == 0; }\r\nbool has_intersected(const Segment\
    \ &a, const Segment &b) { return ccw(a.s, a.t, b.s) * ccw(a.s, a.t, b.t) <= 0\
    \ && ccw(b.s, b.t, a.s) * ccw(b.s, b.t, a.t) <= 0; }\r\nbool has_intersected(const\
    \ Line &a, const Point &b) { int c = ccw(a.s, a.t, b); return c != 1 && c != -1;\
    \ }\r\nbool has_intersected(const Line &a, const Segment &b) { return ccw(a.s,\
    \ a.t, b.s) * ccw(a.s, a.t, b.t) != 1; }\r\nbool has_intersected(const Line &a,\
    \ const Line &b) { return sgn(cross(a.t - a.s, b.t - b.s)) != 0 || sgn(cross(a.t\
    \ - a.s, b.s - a.s)) == 0; }\r\nbool has_intersected(const Circle &a, const Point\
    \ &b) { return sgn(distance(a.p, b) - a.r) == 0; }\r\nbool has_intersected(const\
    \ Circle &a, const Segment &b) { return sgn(a.r - distance(b, a.p)) != -1 && sgn(std::max(distance(a.p,\
    \ b.s), distance(a.p, b.t)) - a.r) != -1; }\r\nbool has_intersected(const Circle\
    \ &a, const Line &b) { return sgn(a.r - distance(b, a.p)) != -1; }\r\nbool has_intersected(const\
    \ Circle &a, const Circle &b) { return sizeof_common_tangent(a, b) > 0; }\r\n\r\
    \nPoint intersection(const Line &a, const Line &b) {\r\n  assert(has_intersected(a,\
    \ b) && !is_parallel(a, b));\r\n  return a.s + (a.t - a.s) * cross(b.t - b.s,\
    \ b.s - a.s) / cross(b.t - b.s, a.t - a.s);\r\n}\r\nPoint intersection(const Segment\
    \ &a, const Segment &b) {\r\n  assert(has_intersected(a, b));\r\n  if (is_parallel(a,\
    \ b)) {\r\n    if (sgn(distance(a.s, b.s)) == 0) {\r\n      assert(sgn(dot(a.t\
    \ - a.s, b.t - a.s)) == -1);\r\n      return a.s;\r\n    } else if (sgn(distance(a.s,\
    \ b.t)) == 0) {\r\n      assert(sgn(dot(a.t - a.s, b.s - a.s)) == -1);\r\n   \
    \   return a.s;\r\n    } else if (sgn(distance(a.t, b.s)) == 0) {\r\n      assert(sgn(dot(a.s\
    \ - a.t, b.t - a.t)) == -1);\r\n      return a.t;\r\n    } else if (sgn(distance(a.t,\
    \ b.t)) == 0) {\r\n      assert(sgn(dot(a.s - a.t, b.s - a.t)) == -1);\r\n   \
    \   return a.t;\r\n    } else {\r\n      assert(false);\r\n    }\r\n  } else {\r\
    \n    return intersection(Line(a.s, a.t), Line(b.s, b.t));\r\n  }\r\n}\r\nPoint\
    \ intersection(const Line &a, const Segment &b) {\r\n  assert(has_intersected(a,\
    \ b));\r\n  return intersection(a, Line(b.s, b.t));\r\n}\r\nstd::vector<Point>\
    \ intersection(const Circle &a, const Line &b) {\r\n  Point pro = projection(b,\
    \ a.p);\r\n  Real nor = (a.p - pro).norm();\r\n  int sign = sgn(a.r - std::sqrt(nor));\r\
    \n  if (sign == -1) return {};\r\n  if (sign == 0) return {pro};\r\n  Point v\
    \ = (b.t - b.s).unit_vector() * std::sqrt(a.r * a.r - nor);\r\n  return {pro +\
    \ v, pro - v};\r\n}\r\nstd::vector<Point> intersection(const Circle &a, const\
    \ Segment &b) {\r\n  if (!has_intersected(a, b)) return {};\r\n  std::vector<Point>\
    \ res = intersection(a, Line(b.s, b.t));\r\n  if (sgn(distance(a.p, b.s) - a.r)\
    \ != -1 && sgn(distance(a.p, b.t) - a.r) != -1) return res;\r\n  return {sgn(dot(res[0]\
    \ - b.s, res[0] - b.t)) == 1 ? res[1] : res[0]};\r\n}\r\nstd::vector<Point> intersection(const\
    \ Circle &a, const Circle &b) {\r\n  int sz = sizeof_common_tangent(a, b);\r\n\
    \  if (sz == 0 || sz == 4) return {};\r\n  Real alpha = (b.p - a.p).arg();\r\n\
    \  if (sz == 1 || sz == 3) return {Point(a.p.x + a.r * std::cos(alpha), a.p.y\
    \ + a.r * std::sin(alpha))};\r\n  Real dist = (b.p - a.p).norm(), beta = std::acos((dist\
    \ + a.r * a.r - b.r * b.r) / (2 * std::sqrt(dist) * a.r));\r\n  return {a.p +\
    \ Point(a.r * std::cos(alpha + beta), a.r * std::sin(alpha + beta)), a.p + Point(a.r\
    \ * std::cos(alpha - beta), a.r * std::sin(alpha - beta))};\r\n}\r\n\r\nReal distance(const\
    \ Point &a, const Point &b) { return (b - a).abs(); }\r\nReal distance(const Segment\
    \ &a, const Point &b) {\r\n  Point foot = projection(a, b);\r\n  return has_intersected(a,\
    \ foot) ? distance(foot, b) : std::min(distance(a.s, b), distance(a.t, b));\r\n\
    }\r\nReal distance(const Segment &a, const Segment &b) { return has_intersected(a,\
    \ b) ? 0 : std::min({distance(a, b.s), distance(a, b.t), distance(b, a.s), distance(b,\
    \ a.t)}); }\r\nReal distance(const Line &a, const Point &b) { return distance(projection(a,\
    \ b), b); }\r\nReal distance(const Line &a, const Segment &b) { return has_intersected(a,\
    \ b) ? 0 : std::min(distance(a, b.s), distance(a, b.t)); }\r\nReal distance(const\
    \ Line &a, const Line &b) { return has_intersected(a, b) ? 0 : distance(a, b.s);\
    \ }\r\n\r\nstd::vector<Point> tangency(const Circle &a, const Point &b) {\r\n\
    \  Real dist = distance(a.p, b);\r\n  int sign = sgn(dist - a.r);\r\n  if (sign\
    \ == -1) return {};\r\n  if (sign == 0) return {b};\r\n  Real alpha = (b - a.p).arg(),\
    \ beta = std::acos(a.r / dist);\r\n  return {a.p + Point(a.r * std::cos(alpha\
    \ + beta), a.r * std::sin(alpha + beta)), a.p + Point(a.r * std::cos(alpha - beta),\
    \ a.r * std::sin(alpha - beta))};\r\n}\r\nint sizeof_common_tangent(const Circle\
    \ &a, const Circle &b) {\r\n  Real dist = distance(a.p, b.p);\r\n  int sign =\
    \ sgn(a.r + b.r - dist);\r\n  if (sign == -1) return 4;\r\n  if (sign == 0) return\
    \ 3;\r\n  sign = sgn((sgn(a.r - b.r) == -1 ? b.r - a.r : a.r - b.r) - dist);\r\
    \n  if (sign == -1) return 2;\r\n  if (sign == 0) return 1;\r\n  return 0;\r\n\
    }\r\nstd::vector<Line> common_tangent(const Circle &a, const Circle &b) {\r\n\
    \  std::vector<Line> tangents;\r\n  Real dist = distance(a.p, b.p), argument =\
    \ (b.p - a.p).arg();\r\n  int sign = sgn(a.r + b.r - dist);\r\n  if (sign == -1)\
    \ {\r\n    Real ac = std::acos((a.r + b.r) / dist), alpha = argument + ac, cs\
    \ = std::cos(alpha), sn = std::sin(alpha);\r\n    tangents.emplace_back(a.p +\
    \ Point(a.r * cs, a.r * sn), b.p + Point(-b.r * cs, -b.r * sn));\r\n    alpha\
    \ = argument - ac; cs = std::cos(alpha); sn = std::sin(alpha);\r\n    tangents.emplace_back(a.p\
    \ + Point(a.r * cs, a.r * sn), b.p + Point(-b.r * cs, -b.r * sn));\r\n  } else\
    \ if (sign == 0) {\r\n    Point s = a.p + Point(a.r * std::cos(argument), a.r\
    \ * std::sin(argument));\r\n    tangents.emplace_back(s, s + (b.p - a.p).normal_unit_vector().first);\r\
    \n  }\r\n  if (sgn(b.r - a.r) == -1) {\r\n    sign = sgn(a.r - b.r - dist);\r\n\
    \    if (sign == -1) {\r\n      Real at = std::acos((a.r - b.r) / dist), alpha\
    \ = argument + at, cs = std::cos(alpha), sn = std::sin(alpha);\r\n      tangents.emplace_back(a.p\
    \ + Point(a.r * cs, a.r * sn), b.p + Point(b.r * cs, b.r * sn));\r\n      alpha\
    \ = argument - at; cs = std::cos(alpha); sn = std::sin(alpha);\r\n      tangents.emplace_back(a.p\
    \ + Point(a.r * cs, a.r * sn), b.p + Point(b.r * cs, b.r * sn));\r\n    } else\
    \ if (sign == 0) {\r\n      Point s = a.p + Point(a.r * std::cos(argument), a.r\
    \ * std::sin(argument));\r\n      tangents.emplace_back(s, s + (b.p - a.p).normal_unit_vector().first);\r\
    \n    }\r\n  } else {\r\n    sign = sgn(b.r - a.r - dist);\r\n    if (sign ==\
    \ -1) {\r\n      Real at = std::acos((b.r - a.r) / dist), alpha = argument - at,\
    \ cs = std::cos(alpha), sn = std::sin(alpha);\r\n      tangents.emplace_back(a.p\
    \ + Point(-a.r * cs, -a.r * sn), b.p + Point(-b.r * cs, -b.r * sn));\r\n     \
    \ alpha = argument + at; cs = std::cos(alpha); sn = std::sin(alpha);\r\n     \
    \ tangents.emplace_back(a.p + Point(-a.r * cs, -a.r * sn), b.p + Point(-b.r *\
    \ cs, -b.r * sn));\r\n    } else if (sign == 0) {\r\n      Point s = b.p + Point(-b.r\
    \ * std::cos(argument), -b.r * std::sin(argument));\r\n      tangents.emplace_back(s,\
    \ s + (a.p - b.p).normal_unit_vector().first);\r\n    }\r\n  }\r\n  return tangents;\r\
    \n}\r\n\r\nReal intersection_area(const Circle &a, const Circle &b) {\r\n  Real\
    \ nor = (b.p - a.p).norm(), dist = std::sqrt(nor);\r\n  if (sgn(a.r + b.r - dist)\
    \ != 1) return 0;\r\n  if (sgn(std::abs(a.r - b.r) - dist) != -1) return std::min(a.r,\
    \ b.r) * std::min(a.r, b.r) * PI;\r\n  Real alpha = std::acos((nor + a.r * a.r\
    \ - b.r * b.r) / (2 * dist * a.r)), beta = std::acos((nor + b.r * b.r - a.r *\
    \ a.r) / (2 * dist * b.r));\r\n  return (alpha - std::sin(alpha + alpha) * 0.5)\
    \ * a.r * a.r + (beta - std::sin(beta + beta) * 0.5) * b.r * b.r;\r\n}\r\n\r\n\
    using Polygon = std::vector<Point>;\r\n\r\nReal area(const Polygon &a) {\r\n \
    \ int n = a.size();\r\n  Real res = 0;\r\n  for (int i = 0; i < n; ++i) res +=\
    \ cross(a[i], a[(i + 1) % n]);\r\n  return res * 0.5;\r\n}\r\n\r\nPoint centroid(const\
    \ Polygon &a) {\r\n  Point res(0, 0);\r\n  int n = a.size();\r\n  Real den = 0;\r\
    \n  for (int i = 0; i < n; ++i) {\r\n    Real cro = cross(a[i], a[(i + 1) % n]);\r\
    \n    res += (a[i] + a[(i + 1) % n]) / 3 * cro;\r\n    den += cro;\r\n  }\r\n\
    \  return res / den;\r\n}\r\n\r\nint is_contained(const Polygon &a, const Point\
    \ &b) {\r\n  int n = a.size();\r\n  bool is_in = false;\r\n  for (int i = 0; i\
    \ < n; ++i) {\r\n    Point p = a[i] - b, q = a[(i + 1) % n] - b;\r\n    if (sgn(q.y\
    \ - p.y) == -1) std::swap(p, q);\r\n    int sign = sgn(cross(p, q));\r\n    if\
    \ (sign == 1 && sgn(p.y) != 1 && sgn(q.y) == 1) is_in = !is_in;\r\n    if (sign\
    \ == 0 && sgn(dot(p, q)) != 1) return 1;\r\n  }\r\n  return is_in ? 2 : 0;\r\n\
    }\r\n\r\nbool is_convex(const Polygon &a) {\r\n  int n = a.size();\r\n  for (int\
    \ i = 0; i < n; ++i) {\r\n    if (ccw(a[(i - 1 + n) % n], a[i], a[(i + 1) % n])\
    \ == -1) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nPolygon monotone_chain(std::vector<Point>\
    \ ps, bool tight = true) {\r\n  std::sort(ps.begin(), ps.end());\r\n  int n =\
    \ ps.size(), idx = 0;\r\n  Polygon convex_hull(n << 1);\r\n  for (int i = 0; i\
    \ < n; convex_hull[idx++] = ps[i++]) {\r\n    while (idx >= 2 && sgn(cross(convex_hull[idx\
    \ - 1] - convex_hull[idx - 2], ps[i] - convex_hull[idx - 1])) < tight) --idx;\r\
    \n  }\r\n  for (int i = n - 2, border = idx + 1; i >= 0; convex_hull[idx++] =\
    \ ps[i--]) {\r\n    while (idx >= border && sgn(cross(convex_hull[idx - 1] - convex_hull[idx\
    \ - 2], ps[i] - convex_hull[idx - 1])) < tight) --idx;\r\n  }\r\n  convex_hull.resize(idx\
    \ - 1);\r\n  return convex_hull;\r\n}\r\n\r\nPolygon cut_convex(const Polygon\
    \ &a, const Line &b) {\r\n  int n = a.size();\r\n  Polygon res;\r\n  for (int\
    \ i = 0; i < n; ++i) {\r\n    int c = ccw(b.s, b.t, a[i]);\r\n    if (c != -1)\
    \ res.emplace_back(a[i]);\r\n    if (c * ccw(b.s, b.t, a[(i + 1) % n]) == -1)\
    \ res.emplace_back(intersection(Line(a[i], a[(i + 1) % n]), b));\r\n  }\r\n  if\
    \ (res.size() < 3) res.clear();\r\n  return res;\r\n}\r\n\r\nstd::pair<Point,\
    \ Point> rotating_calipers(const Polygon &a) {\r\n  int n = a.size(), high = 0,\
    \ low = 0;\r\n  if (n <= 2) {\r\n    assert(n == 2);\r\n    return {a[0], a[1]};\r\
    \n  }\r\n  for (int i = 1; i < n; ++i) {\r\n    if (a[i].y > a[high].y) high =\
    \ i;\r\n    if (a[i].y < a[low].y) low = i;\r\n  }\r\n  Real max_norm = (a[high]\
    \ - a[low]).norm();\r\n  int i = high, j = low, max_i = i, max_j = j;\r\n  do\
    \ {\r\n    ((sgn(cross(a[(i + 1) % n] - a[i], a[(j + 1) % n] - a[j])) != -1 ?\
    \ j : i) += 1) %= n;\r\n    Real tmp = (a[j] - a[i]).norm();\r\n    if (sgn(tmp\
    \ - max_norm) == 1) {\r\n      max_norm = tmp;\r\n      max_i = i; max_j = j;\r\
    \n    }\r\n  } while (i != high || j != low);\r\n  return {a[max_i], a[max_j]};\r\
    \n}\r\n}  // geometry\r\n"
  dependsOn: []
  isVerificationFile: false
  path: geometry/geometry.hpp
  requiredBy:
  - geometry/smallest_enclosing_circle.hpp
  timestamp: '2021-02-13 06:42:09+09:00'
  verificationStatus: LIBRARY_SOME_WA
  verifiedWith:
  - test/math/quadratic_equation.test.cpp
  - test/geometry/geometry.11.test.cpp
  - test/geometry/geometry.09.test.cpp
  - test/geometry/geometry.20.test.cpp
  - test/geometry/geometry.14.test.cpp
  - test/geometry/geometry.18.test.cpp
  - test/geometry/geometry.17.test.cpp
  - test/geometry/geometry.07.test.cpp
  - test/geometry/geometry.10.test.cpp
  - test/geometry/geometry.08.test.cpp
  - test/geometry/geometry.21.test.cpp
  - test/geometry/geometry.13.test.cpp
  - test/geometry/geometry.19.test.cpp
  - test/geometry/geometry.22.test.cpp
  - test/geometry/geometry.01.test.cpp
  - test/geometry/geometry.05.test.cpp
  - test/geometry/geometry.06.test.cpp
  - test/geometry/geometry.15.test.cpp
  - test/geometry/geometry.12.test.cpp
  - test/geometry/smallest_enclosing_circle.test.cpp
  - test/geometry/geometry.02.test.cpp
  - test/geometry/geometry.04.test.cpp
  - test/geometry/geometry.03.test.cpp
  - test/geometry/geometry.16.test.cpp
documentation_of: geometry/geometry.hpp
layout: document
title: "\u8A08\u7B97\u5E7E\u4F55\u5B66 (computational geometry)"
---


## 時間計算量

||時間計算量|
|:--:|:--:|
|最近点対|$O(N\log{N})$|
|多角形の面積|$O(N)$|
|多角形の重心|$O(N)$|
|多角形の内外判定|$O(N)$|
|凸性判定|$O(N)$|
|monotone chain|$O(N\log{N})$|
|凸多角形の切断|$O(N)$|
|キャリパー法|$O(N)$|


## 使用法

||説明|
|:--:|:--:|
|`sgn(x)`|$\begin{cases} 1 & (x > \varepsilon) \\\\ -1 & (x < -\varepsilon) \\\\ 0 & (\text{otherwise}) \end{cases}$|
|`degree_to_radian(d)`|$\frac{\pi d}{180}\,\mathrm{rad}$|
|`radian_to_degree(r)`|$(\frac{180r}{\pi})^\circ$|

- 点

||説明|備考|
|:--:|:--:|:--:|
|`Point(x = 0, y = 0)`|点 $(x, y)$||
|`x`, `y`|$(x, y)$||
|`abs()`|$\|\boldsymbol{p}\|$||
|`arg()`|$\arg(x + iy)$|$[0, 2\pi)$|
|`norm()`|$\|\boldsymbol{p}\|^2$||
|`rotate(angle)`|原点周りに $\mathrm{angle}$ だけ回転させたときの座標 $(x^{\prime}, y^{\prime})$|$\begin{cases} x^{\prime} = x\cos{\mathrm{angle}} - y\sin{\mathrm{angle}} \\\\ y^{\prime} = x\sin{\mathrm{angle}} + y\cos{\mathrm{angle}} \end{cases}$|
|`unit_vector()`|単位ベクトル||
|`normal_unit_vector()`|単位法線ベクトル|

- 線分

||説明|
|:--:|:--:|
|`Segment(s = (0, 0), t = (0, 0))`|始点 $s$, 終点 $t$ の線分|
|`s`|始点|
|`t`|終点|

- 直線

||説明|備考|
|:--:|:--:|:--:|
|`Line(s = (0, 0), t = (0, 0))`|始点 $s$, 終点 $t$ の線分||
|`Line(a, b, c)`|$ax + by + c = 0$ で表される直線|`s`, `t` には代表される2点を格納する．|
|`s`|始点|
|`t`|終点|

- 円

||説明|
|:--:|:--:|
|`Circle(p = (0, 0), r = 0)`|中心 $\mathrm{P}$, 半径 $r$ の円|
|`o`|中心|
|`r`|半径|

- 多角形

頂点は反時計回りに並ぶ．

- ライブラリ

||説明|備考|
|:--:|:--:|:--:|
|`cross(a, b)`|$\boldsymbol{a} \times \boldsymbol{b}$||
|`dot(a, b)`|$\boldsymbol{a} \cdot \boldsymbol{b}$||
|`ccw(a, b, c)`|$\begin{cases} -2 & (\mathrm{A}, \mathrm{B}, \mathrm{C}\text{ の順で一直線上に並ぶ}) \\\\ -1 & (\mathrm{AB} \text{ から見て } \mathrm{C} \text{ は右側にある}) \\\\ 0 & (\mathrm{A}, \mathrm{C}, \mathrm{B} \text{ の順で一直線上に並ぶ}) \\\\ 1 & (\mathrm{AB} \text{ から見て } \mathrm{C} \text{ は左側にある}) \\\\ 2 & (\mathrm{C}, \mathrm{A}, \mathrm{B} \text{ の順で一直線上に並ぶ}) \end{cases}$||
|`get_angle(a, b, c)`|$\angle{\mathrm{ABC}}$||
|`closest_pair(ps)`|点集合 $\mathrm{ps}$ の中から最も近い点対間の距離||
|`projection(a, b)`|$\mathrm{A}$ に対する点 $\mathrm{B}$ の射影||
|`reflection(a, b)`|$\mathrm{A}$ に対する点 $\mathrm{B}$ の鏡映||
|`is_parallel(a, b)`|$\boldsymbol{a} \parallel \boldsymbol{b}$|$\Leftrightarrow \boldsymbol{a} \times \boldsymbol{b}$|
|`is_orthogonal(a, b)`|$\boldsymbol{a} \perp \boldsymbol{b}$|$\Leftrightarrow \boldsymbol{a} \cdot \boldsymbol{b}$|
|`has_intersected(a, b)`|$\mathrm{A}$ と $\mathrm{B}$ は交差しているか．||
|`intersection(a, b)`|$\mathrm{A}$ と $\mathrm{B}$ の交点||
|`distance(a, b)`|$\mathrm{A}$ と $\mathrm{B}$ の距離||
|`tangency(a, b)`|点 $\mathrm{B}$ から円 $\mathrm{A}$ に引いた接線の接点|円 $(x - a)^2 + (y - b)^2 = r^2$ 上の点 $(x_0, y_0)$ における接線の方程式は $(x_0 - a)(x - a) + (y_0 - b)(y - b) = r^2$ である．|
|`sizeof_common_tangent(a, b)`|円 $\mathrm{A}$ と $\mathrm{B}$ の共通接線の本数||
|`common_tangent(a, b)`|円 $\mathrm{A}$ と $\mathrm{B}$ の共通接線|2円が接していない場合，`s` は円 $\mathrm{A}$ における接点，`t` は円 $\mathrm{B}$ における接点が格納される．|
|`intersection_area(a, b)`|円 $\mathrm{A}$ と $\mathrm{B}$ の共通部分の面積||
|`area(a)`|多角形 $\mathrm{A}$ の面積||
|`centroid(a)`|多角形 $\mathrm{A}$ の重心||
|`is_contained(a, b)`|多角形 $\mathrm{A}$ は点 $\mathrm{B}$ を含むか．||
|`is_convex(a)`|多角形 $\mathrm{A}$ は凸性をもつか．||
|`monotone_chain(ps, 凸包の辺上にある点を含まないか = true)`|点集合 $\mathrm{ps}$ の凸包|座標幅 $w$ のとき頂点数は $O(\sqrt{w})$ 個である．|
|`cut_convex(a, b)`|直線 $\mathrm{B}$ で凸多角形 $\mathrm{A}$ を切断したときの左側の凸多角形||
|`rotating_calipers(a)`|凸多角形 $\mathrm{A}$ の直径||


## 参考

- https://www.ioi-jp.org/camp/2017/2017-sp_camp-hide.pdf
- https://sen-comp.hatenablog.com/archive/category/%E3%80%8C%E5%9F%BA%E7%A4%8E%E7%9A%84%E8%A8%88%E7%AE%97%E5%B9%BE%E4%BD%95%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AE%E4%BD%9C%E3%82%8A%E6%96%B9%E3%80%8D
- http://www.deqnotes.net/acmicpc/2d_geometry/
- https://ei1333.github.io/luzhiled/snippets/geometry/template.html

最近点対
- プログラミングコンテストチャレンジブック \[第2版\] pp.324-326

接点
- https://mathtrain.jp/ennosessen

2円の共通接線の本数
- http://www.e-learning-jp.net/teach_math/mathA/text_1/6/11/001a.htm

2円の共通接線
- http://nutsu.com/blog/2007/102601_as_circletest6.html

多角形の面積
- https://blog.goo.ne.jp/m4g/e/82eb68689c322dc43d52ce16b29a9a74

2円の共通部分の面積
- https://drken1215.hatenablog.com/entry/2020/02/02/005800

多角形の内外判定
- https://www.nttpc.co.jp/technology/number_algorithm.html


## ToDo

- https://github.com/spaghetti-source/algorithm/blob/master/geometry/_geom.cc
- 3次元幾何学
  - https://github.com/beet-aizu/library/tree/master/geometry/3D
  - https://lumakernel.github.io/ecasdqina/geometory/geometory3D
  - https://github.com/drken1215/algorithm/blob/master/Geometry/basic_elements_3D.cpp
  - https://github.com/primenumber/ProconLib/blob/master/Geometry/3DGeometry.cpp
  - 3次元凸包
    - https://lumakernel.github.io/ecasdqina/geometory/ConvexHull3D
    - https://www.slideshare.net/abc3141/3-65377198
- 動的凸包
  - https://codeforces.com/blog/entry/75929
  - https://judge.yosupo.jp/problem/convex_layers
- 線分アレンジメント
  - https://github.com/ei1333/library/blob/master/geometry/template.cpp
  - https://ei1333.github.io/luzhiled/snippets/geometry/template.html
  - https://ei1333.github.io/algorithm/segment-arrangement.html
  - https://github.com/beet-aizu/library/blob/master/geometry/geometry.cpp
  - https://tubo28.me/compprog/algorithm/segment-arrangement/
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/segment_arrangement.cc
  - http://www.prefield.com/algorithm/geometry/segment_arrangement.html
  - https://github.com/primenumber/ProconLib/blob/master/Geometry/Arrangement.cpp
  - https://onlinejudge.u-aizu.ac.jp/problems/1033
- 直線アレンジメント
  - http://www.prefield.com/algorithm/geometry/walk_arrangement.html
  - https://nya3.jp/libicpc/#%E5%B9%BE%E4%BD%95/%E3%81%9D%E3%81%AE%E4%BB%96/%E3%82%A2%E3%83%AC%E3%83%B3%E3%82%B8%E3%83%A1%E3%83%B3%E3%83%88
- 円と多角形の共通部分の面積
  - https://github.com/ei1333/library/blob/master/geometry/template.cpp
  - https://ei1333.github.io/luzhiled/snippets/geometry/template.html
  - https://github.com/beet-aizu/library/blob/master/geometry/geometry.cpp
  - https://drken1215.hatenablog.com/entry/2020/02/02/091000
  - https://github.com/drken1215/algorithm/blob/master/Geometry/area_common_circle_polygon.cpp
  - http://kyopro.hateblo.jp/entry/2019/08/01/192232
  - https://topcoder-g-hatena-ne-jp.jag-icpc.org/not522/20130728/1374979041.html
  - https://twitter.com/not_522/status/1008671743584583682
- 点と半直線の距離
  - https://sen-comp.hatenablog.com/entry/2020/03/14/183251#distanceBetweenPointAndRay%E7%82%B9%E3%81%A8%E5%8D%8A%E7%9B%B4%E7%B7%9A%E3%81%AE%E8%B7%9D%E9%9B%A2
- 凸多角形の共通部分
  - http://www.prefield.com/algorithm/geometry/convex_intersect.html
  - http://gihyo.jp/dev/serial/01/geometry/0009
- 凸多角形の内外判定
  - http://www.prefield.com/algorithm/geometry/convex_contains.html
- 直線から最も遠い凸多角形上の点
  - http://www.prefield.com/algorithm/geometry/convex_extreme.html
- monotone chain 以外の凸包を求めるアルゴリズム
  - https://www.jaist.ac.jp/~uehara/course/2014/i481f/pdf/ppt-3.pdf
  - http://www-ikn.ist.hokudai.ac.jp/~k-sekine/slides/convexhull.pdf
  - http://www.thothchildren.com/chapter/5b268e086298160664e807e9
- 二等分線
  - https://github.com/beet-aizu/library/blob/master/geometry/geometry.cpp
  - https://github.com/drken1215/algorithm/blob/master/Geometry/convex_cut.cpp
- アポロニウスの円 (circle of Apollonius)
  - https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%9D%E3%83%AD%E3%83%8B%E3%82%A6%E3%82%B9%E3%81%AE%E5%86%86
  - https://mathtrain.jp/apollonius
  - https://github.com/drken1215/algorithm/blob/master/Geometry/All.cpp
  - https://onlinejudge.u-aizu.ac.jp/problems/1039
- 3点を通る円
  - http://www.prefield.com/algorithm/geometry/misc.html
- ピックの定理 (Pick's theorem)
  - https://ja.wikipedia.org/wiki/%E3%83%94%E3%83%83%E3%82%AF%E3%81%AE%E5%AE%9A%E7%90%86
- 線分の併合
  - http://www.prefield.com/algorithm/geometry/merge_segments.html
  - https://github.com/ei1333/library/blob/master/geometry/template.cpp
  - https://ei1333.github.io/luzhiled/snippets/geometry/template.html
  - https://onlinejudge.u-aizu.ac.jp/problems/1033
- 点位置決定問題 (point location problem)
  - https://en.wikipedia.org/wiki/Point_location
  - http://www.orsj.or.jp/~wiki/wiki/index.php/%E7%82%B9%E4%BD%8D%E7%BD%AE%E6%B1%BA%E5%AE%9A
  - https://ikatakos.com/pot/programming_algorithm/geometry/planar_point_location
  - http://www-imai.is.s.u-tokyo.ac.jp/~tsuyoshi/tmp/compgeo-20040608.pdf
  - http://www.prefield.com/algorithm/geometry/point_location.html
- 串刺し問題
  - http://www.prefield.com/algorithm/geometry/stabbing_line.html
- 耳分解 (ear decomposition)
  - https://en.wikipedia.org/wiki/Ear_decomposition
  - http://www.prefield.com/algorithm/geometry/triangulate.html
- 多角形の平行移動
  - http://www.prefield.com/algorithm/geometry/shrink_polygon.html
- ドロネー図 (delaunay diagram)
  - https://ja.wikipedia.org/wiki/%E3%83%89%E3%83%AD%E3%83%8D%E3%83%BC%E5%9B%B3
  - https://www.slideshare.net/Kinokkory/ss-25736696
  - http://www.orsj.or.jp/~wiki/wiki/index.php/%E3%83%89%E3%83%AD%E3%83%8D%E3%83%BC%E5%9B%B3
  - http://www.thothchildren.com/chapter/5bded85141f88f267247fdc6
  - http://hadashia.hatenablog.com/entry/2018/10/11/194602
  - http://www.prefield.com/algorithm/geometry/delaunay.html
- kd 木 (k-d tree)
  - https://ja.wikipedia.org/wiki/Kd%E6%9C%A8
  - https://www.slideshare.net/okuraofvegetable/ss-65377588
  - https://github.com/beet-aizu/library/blob/master/datastructure/kdtree.cpp
  - https://github.com/primenumber/ProconLib/blob/master/Structure/kdTree.cpp
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/kd_tree.cc
  - http://www.prefield.com/algorithm/geometry/kdtree.html
  - https://tjkendev.github.io/procon-library/cpp/range_query/kd-tree.html
  - randomized k-d tree
    - https://github.com/spaghetti-source/algorithm/blob/master/geometry/randomized_kd_tree.cc
    - https://www.slideshare.net/keisukeumezawa5/scalable-nearest-neighbor-algorithms-for-high-dimensional-data-71772599
- BK-tree
  - https://en.wikipedia.org/wiki/BK-tree
  - https://postd.cc/bk-tree/
  - https://postd.cc/symspell-vs-bk-tree-100x-faster-fuzzy-string-search-spell-checking/
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/bk_tree.cc
  - http://agtn.hatenablog.com/entry/2017/05/13/183310
- vantage-point tree (VP tree)
  - https://en.wikipedia.org/wiki/Vantage-point_tree
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/vantage_point_tree.cc
- rectilinear minimum spanning tree (RMST)
  - https://en.wikipedia.org/wiki/Rectilinear_minimum_spanning_tree
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/rectilinear_mst.cc
- 双対変換
  - http://www.prefield.com/algorithm/geometry/dual_transformation.html
- 双対グラフ (dual graph)
  - https://en.wikipedia.org/wiki/Dual_graph
  - https://firiexp.github.io/library/library/geometry/dualgraph.cpp.html
  - https://github.com/primenumber/ProconLib/blob/master/Geometry/DualGraph.cpp
  - https://onlinejudge.u-aizu.ac.jp/problems/0273
- 斜方投射
  - https://github.com/beet-aizu/library/blob/master/geometry/projectilemotion.cpp
- Random Ball Cover (RBC)
  - http://www.lcayton.com/rbc.pdf
  - http://jsatml.blogspot.com/2012/10/random-ball-cover.html
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/random_ball_cover.cc
- On Finding the Maxima of a Set of Vectors
  - https://github.com/spaghetti-source/algorithm/blob/master/geometry/coordinate_domination.cc
- タクシー幾何学 (taxicab geometry)
  - https://en.wikipedia.org/wiki/Taxicab_geometry
  - https://github.com/beet-aizu/library/blob/master/geometry/geometry.cpp
- 問題集
  - https://gist.github.com/MiSawa/16d5f84cf66fd2913c82
- 三角形の外心 / 内心 / 垂心


## Verified

- [`ccw(a, b, c)`](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_1_C/review/4325588/emthrm/C++14)
- $\angle{\mathrm{ABC}}$
- [最近点対](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_5_A/review/4325777/emthrm/C++14)
- [射影](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_1_A/review/4325794/emthrm/C++14)
- [鏡映](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_1_B/review/4325814/emthrm/C++14)
- [平行](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_A/review/4325838/emthrm/C++14)
- [垂直](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_A/review/4325838/emthrm/C++14)
- [点と線分の交差判定](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_D/review/4325929/emthrm/C++14)
- [2線分の交差判定](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_B/review/4325860/emthrm/C++14)
- 点と直線の交差判定
- 線分と直線の交差判定
- 2直線の交差判定
- 点と円の交差判定
- [線分と円の交差判定](https://onlinejudge.u-aizu.ac.jp/solutions/problem/2276/review/4339412/emthrm/C++14)
- 直線と円の交差判定
- 2円の交差判定
- [2直線の交点](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_4_C/review/4326103/emthrm/C++14)
- [2線分の交点](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_C/review/4325877/emthrm/C++14)
- 線分と直線の交点
- [直線と円の交点](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_D/review/4325892/emthrm/C++14)
- [線分と円の交点](https://onlinejudge.u-aizu.ac.jp/solutions/problem/2316/review/4345536/emthrm/C++14)
- [2円の交点](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_E/review/4325909/emthrm/C++14)
- [2点の距離](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_F/review/4325939/emthrm/C++14)
- [点と線分の距離](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_D/review/4325929/emthrm/C++14)
- [2線分の距離](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_2_D/review/4325929/emthrm/C++14)
- 点と直線の距離
- 線分と直線の距離
- 2直線の距離
- [接点](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_F/review/4325939/emthrm/C++14)
- [2円の共通接線の本数](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_A/review/4325959/emthrm/C++14)
- [2円の共通接線](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_G/review/4325977/emthrm/C++14)
- [2円の共通部分の面積](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_7_I/review/4967134/emthrm/C++17)
- [多角形の面積](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_3_A/review/4326007/emthrm/C++14)
- 多角形の重心
- [多角形の内外判定](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_3_C/review/4326013/emthrm/C++14)
- [凸性判定](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_3_B/review/4326091/emthrm/C++14)
- [凸包](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_4_A/review/4326095/emthrm/C++14)
- [凸多角形の切断](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_4_C/review/4326103/emthrm/C++14)
- [凸多角形の直径](https://onlinejudge.u-aizu.ac.jp/solutions/problem/CGL_4_B/review/4326112/emthrm/C++14)
