---
data:
  _extendedDependsOn: []
  _extendedRequiredBy:
  - icon: ':heavy_check_mark:'
    path: dynamic_programming/subset_sum_problem.hpp
    title: "\u90E8\u5206\u548C\u554F\u984C (subset sum problem)"
  - icon: ':heavy_check_mark:'
    path: math/formal_power_series/bernoulli_number.hpp
    title: "\u30D9\u30EB\u30CC\u30FC\u30A4\u6570 (Bernoulli number)"
  - icon: ':warning:'
    path: math/formal_power_series/eulerian_number_init_by_fps.hpp
    title: "Eulerian number \u306E\u6570\u8868 \u5F62\u5F0F\u7684\u51AA\u7D1A\u6570\
      \u7248"
  - icon: ':heavy_check_mark:'
    path: math/formal_power_series/faulhaber_by_fps.hpp
    title: "\u30D5\u30A1\u30A6\u30EB\u30CF\u30FC\u30D0\u30FC\u306E\u516C\u5F0F \u5F62\
      \u5F0F\u7684\u51AA\u7D1A\u6570\u7248"
  - icon: ':warning:'
    path: math/twelvefold_way/bell_number/bell_number_init_by_fps.hpp
    title: "\u30D9\u30EB\u6570\u306E\u6570\u8868 $n = k$ \u7248"
  - icon: ':heavy_check_mark:'
    path: math/twelvefold_way/partition_function_init_by_fps.hpp
    title: "\u5206\u5272\u6570 $n = m$ \u7248"
  - icon: ':heavy_check_mark:'
    path: math/twelvefold_way/stirling_number/stirling_number_of_the_first_kind_init_by_fps.hpp
    title: "\u7B2C1\u7A2E\u30B9\u30BF\u30FC\u30EA\u30F3\u30B0\u6570\u306E\u6570\u8868\
      \ \u5F62\u5F0F\u7684\u51AA\u7D1A\u6570\u7248"
  - icon: ':heavy_check_mark:'
    path: math/twelvefold_way/stirling_number/stirling_number_of_the_second_kind_init_by_fps.hpp
    title: "\u7B2C2\u7A2E\u30B9\u30BF\u30FC\u30EA\u30F3\u30B0\u6570\u306E\u6570\u8868\
      \ \u5F62\u5F0F\u7684\u51AA\u7D1A\u6570\u7248"
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: test/dynamic_programming/subset_sum_problem.test.cpp
    title: "\u52D5\u7684\u8A08\u753B\u6CD5/\u90E8\u5206\u548C\u554F\u984C"
  - icon: ':heavy_check_mark:'
    path: test/math/formal_power_series/bernoulli_number.test.cpp
    title: "\u6570\u5B66/\u5F62\u5F0F\u7684\u51AA\u7D1A\u6570/\u30D9\u30EB\u30CC\u30FC\
      \u30A4\u6570"
  - icon: ':heavy_check_mark:'
    path: test/math/formal_power_series/faulhaber_by_fps.test.cpp
    title: "\u6570\u5B66/\u5F62\u5F0F\u7684\u51AA\u7D1A\u6570/\u30D5\u30A1\u30A6\u30EB\
      \u30CF\u30FC\u30D0\u30FC\u306E\u516C\u5F0F \u5F62\u5F0F\u7684\u51AA\u7D1A\u6570\
      \u7248"
  - icon: ':heavy_check_mark:'
    path: test/math/formal_power_series/formal_power_series.1.test.cpp
    title: "\u6570\u5B66/\u5F62\u5F0F\u7684\u51AA\u7D1A\u6570/\u5F62\u5F0F\u7684\u51AA\
      \u7D1A\u6570 (\u6307\u6570)"
  - icon: ':heavy_check_mark:'
    path: test/math/formal_power_series/formal_power_series.2.test.cpp
    title: "\u6570\u5B66/\u5F62\u5F0F\u7684\u51AA\u7D1A\u6570/\u5F62\u5F0F\u7684\u51AA\
      \u7D1A\u6570 (\u9006\u5143)"
  - icon: ':heavy_check_mark:'
    path: test/math/formal_power_series/formal_power_series.3.test.cpp
    title: "\u6570\u5B66/\u5F62\u5F0F\u7684\u51AA\u7D1A\u6570/\u5F62\u5F0F\u7684\u51AA\
      \u7D1A\u6570 (\u5BFE\u6570)"
  - icon: ':heavy_check_mark:'
    path: test/math/formal_power_series/formal_power_series.4.test.cpp
    title: "\u6570\u5B66/\u5F62\u5F0F\u7684\u51AA\u7D1A\u6570/\u5F62\u5F0F\u7684\u51AA\
      \u7D1A\u6570 (\u51AA\u4E57)"
  - icon: ':x:'
    path: test/math/formal_power_series/formal_power_series.5.test.cpp
    title: "\u6570\u5B66/\u5F62\u5F0F\u7684\u51AA\u7D1A\u6570/\u5F62\u5F0F\u7684\u51AA\
      \u7D1A\u6570 (mod_pow(exponend, md))"
  - icon: ':heavy_check_mark:'
    path: test/math/formal_power_series/formal_power_series.6.test.cpp
    title: "\u6570\u5B66/\u5F62\u5F0F\u7684\u51AA\u7D1A\u6570/\u5F62\u5F0F\u7684\u51AA\
      \u7D1A\u6570 (\u5E73\u65B9\u6839)"
  - icon: ':heavy_check_mark:'
    path: test/math/formal_power_series/formal_power_series.7.test.cpp
    title: "\u6570\u5B66/\u5F62\u5F0F\u7684\u51AA\u7D1A\u6570/\u5F62\u5F0F\u7684\u51AA\
      \u7D1A\u6570 (translate(c))"
  - icon: ':heavy_check_mark:'
    path: test/math/formal_power_series/multipoint_evaluation.test.cpp
    title: "\u6570\u5B66/\u5F62\u5F0F\u7684\u51AA\u7D1A\u6570/multipoint evaluation"
  - icon: ':heavy_check_mark:'
    path: test/math/formal_power_series/polynomial_interpolation.test.cpp
    title: "\u6570\u5B66/\u5F62\u5F0F\u7684\u51AA\u7D1A\u6570/\u591A\u9805\u5F0F\u88DC\
      \u9593"
  - icon: ':heavy_check_mark:'
    path: test/math/twelvefold_way/partition_function_init_by_fps.test.cpp
    title: "\u6570\u5B66/\u5199\u50CF12\u76F8/\u5206\u5272\u6570 $n = m$ \u7248"
  - icon: ':heavy_check_mark:'
    path: test/math/twelvefold_way/stirling_number/stirling_number_of_the_first_kind_init_with_fps.test.cpp
    title: "\u6570\u5B66/\u5199\u50CF12\u76F8/\u30B9\u30BF\u30FC\u30EA\u30F3\u30B0\
      \u6570/\u7B2C1\u7A2E\u30B9\u30BF\u30FC\u30EA\u30F3\u30B0\u6570\u306E\u6570\u8868\
      \ \u5F62\u5F0F\u7684\u51AA\u7D1A\u6570\u7248"
  - icon: ':heavy_check_mark:'
    path: test/math/twelvefold_way/stirling_number/stirling_number_of_the_second_kind_init_with_fps.test.cpp
    title: "\u6570\u5B66/\u5199\u50CF12\u76F8/\u30B9\u30BF\u30FC\u30EA\u30F3\u30B0\
      \u6570/\u7B2C2\u7A2E\u30B9\u30BF\u30FC\u30EA\u30F3\u30B0\u6570\u306E\u6570\u8868\
      \ \u5F62\u5F0F\u7684\u51AA\u7D1A\u6570\u7248"
  _isVerificationFailed: true
  _pathExtension: hpp
  _verificationStatusIcon: ':question:'
  attributes:
    links: []
  bundledCode: "#line 2 \"math/formal_power_series/formal_power_series.hpp\"\n#include\
    \ <algorithm>\r\n#include <cassert>\r\n#include <functional>\r\n#include <initializer_list>\r\
    \n#include <vector>\r\n\r\ntemplate <typename T>\r\nstruct FormalPowerSeries {\r\
    \n  using MUL = std::function<std::vector<T>(const std::vector<T>&, const std::vector<T>&)>;\r\
    \n  using SQR = std::function<bool(const T&, T&)>;\r\n  std::vector<T> co;\r\n\
    \  FormalPowerSeries(int deg = 0) : co(deg + 1, 0) {}\r\n  FormalPowerSeries(const\
    \ std::vector<T> &co) : co(co) {}\r\n  FormalPowerSeries(std::initializer_list<T>\
    \ init) : co(init.begin(), init.end()) {}\r\n  template <typename InputIter> FormalPowerSeries(InputIter\
    \ first, InputIter last) : co(first, last) {}\r\n  inline const T &operator[](int\
    \ term) const { return co[term]; }\r\n  inline T &operator[](int term) { return\
    \ co[term]; }\r\n  static void set_mul(MUL mul) { get_mul() = mul; }\r\n  static\
    \ void set_sqr(SQR sqr) { get_sqr() = sqr; }\r\n  void resize(int deg) { co.resize(deg\
    \ + 1, 0); }\r\n  void shrink() { while (co.size() > 1 && co.back() == 0) co.pop_back();\
    \ }\r\n  int degree() const { return static_cast<int>(co.size()) - 1; }\r\n  FormalPowerSeries\
    \ &operator=(const std::vector<T> &new_co) {\r\n    co.resize(new_co.size());\r\
    \n    std::copy(new_co.begin(), new_co.end(), co.begin());\r\n    return *this;\r\
    \n  }\r\n  FormalPowerSeries &operator=(const FormalPowerSeries &x) {\r\n    co.resize(x.co.size());\r\
    \n    std::copy(x.co.begin(), x.co.end(), co.begin());\r\n    return *this;\r\n\
    \  }\r\n  FormalPowerSeries &operator+=(const FormalPowerSeries &x) {\r\n    int\
    \ n = x.co.size();\r\n    if (n > co.size()) resize(n - 1);\r\n    for (int i\
    \ = 0; i < n; ++i) co[i] += x.co[i];\r\n    return *this;\r\n  }\r\n  FormalPowerSeries\
    \ &operator-=(const FormalPowerSeries &x) {\r\n    int n = x.co.size();\r\n  \
    \  if (n > co.size()) resize(n - 1);\r\n    for (int i = 0; i < n; ++i) co[i]\
    \ -= x.co[i];\r\n    return *this;\r\n  }\r\n  FormalPowerSeries &operator*=(T\
    \ x) {\r\n    for (T &e : co) e *= x;\r\n    return *this;\r\n  }\r\n  FormalPowerSeries\
    \ &operator*=(const FormalPowerSeries &x) { return *this = get_mul()(co, x.co);\
    \ }\r\n  FormalPowerSeries &operator/=(T x) {\r\n    assert(x != 0);\r\n    T\
    \ inv_x = static_cast<T>(1) / x;\r\n    for (T &e : co) e *= inv_x;\r\n    return\
    \ *this;\r\n  }\r\n  FormalPowerSeries &operator/=(const FormalPowerSeries &x)\
    \ {\r\n    int sz = x.co.size();\r\n    if (sz > co.size()) return *this = FormalPowerSeries();\r\
    \n    int n = co.size() - sz + 1;\r\n    FormalPowerSeries a(co.rbegin(), co.rbegin()\
    \ + n), b(x.co.rbegin(), x.co.rbegin() + std::min(sz, n));\r\n    b = b.inv(n\
    \ - 1);\r\n    a *= b;\r\n    return *this = FormalPowerSeries(a.co.rend() - n,\
    \ a.co.rend());\r\n  }\r\n  FormalPowerSeries &operator%=(const FormalPowerSeries\
    \ &x) {\r\n    *this -= *this / x * x;\r\n    co.resize(static_cast<int>(x.co.size())\
    \ - 1);\r\n    if (co.empty()) co = {0};\r\n    return *this;\r\n  }\r\n  FormalPowerSeries\
    \ &operator<<=(int n) {\r\n    co.insert(co.begin(), n, 0);\r\n    return *this;\r\
    \n  }\r\n  FormalPowerSeries &operator>>=(int n) {\r\n    if (co.size() < n) return\
    \ *this = FormalPowerSeries();\r\n    co.erase(co.begin(), co.begin() + n);\r\n\
    \    return *this;\r\n  }\r\n  bool operator==(const FormalPowerSeries &x) const\
    \ {\r\n    FormalPowerSeries a(*this), b(x);\r\n    a.shrink(); b.shrink();\r\n\
    \    int n = a.co.size();\r\n    if (n != b.co.size()) return false;\r\n    for\
    \ (int i = 0; i < n; ++i) if (a.co[i] != b.co[i]) return false;\r\n    return\
    \ true;\r\n  }\r\n  bool operator!=(const FormalPowerSeries &x) const { return\
    \ !(*this == x); }\r\n  FormalPowerSeries operator+() const { return *this; }\r\
    \n  FormalPowerSeries operator-() const {\r\n    FormalPowerSeries res(*this);\r\
    \n    for (T &e : res.co) e = -e;\r\n    return res;\r\n  }\r\n  FormalPowerSeries\
    \ operator+(const FormalPowerSeries &x) const { return FormalPowerSeries(*this)\
    \ += x; }\r\n  FormalPowerSeries operator-(const FormalPowerSeries &x) const {\
    \ return FormalPowerSeries(*this) -= x; }\r\n  FormalPowerSeries operator*(T x)\
    \ const { return FormalPowerSeries(*this) *= x; }\r\n  FormalPowerSeries operator*(const\
    \ FormalPowerSeries &x) const { return FormalPowerSeries(*this) *= x; }\r\n  FormalPowerSeries\
    \ operator/(T x) const { return FormalPowerSeries(*this) /= x; }\r\n  FormalPowerSeries\
    \ operator/(const FormalPowerSeries &x) const { return FormalPowerSeries(*this)\
    \ /= x; }\r\n  FormalPowerSeries operator%(const FormalPowerSeries &x) const {\
    \ return FormalPowerSeries(*this) %= x; }\r\n  FormalPowerSeries operator<<(int\
    \ n) const { return FormalPowerSeries(*this) <<= n; }\r\n  FormalPowerSeries operator>>(int\
    \ n) const { return FormalPowerSeries(*this) >>= n; }\r\n  T horner(T x) const\
    \ {\r\n    T res = 0;\r\n    for (int i = static_cast<int>(co.size()) - 1; i >=\
    \ 0; --i) (res *= x) += co[i];\r\n    return res;\r\n  }\r\n  FormalPowerSeries\
    \ differential() const {\r\n    int n = co.size();\r\n    assert(n >= 1);\r\n\
    \    FormalPowerSeries res(n - 1);\r\n    for (int i = 1; i < n; ++i) res.co[i\
    \ - 1] = co[i] * i;\r\n    return res;\r\n  }\r\n  FormalPowerSeries integral()\
    \ const {\r\n    int n = co.size();\r\n    FormalPowerSeries res(n + 1);\r\n \
    \   for (int i = 0; i < n; ++i) res[i + 1] = co[i] / (i + 1);\r\n    return res;\r\
    \n  }\r\n  FormalPowerSeries exp(int deg = -1) const {\r\n    assert(co[0] ==\
    \ 0);\r\n    int n = co.size();\r\n    if (deg == -1) deg = n - 1;\r\n    FormalPowerSeries\
    \ one{1}, res = one;\r\n    for (int i = 1; i <= deg; i <<= 1) {\r\n      res\
    \ *= FormalPowerSeries(co.begin(), co.begin() + std::min(n, i << 1)) - res.log((i\
    \ << 1) - 1) + one;\r\n      res.co.resize(i << 1);\r\n    }\r\n    res.co.resize(deg\
    \ + 1);\r\n    return res;\r\n  }\r\n  FormalPowerSeries inv(int deg = -1) const\
    \ {\r\n    assert(co[0] != 0);\r\n    int n = co.size();\r\n    if (deg == -1)\
    \ deg = n - 1;\r\n    FormalPowerSeries res{static_cast<T>(1) / co[0]};\r\n  \
    \  for (int i = 1; i <= deg; i <<= 1) {\r\n      res = res + res - res * res *\
    \ FormalPowerSeries(co.begin(), co.begin() + std::min(n, i << 1));\r\n      res.co.resize(i\
    \ << 1);\r\n    }\r\n    res.co.resize(deg + 1);\r\n    return res;\r\n  }\r\n\
    \  FormalPowerSeries log(int deg = -1) const {\r\n    assert(co[0] == 1);\r\n\
    \    if (deg == -1) deg = static_cast<int>(co.size()) - 1;\r\n    FormalPowerSeries\
    \ integrand = differential() * inv(deg - 1);\r\n    integrand.co.resize(deg);\r\
    \n    return integrand.integral();\r\n  }\r\n  FormalPowerSeries pow(long long\
    \ exponent, int deg = -1) const {\r\n    int n = co.size();\r\n    if (deg ==\
    \ -1) deg = n - 1;\r\n    for (int i = 0; i < n; ++i) {\r\n      if (co[i] !=\
    \ 0) {\r\n        long long shift = exponent * i;\r\n        if (shift > deg)\
    \ break;\r\n        T tmp = 1, base = co[i];\r\n        long long e = exponent;\r\
    \n        while (e > 0) {\r\n          if (e & 1) tmp *= base;\r\n          base\
    \ *= base;\r\n          e >>= 1;\r\n        }\r\n        return ((((*this >> i)\
    \ * (static_cast<T>(1) / co[i])).log(deg - shift)\r\n                * static_cast<T>(exponent)).exp(deg\
    \ - shift) * tmp)\r\n               << shift;\r\n      }\r\n    }\r\n    return\
    \ FormalPowerSeries(deg);\r\n  }\r\n  FormalPowerSeries mod_pow(long long exponent,\
    \ const FormalPowerSeries &md) const {\r\n    FormalPowerSeries inv_rev_md = FormalPowerSeries(md.co.rbegin(),\
    \ md.co.rend()).inv();\r\n    int deg_of_md = md.co.size();\r\n    auto mod_mul\
    \ = [&](FormalPowerSeries &multiplicand, const FormalPowerSeries &multiplier)\
    \ -> void {\r\n      multiplicand *= multiplier;\r\n      if (deg_of_md <= multiplicand.co.size())\
    \ {\r\n        int n = multiplicand.co.size() - deg_of_md + 1;\r\n        FormalPowerSeries\
    \ quotient =\r\n          FormalPowerSeries(multiplicand.co.rbegin(), multiplicand.co.rbegin()\
    \ + n)\r\n          * FormalPowerSeries(inv_rev_md.co.begin(), inv_rev_md.co.begin()\
    \ + std::min(static_cast<int>(inv_rev_md.co.size()), n));\r\n        multiplicand\
    \ -= FormalPowerSeries(quotient.co.rend() - n, quotient.co.rend()) * md;\r\n \
    \     }\r\n      multiplicand.co.resize(deg_of_md - 1);\r\n      if (multiplicand.co.empty())\
    \ multiplicand.co = {0};\r\n    };\r\n    FormalPowerSeries res{1}, base = *this;\r\
    \n    mod_mul(base, res);\r\n    while (exponent > 0) {\r\n      if (exponent\
    \ & 1) mod_mul(res, base);\r\n      mod_mul(base, base);\r\n      exponent >>=\
    \ 1;\r\n    }\r\n    return res;\r\n  }\r\n  FormalPowerSeries sqrt(int deg =\
    \ -1) const {\r\n    int n = co.size();\r\n    if (deg == -1) deg = n - 1;\r\n\
    \    if (co[0] == 0) {\r\n      for (int i = 1; i < n; ++i) {\r\n        if (co[i]\
    \ == 0) continue;\r\n        if (i & 1) return FormalPowerSeries(-1);\r\n    \
    \    int shift = i >> 1;\r\n        if (deg < shift) break;\r\n        FormalPowerSeries\
    \ res = (*this >> i).sqrt(deg - shift);\r\n        if (res.co.empty()) return\
    \ FormalPowerSeries(-1);\r\n        res <<= shift;\r\n        res.resize(deg);\r\
    \n        return res;\r\n      }\r\n      return FormalPowerSeries(deg);\r\n \
    \   }\r\n    T s;\r\n    if (!get_sqr()(co[0], s)) return FormalPowerSeries(-1);\r\
    \n    FormalPowerSeries res{s};\r\n    T half = static_cast<T>(1) / 2;\r\n   \
    \ for (int i = 1; i <= deg; i <<= 1) {\r\n      (res += FormalPowerSeries(co.begin(),\
    \ co.begin() + std::min(n, i << 1)) * res.inv((i << 1) - 1)) *= half;\r\n    }\r\
    \n    res.resize(deg);\r\n    return res;\r\n  }\r\n  FormalPowerSeries translate(T\
    \ c) const {\r\n    int n = co.size();\r\n    std::vector<T> fact(n, 1), inv_fact(n,\
    \ 1);\r\n    for (int i = 1; i < n; ++i) fact[i] = fact[i - 1] * i;\r\n    inv_fact[n\
    \ - 1] = static_cast<T>(1) / fact[n - 1];\r\n    for (int i = n - 1; i > 0; --i)\
    \ inv_fact[i - 1] = inv_fact[i] * i;\r\n    std::vector<T> g(n), ex(n);\r\n  \
    \  for (int i = 0; i < n; ++i) g[n - 1 - i] = co[i] * fact[i];\r\n    T pow_c\
    \ = 1;\r\n    for (int i = 0; i < n; ++i) {\r\n      ex[i] = pow_c * inv_fact[i];\r\
    \n      pow_c *= c;\r\n    }\r\n    std::vector<T> conv = get_mul()(g, ex);\r\n\
    \    FormalPowerSeries res(n - 1);\r\n    for (int i = 0; i < n; ++i) res[i] =\
    \ conv[n - 1 - i] * inv_fact[i];\r\n    return res;\r\n  }\r\nprivate:\r\n  static\
    \ MUL &get_mul() {\r\n    static MUL mul = [](const std::vector<T> &a, const std::vector<T>\
    \ &b) -> std::vector<T> {\r\n      int n = a.size(), m = b.size();\r\n      std::vector<T>\
    \ res(n + m - 1, 0);\r\n      for (int i = 0; i < n; ++i) for (int j = 0; j <\
    \ m; ++j) res[i + j] += a[i] * b[j];\r\n      return res;\r\n    };\r\n    return\
    \ mul;\r\n  }\r\n  static SQR &get_sqr() {\r\n    static SQR sqr = [](const T\
    \ &a, T &res) -> bool { return false; };\r\n    return sqr;\r\n  }\r\n};\r\n"
  code: "#pragma once\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <functional>\r\
    \n#include <initializer_list>\r\n#include <vector>\r\n\r\ntemplate <typename T>\r\
    \nstruct FormalPowerSeries {\r\n  using MUL = std::function<std::vector<T>(const\
    \ std::vector<T>&, const std::vector<T>&)>;\r\n  using SQR = std::function<bool(const\
    \ T&, T&)>;\r\n  std::vector<T> co;\r\n  FormalPowerSeries(int deg = 0) : co(deg\
    \ + 1, 0) {}\r\n  FormalPowerSeries(const std::vector<T> &co) : co(co) {}\r\n\
    \  FormalPowerSeries(std::initializer_list<T> init) : co(init.begin(), init.end())\
    \ {}\r\n  template <typename InputIter> FormalPowerSeries(InputIter first, InputIter\
    \ last) : co(first, last) {}\r\n  inline const T &operator[](int term) const {\
    \ return co[term]; }\r\n  inline T &operator[](int term) { return co[term]; }\r\
    \n  static void set_mul(MUL mul) { get_mul() = mul; }\r\n  static void set_sqr(SQR\
    \ sqr) { get_sqr() = sqr; }\r\n  void resize(int deg) { co.resize(deg + 1, 0);\
    \ }\r\n  void shrink() { while (co.size() > 1 && co.back() == 0) co.pop_back();\
    \ }\r\n  int degree() const { return static_cast<int>(co.size()) - 1; }\r\n  FormalPowerSeries\
    \ &operator=(const std::vector<T> &new_co) {\r\n    co.resize(new_co.size());\r\
    \n    std::copy(new_co.begin(), new_co.end(), co.begin());\r\n    return *this;\r\
    \n  }\r\n  FormalPowerSeries &operator=(const FormalPowerSeries &x) {\r\n    co.resize(x.co.size());\r\
    \n    std::copy(x.co.begin(), x.co.end(), co.begin());\r\n    return *this;\r\n\
    \  }\r\n  FormalPowerSeries &operator+=(const FormalPowerSeries &x) {\r\n    int\
    \ n = x.co.size();\r\n    if (n > co.size()) resize(n - 1);\r\n    for (int i\
    \ = 0; i < n; ++i) co[i] += x.co[i];\r\n    return *this;\r\n  }\r\n  FormalPowerSeries\
    \ &operator-=(const FormalPowerSeries &x) {\r\n    int n = x.co.size();\r\n  \
    \  if (n > co.size()) resize(n - 1);\r\n    for (int i = 0; i < n; ++i) co[i]\
    \ -= x.co[i];\r\n    return *this;\r\n  }\r\n  FormalPowerSeries &operator*=(T\
    \ x) {\r\n    for (T &e : co) e *= x;\r\n    return *this;\r\n  }\r\n  FormalPowerSeries\
    \ &operator*=(const FormalPowerSeries &x) { return *this = get_mul()(co, x.co);\
    \ }\r\n  FormalPowerSeries &operator/=(T x) {\r\n    assert(x != 0);\r\n    T\
    \ inv_x = static_cast<T>(1) / x;\r\n    for (T &e : co) e *= inv_x;\r\n    return\
    \ *this;\r\n  }\r\n  FormalPowerSeries &operator/=(const FormalPowerSeries &x)\
    \ {\r\n    int sz = x.co.size();\r\n    if (sz > co.size()) return *this = FormalPowerSeries();\r\
    \n    int n = co.size() - sz + 1;\r\n    FormalPowerSeries a(co.rbegin(), co.rbegin()\
    \ + n), b(x.co.rbegin(), x.co.rbegin() + std::min(sz, n));\r\n    b = b.inv(n\
    \ - 1);\r\n    a *= b;\r\n    return *this = FormalPowerSeries(a.co.rend() - n,\
    \ a.co.rend());\r\n  }\r\n  FormalPowerSeries &operator%=(const FormalPowerSeries\
    \ &x) {\r\n    *this -= *this / x * x;\r\n    co.resize(static_cast<int>(x.co.size())\
    \ - 1);\r\n    if (co.empty()) co = {0};\r\n    return *this;\r\n  }\r\n  FormalPowerSeries\
    \ &operator<<=(int n) {\r\n    co.insert(co.begin(), n, 0);\r\n    return *this;\r\
    \n  }\r\n  FormalPowerSeries &operator>>=(int n) {\r\n    if (co.size() < n) return\
    \ *this = FormalPowerSeries();\r\n    co.erase(co.begin(), co.begin() + n);\r\n\
    \    return *this;\r\n  }\r\n  bool operator==(const FormalPowerSeries &x) const\
    \ {\r\n    FormalPowerSeries a(*this), b(x);\r\n    a.shrink(); b.shrink();\r\n\
    \    int n = a.co.size();\r\n    if (n != b.co.size()) return false;\r\n    for\
    \ (int i = 0; i < n; ++i) if (a.co[i] != b.co[i]) return false;\r\n    return\
    \ true;\r\n  }\r\n  bool operator!=(const FormalPowerSeries &x) const { return\
    \ !(*this == x); }\r\n  FormalPowerSeries operator+() const { return *this; }\r\
    \n  FormalPowerSeries operator-() const {\r\n    FormalPowerSeries res(*this);\r\
    \n    for (T &e : res.co) e = -e;\r\n    return res;\r\n  }\r\n  FormalPowerSeries\
    \ operator+(const FormalPowerSeries &x) const { return FormalPowerSeries(*this)\
    \ += x; }\r\n  FormalPowerSeries operator-(const FormalPowerSeries &x) const {\
    \ return FormalPowerSeries(*this) -= x; }\r\n  FormalPowerSeries operator*(T x)\
    \ const { return FormalPowerSeries(*this) *= x; }\r\n  FormalPowerSeries operator*(const\
    \ FormalPowerSeries &x) const { return FormalPowerSeries(*this) *= x; }\r\n  FormalPowerSeries\
    \ operator/(T x) const { return FormalPowerSeries(*this) /= x; }\r\n  FormalPowerSeries\
    \ operator/(const FormalPowerSeries &x) const { return FormalPowerSeries(*this)\
    \ /= x; }\r\n  FormalPowerSeries operator%(const FormalPowerSeries &x) const {\
    \ return FormalPowerSeries(*this) %= x; }\r\n  FormalPowerSeries operator<<(int\
    \ n) const { return FormalPowerSeries(*this) <<= n; }\r\n  FormalPowerSeries operator>>(int\
    \ n) const { return FormalPowerSeries(*this) >>= n; }\r\n  T horner(T x) const\
    \ {\r\n    T res = 0;\r\n    for (int i = static_cast<int>(co.size()) - 1; i >=\
    \ 0; --i) (res *= x) += co[i];\r\n    return res;\r\n  }\r\n  FormalPowerSeries\
    \ differential() const {\r\n    int n = co.size();\r\n    assert(n >= 1);\r\n\
    \    FormalPowerSeries res(n - 1);\r\n    for (int i = 1; i < n; ++i) res.co[i\
    \ - 1] = co[i] * i;\r\n    return res;\r\n  }\r\n  FormalPowerSeries integral()\
    \ const {\r\n    int n = co.size();\r\n    FormalPowerSeries res(n + 1);\r\n \
    \   for (int i = 0; i < n; ++i) res[i + 1] = co[i] / (i + 1);\r\n    return res;\r\
    \n  }\r\n  FormalPowerSeries exp(int deg = -1) const {\r\n    assert(co[0] ==\
    \ 0);\r\n    int n = co.size();\r\n    if (deg == -1) deg = n - 1;\r\n    FormalPowerSeries\
    \ one{1}, res = one;\r\n    for (int i = 1; i <= deg; i <<= 1) {\r\n      res\
    \ *= FormalPowerSeries(co.begin(), co.begin() + std::min(n, i << 1)) - res.log((i\
    \ << 1) - 1) + one;\r\n      res.co.resize(i << 1);\r\n    }\r\n    res.co.resize(deg\
    \ + 1);\r\n    return res;\r\n  }\r\n  FormalPowerSeries inv(int deg = -1) const\
    \ {\r\n    assert(co[0] != 0);\r\n    int n = co.size();\r\n    if (deg == -1)\
    \ deg = n - 1;\r\n    FormalPowerSeries res{static_cast<T>(1) / co[0]};\r\n  \
    \  for (int i = 1; i <= deg; i <<= 1) {\r\n      res = res + res - res * res *\
    \ FormalPowerSeries(co.begin(), co.begin() + std::min(n, i << 1));\r\n      res.co.resize(i\
    \ << 1);\r\n    }\r\n    res.co.resize(deg + 1);\r\n    return res;\r\n  }\r\n\
    \  FormalPowerSeries log(int deg = -1) const {\r\n    assert(co[0] == 1);\r\n\
    \    if (deg == -1) deg = static_cast<int>(co.size()) - 1;\r\n    FormalPowerSeries\
    \ integrand = differential() * inv(deg - 1);\r\n    integrand.co.resize(deg);\r\
    \n    return integrand.integral();\r\n  }\r\n  FormalPowerSeries pow(long long\
    \ exponent, int deg = -1) const {\r\n    int n = co.size();\r\n    if (deg ==\
    \ -1) deg = n - 1;\r\n    for (int i = 0; i < n; ++i) {\r\n      if (co[i] !=\
    \ 0) {\r\n        long long shift = exponent * i;\r\n        if (shift > deg)\
    \ break;\r\n        T tmp = 1, base = co[i];\r\n        long long e = exponent;\r\
    \n        while (e > 0) {\r\n          if (e & 1) tmp *= base;\r\n          base\
    \ *= base;\r\n          e >>= 1;\r\n        }\r\n        return ((((*this >> i)\
    \ * (static_cast<T>(1) / co[i])).log(deg - shift)\r\n                * static_cast<T>(exponent)).exp(deg\
    \ - shift) * tmp)\r\n               << shift;\r\n      }\r\n    }\r\n    return\
    \ FormalPowerSeries(deg);\r\n  }\r\n  FormalPowerSeries mod_pow(long long exponent,\
    \ const FormalPowerSeries &md) const {\r\n    FormalPowerSeries inv_rev_md = FormalPowerSeries(md.co.rbegin(),\
    \ md.co.rend()).inv();\r\n    int deg_of_md = md.co.size();\r\n    auto mod_mul\
    \ = [&](FormalPowerSeries &multiplicand, const FormalPowerSeries &multiplier)\
    \ -> void {\r\n      multiplicand *= multiplier;\r\n      if (deg_of_md <= multiplicand.co.size())\
    \ {\r\n        int n = multiplicand.co.size() - deg_of_md + 1;\r\n        FormalPowerSeries\
    \ quotient =\r\n          FormalPowerSeries(multiplicand.co.rbegin(), multiplicand.co.rbegin()\
    \ + n)\r\n          * FormalPowerSeries(inv_rev_md.co.begin(), inv_rev_md.co.begin()\
    \ + std::min(static_cast<int>(inv_rev_md.co.size()), n));\r\n        multiplicand\
    \ -= FormalPowerSeries(quotient.co.rend() - n, quotient.co.rend()) * md;\r\n \
    \     }\r\n      multiplicand.co.resize(deg_of_md - 1);\r\n      if (multiplicand.co.empty())\
    \ multiplicand.co = {0};\r\n    };\r\n    FormalPowerSeries res{1}, base = *this;\r\
    \n    mod_mul(base, res);\r\n    while (exponent > 0) {\r\n      if (exponent\
    \ & 1) mod_mul(res, base);\r\n      mod_mul(base, base);\r\n      exponent >>=\
    \ 1;\r\n    }\r\n    return res;\r\n  }\r\n  FormalPowerSeries sqrt(int deg =\
    \ -1) const {\r\n    int n = co.size();\r\n    if (deg == -1) deg = n - 1;\r\n\
    \    if (co[0] == 0) {\r\n      for (int i = 1; i < n; ++i) {\r\n        if (co[i]\
    \ == 0) continue;\r\n        if (i & 1) return FormalPowerSeries(-1);\r\n    \
    \    int shift = i >> 1;\r\n        if (deg < shift) break;\r\n        FormalPowerSeries\
    \ res = (*this >> i).sqrt(deg - shift);\r\n        if (res.co.empty()) return\
    \ FormalPowerSeries(-1);\r\n        res <<= shift;\r\n        res.resize(deg);\r\
    \n        return res;\r\n      }\r\n      return FormalPowerSeries(deg);\r\n \
    \   }\r\n    T s;\r\n    if (!get_sqr()(co[0], s)) return FormalPowerSeries(-1);\r\
    \n    FormalPowerSeries res{s};\r\n    T half = static_cast<T>(1) / 2;\r\n   \
    \ for (int i = 1; i <= deg; i <<= 1) {\r\n      (res += FormalPowerSeries(co.begin(),\
    \ co.begin() + std::min(n, i << 1)) * res.inv((i << 1) - 1)) *= half;\r\n    }\r\
    \n    res.resize(deg);\r\n    return res;\r\n  }\r\n  FormalPowerSeries translate(T\
    \ c) const {\r\n    int n = co.size();\r\n    std::vector<T> fact(n, 1), inv_fact(n,\
    \ 1);\r\n    for (int i = 1; i < n; ++i) fact[i] = fact[i - 1] * i;\r\n    inv_fact[n\
    \ - 1] = static_cast<T>(1) / fact[n - 1];\r\n    for (int i = n - 1; i > 0; --i)\
    \ inv_fact[i - 1] = inv_fact[i] * i;\r\n    std::vector<T> g(n), ex(n);\r\n  \
    \  for (int i = 0; i < n; ++i) g[n - 1 - i] = co[i] * fact[i];\r\n    T pow_c\
    \ = 1;\r\n    for (int i = 0; i < n; ++i) {\r\n      ex[i] = pow_c * inv_fact[i];\r\
    \n      pow_c *= c;\r\n    }\r\n    std::vector<T> conv = get_mul()(g, ex);\r\n\
    \    FormalPowerSeries res(n - 1);\r\n    for (int i = 0; i < n; ++i) res[i] =\
    \ conv[n - 1 - i] * inv_fact[i];\r\n    return res;\r\n  }\r\nprivate:\r\n  static\
    \ MUL &get_mul() {\r\n    static MUL mul = [](const std::vector<T> &a, const std::vector<T>\
    \ &b) -> std::vector<T> {\r\n      int n = a.size(), m = b.size();\r\n      std::vector<T>\
    \ res(n + m - 1, 0);\r\n      for (int i = 0; i < n; ++i) for (int j = 0; j <\
    \ m; ++j) res[i + j] += a[i] * b[j];\r\n      return res;\r\n    };\r\n    return\
    \ mul;\r\n  }\r\n  static SQR &get_sqr() {\r\n    static SQR sqr = [](const T\
    \ &a, T &res) -> bool { return false; };\r\n    return sqr;\r\n  }\r\n};\r\n"
  dependsOn: []
  isVerificationFile: false
  path: math/formal_power_series/formal_power_series.hpp
  requiredBy:
  - dynamic_programming/subset_sum_problem.hpp
  - math/twelvefold_way/bell_number/bell_number_init_by_fps.hpp
  - math/twelvefold_way/partition_function_init_by_fps.hpp
  - math/twelvefold_way/stirling_number/stirling_number_of_the_second_kind_init_by_fps.hpp
  - math/twelvefold_way/stirling_number/stirling_number_of_the_first_kind_init_by_fps.hpp
  - math/formal_power_series/faulhaber_by_fps.hpp
  - math/formal_power_series/eulerian_number_init_by_fps.hpp
  - math/formal_power_series/bernoulli_number.hpp
  timestamp: '2021-04-27 20:17:50+09:00'
  verificationStatus: LIBRARY_SOME_WA
  verifiedWith:
  - test/dynamic_programming/subset_sum_problem.test.cpp
  - test/math/twelvefold_way/partition_function_init_by_fps.test.cpp
  - test/math/twelvefold_way/stirling_number/stirling_number_of_the_first_kind_init_with_fps.test.cpp
  - test/math/twelvefold_way/stirling_number/stirling_number_of_the_second_kind_init_with_fps.test.cpp
  - test/math/formal_power_series/formal_power_series.2.test.cpp
  - test/math/formal_power_series/multipoint_evaluation.test.cpp
  - test/math/formal_power_series/polynomial_interpolation.test.cpp
  - test/math/formal_power_series/bernoulli_number.test.cpp
  - test/math/formal_power_series/formal_power_series.1.test.cpp
  - test/math/formal_power_series/formal_power_series.6.test.cpp
  - test/math/formal_power_series/formal_power_series.3.test.cpp
  - test/math/formal_power_series/formal_power_series.4.test.cpp
  - test/math/formal_power_series/formal_power_series.5.test.cpp
  - test/math/formal_power_series/faulhaber_by_fps.test.cpp
  - test/math/formal_power_series/formal_power_series.7.test.cpp
documentation_of: math/formal_power_series/formal_power_series.hpp
layout: document
title: "\u5F62\u5F0F\u7684\u51AA\u7D1A\u6570 (formal power series)"
---


### 操作

- 累積和

  $$(1 + x^r + x^{2r} + \cdots)f = f \sum_{n = 0}^{\infty} x^{rn} = \dfrac{f}{1 - x^r} \text{．}$$

  特に $r = 1$ のとき

  $$(1 + x + x^2 + \cdots)f = f \sum_{n = 0}^{\infty} x^n = \dfrac{f}{1 - x} \text{．}$$

- 階差数列

  $$\sum_{n = 0}^{\infty} (A_n - A_{n - 1}) x^n = (1 - x)f \text{．}$$

- [部分和問題](../../dynamic_programming/subset_sum_problem.md)

  $$\prod_{i = 1}^N (1 + x^{C_i}) = \exp \left(\sum_{i = 0}^D \sum_{j = 1}^{\left\lfloor \frac{D}{j} \right\rfloor} \# \lbrace k \mid C_k = i \rbrace \dfrac{(-1)^{j - 1}}{j} x^{ji}\right) \bmod x^{D + 1} \text{．}$$


### 公式

- [重複組み合わせ](modint.md)

  $N$ 種類存在するとき

  $$\sum_{n = 0}^{\infty} \binom{N + n - 1}{n} x^n = \dfrac{1}{(1 - x)^N} \text{．}$$

- [二項係数](twelvefold_way/binomial_coefficient/binomial_coefficient.md)

  $$(x + y)^n = \sum_{k = 0}^{\infty} \binom{n}{k} x^k y^{n - k} \text{，}$$

  $$(1 - rx)^{-d} = \sum_{n = 0}^{\infty} \binom{n + d - 1}{d - 1} (rx)^n \text{．}$$


## 時間計算量

||時間計算量|
|:--:|:--:|
|加減算|$O(N)$|
|スカラー倍|$O(N)$|
|乗算|$O(N\log{N})$|
|除算|$O(N\log{N})$|
|剰余演算|$O(N\log{N})$|
|ホーナー法 (Horner's rule)|$O(N)$|
|形式微積分|$O(N)$|
|指数|$O(N\log{N})$|
|逆元|$O(N\log{N})$|
|対数|$O(N\log{N})$|
|冪乗|$O(N\log{N} + \log{M})$|
|`mod_pow(exponent, md)`|$O((N + M)\log(N + M)\log{E})$ ?|
|平方根|数 $M$ の平方根を求めるときの計算量を $f(M)$ とおくと $O(N\log{N} + f(M))$．|
|`translate(c)`|$O(N\log{N})$|


## 使用法

||説明|備考|
|:--:|:--:|:--:|
|`FormalPowerSeries<T>(deg = 0)`|次数 $\mathrm{deg}$ の形式的冪級数||
|`FormalPowerSeries<T>(co)`|数列 $\mathrm{co}$ の母関数||
|`co`|係数||
|`operator()[term]`|${\lbrack x^{\mathrm{term}} \rbrack}f$||
|`set_mul(mul)`|乗算を定義する．||
|`set_sqr(sqr)`|平方根の計算を定義する．||
|`resize(deg)`|先頭 $\mathrm{deg}$ 次を考える．||
|`shrink()`|正規化を行う．||
|`degree()`|次数||
|`operator=(new_co)`|数列 $\mathrm{new\_co}$ を代入する．||
|`operator=(x)`|形式的冪級数 $x$ を代入する．||
|`operator+=(x)`<br>`operator+(x)`|加算||
|`operator-=(x)`<br>`operator-(x)`|減算||
|`operator*=(x)`<br>`operator*(x)`|乗算||
|`operator/=(x)`<br>`operator/(x)`|除算||
|`operator%=(x)`<br>`operator%(x)`|剰余演算||
|`operator<<=(n)`<br>`operator<<(n)`|$x^n f$||
|`operator>>=(n)`<br>`operator>>(n)`|$x^{-n} f$|$\mathrm{deg}(f) < n$ のとき $0$ となる．|
|`operator==(x)`|$f = x$ であるか．||
|`operator!=(x)`|$f \neq x$ であるか．||
|`operator+()`|$+{f}$||
|`operator-()`|$-{f}$||
|`horner(x)`|$f(x)$||
|`differential()`|$f^{\prime}$|$\mathrm{deg}(f) \geq 0$|
|`integral()`|$\int{f}$||
|`exp(deg = n)`|$\exp(f)$|${\lbrack x^0 \rbrack}f = 0$|
|`inv(deg = n)`|$g \text{ s.t. } f \cdot g \equiv 1 \pmod{x^{\mathrm{deg} + 1}}$|${\lbrack x^0 \rbrack}f \neq 0$|
|`log(deg = n)`|$\ln{f}$|${\lbrack x^0 \rbrack}f = 1$|
|`pow(exponent, deg = n)`|$f^{\mathrm{exponent}}$||
|`mod_pow(exponent, md)`|$f^{\mathrm{exponent}} \bmod \mathrm{md}$||
|`sqrt(deg = n)`|$\sqrt{f}$|存在しない場合は空列となる．|
|`translate(c)`|$f(x + c)$||


## 参考

- ~~http://lattemalta.hatenablog.jp/entry/2019/09/29/231332~~
- https://maspypy.com/category/%e5%bd%a2%e5%bc%8f%e7%9a%84%e3%81%b9%e3%81%8d%e7%b4%9a%e6%95%b0%e8%a7%a3%e8%aa%ac
- https://science-log.com/%e3%83%9b%e3%83%bc%e3%83%a0%e3%83%9a%e3%83%bc%e3%82%b8/%e6%95%b0%e5%ad%a6top%e3%83%9a%e3%83%bc%e3%82%b8/%e8%a7%a3%e6%9e%90top/%e6%af%8d%e9%96%a2%e6%95%b0%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6/
- https://codeforces.com/blog/entry/56422
- ~~http://sugarknri.hatenablog.com/entry/2019/10/08/001359~~
- https://github.com/ei1333/library/tree/d7e8da80351ac962978692b1a60d2728783afb26/math/fps
- https://yukicoder.me/wiki/polynomial_techniques


## ToDo

- https://yukicoder.me/wiki/polynomial_techniques
- https://drive.google.com/drive/folders/1CI4P9TUWcK_sGLkUBsA4ORNilIcNjB-N
- $g(f(x))$ を $O((N\log{N})^{1.5})$ で求める．
  - http://www.eecs.harvard.edu/~htk/publication/1978-jacm-brent-kung.pdf
  - https://judge.yosupo.jp/problem/composition_of_formal_power_series
- $\arcsin{f}$
  - https://codeforces.com/blog/entry/56422?#comment-401173
  - https://codeforces.com/blog/entry/56422?#comment-401217
  - https://codeforces.com/blog/entry/56422?#comment-401351
- Berlekamp–Massey algorithm
  - https://en.wikipedia.org/wiki/Berlekamp%E2%80%93Massey_algorithm
  - https://de.wikipedia.org/wiki/Berlekamp-Massey-Algorithmus
  - https://yukicoder.me/wiki/polynomial_techniques
  - http://sugarknri.hatenablog.com/entry/2017/11/18/234217
  - https://qiita.com/kenmaro/items/4042b646d39255b623b8
  - https://haruya12.hatenadiary.org/entry/20160131/1454252059
  - https://github.com/beet-aizu/library/blob/master/polynomial/berlekampmassey.cpp
  - https://github.com/ei1333/library/blob/master/math/fps/berlekamp-massey.cpp
  - https://yukicoder.me/submissions/427818
  - https://judge.yosupo.jp/problem/find_linear_recurrence
- $x^n \bmod f(x)$
  - https://qiita.com/ryuhe1/items/c18ddbb834eed724a42b
- 多項式ハッシュ
  - https://yukicoder.me/wiki/polynomial_techniques
  - https://github.com/beet-aizu/library/blob/master/polynomial/hash.cpp


## Verified

- [指数](https://judge.yosupo.jp/submission/3788)
- [逆元](https://judge.yosupo.jp/submission/3787)
- [対数](https://judge.yosupo.jp/submission/3790)
- [累乗](https://judge.yosupo.jp/submission/7464)
- [`mod_pow(exponent, md)`](https://atcoder.jp/contests/abc135/submissions/10197576)
- [平方根](https://judge.yosupo.jp/submission/3786)
- [`translate(c)`](https://judge.yosupo.jp/submission/8212)
